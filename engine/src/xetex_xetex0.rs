#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]

use std::io::Write;

use super::xetex_io::{
    bytesFromUTF8, make_utf16_name, name_of_input_file, offsetsFromUTF8, tt_xetex_open_input,
    u_open_in,
};
use crate::core_memory::{mfree, xmalloc, xrealloc};
#[cfg(target_os = "macos")]
use crate::xetex_aatfont as aat;
use crate::xetex_errors::{confusion, error, fatal_error, overflow, pdf_error};
use crate::xetex_ext::{
    apply_mapping, apply_tfm_font_mapping, check_for_tfm_font_mapping, find_native_font,
    get_encoding_mode_and_info, get_font_char_range, get_glyph_bounds,
    get_native_char_height_depth, get_native_char_sidebearings, getnativechardp, getnativecharht,
    getnativecharic, getnativecharwd, gr_font_get_named, gr_font_get_named_1, gr_print_font_name,
    linebreak_next, linebreak_start, load_tfm_font_mapping, map_char_to_glyph, map_glyph_to_index,
    measure_native_glyph, measure_native_node, ot_font_get, ot_font_get_1, ot_font_get_2,
    ot_font_get_3, ot_get_font_metrics, print_glyph_name, print_utf8_str,
    real_get_native_glyph_italic_correction, real_get_native_italic_correction,
    real_get_native_word_cp, release_font_engine,
};
use crate::xetex_ini::{
    _xeq_level_array, active_width, adjust_tail, after_token, align_ptr, align_state,
    area_delimiter, arith_error, avail, base_ptr, bchar, bchar_label, best_height_plus_depth,
    breadth_max, buf_size, buffer, cancel_boundary, char_base, cond_ptr, cur_align, cur_area,
    cur_boundary, cur_box, cur_chr, cur_cmd, cur_cs, cur_dir, cur_ext, cur_group, cur_head, cur_if,
    cur_input, cur_l, cur_lang, cur_level, cur_list, cur_loop, cur_mark, cur_name, cur_order,
    cur_pre_head, cur_pre_tail, cur_ptr, cur_q, cur_r, cur_span, cur_tail, cur_tok, cur_val,
    cur_val1, cur_val_level, dead_cycles, def_ref, deletions_allowed, depth_base, depth_threshold,
    dig, disc_ptr, empty, eof_seen, eqtb, eqtb_top, error_count, error_line, expand_depth,
    expand_depth_count, ext_delimiter, exten_base, false_bchar, file_line_error_style_p,
    file_name_quote_char, file_offset, first, first_count, fmem_ptr, font_area, font_bc,
    font_bchar, font_check, font_dsize, font_ec, font_false_bchar, font_flags, font_glue,
    font_in_short_display, font_info, font_layout_engine, font_letter_space, font_mapping,
    font_max, font_mem_size, font_name, font_params, font_ptr, font_size, font_used, force_eof,
    full_source_filename_stack, gave_char_warning_help, grp_stack, half_error_line, hash,
    hash_extra, hash_high, hash_used, height_base, help_line, help_ptr, hi_mem_min, history,
    hyphen_char, if_limit, if_line, if_stack, in_open, init_pool_ptr, init_str_ptr, input_file,
    input_ptr, input_stack, ins_disc, insert_penalties, insert_src_special_auto,
    insert_src_special_every_par, insert_src_special_every_vbox, interaction, is_hyph,
    is_in_csname, italic_base, job_name, kern_base, last, last_badness, last_glue, last_kern,
    last_leftmost_char, last_node_type, last_penalty, last_rightmost_char, lft_hit, lig_kern_base,
    lig_stack, ligature_present, line, line_stack, lo_mem_max, loaded_font_design_size,
    loaded_font_flags, loaded_font_letter_space, loaded_font_mapping, log_file, log_opened,
    long_help_seen, long_state, mag_set, main_f, main_h, main_i, main_j, main_k, main_p, main_pp,
    main_ppp, main_s, mapped_text, max_buf_stack, max_in_open, max_in_stack, max_nest_stack,
    max_param_stack, max_print_line, max_reg_help_line, max_reg_num, max_save_stack, max_strings,
    mem, mem_end, name_in_progress, name_length, name_length16, name_of_file, name_of_file16,
    native_font_type_flag, native_len, native_text, native_text_size, nest, nest_ptr, nest_size,
    no_new_control_sequence, old_setting, open_parens, output_active, pack_begin_line,
    page_contents, page_so_far, page_tail, par_loc, par_token, param_base, param_ptr, param_size,
    param_stack, pdf_last_x_pos, pdf_last_y_pos, pool_ptr, pool_size, pre_adjust_tail, prev_class,
    prim, prim_eqtb, prim_used, pseudo_files, pstack, quoted_filename, radix, read_file, read_open,
    rover, rt_hit, rust_stdout, sa_chain, sa_level, sa_null, sa_root, save_native_len, save_ptr,
    save_size, save_stack, scanner_status, selector, set_box_allowed, shown_mode, skew_char,
    skip_line, source_filename_stack, space_class, stack_size, stop_at_space, str_pool, str_ptr,
    str_start, tally, temp_ptr, term_offset, tex_remainder, texmf_log_name, total_shrink,
    total_stretch, trick_buf, trick_count, use_err_help, used_tectonic_coda_tokens, warning_index,
    width_base, write_file, write_open, xtx_ligature_present, LR_problems, LR_ptr,
};
use crate::xetex_ini::{b16x4, b32x2, memory_word, prefixed_command};
use crate::xetex_io::{input_line, open_or_close_in, set_input_file_encoding, u_close};
use crate::xetex_layout_engine::*;
use crate::xetex_linebreak::line_break;
use crate::xetex_math::{
    after_math, append_choices, build_choices, fin_mlist, flush_math, init_math, math_ac,
    math_fraction, math_left_right, math_limit_switch, math_radical, resume_after_display,
    start_eq_no, sub_sup,
};
use crate::xetex_output::{
    print, print_char, print_cs, print_cstr, print_current_string, print_esc, print_esc_cstr,
    print_file_line, print_file_name, print_hex, print_int, print_ln, print_native_word, print_nl,
    print_nl_cstr, print_raw_char, print_roman_int, print_sa_num, print_scaled, print_size,
    print_write_whatsit, sprint_cs,
};
use crate::xetex_pagebuilder::build_page;
use crate::xetex_pic::{count_pdf_file_pages, load_picture};
use crate::xetex_scaledmath::{mult_and_add, round_xn_over_d, tex_round, x_over_n, xn_over_d};
use crate::xetex_shipout::{finalize_dvi_file, new_edge, out_what, ship_out};
use crate::xetex_stringpool::{
    append_str, length, make_string, search_string, slow_make_string, str_eq_buf, str_eq_str,
};
use crate::xetex_synctex::{synctex_start_input, synctex_terminate};
use crate::xetex_texmfmp::{
    getmd5sum, gettexstring, is_new_source, make_src_special, maketexstring, remember_source_info,
};
use crate::xetex_xetexd::{is_char_node, is_non_discardable_node, print_c_string};
use crate::{
    ttstub_input_close, ttstub_input_getc, ttstub_issue_warning, ttstub_output_close,
    ttstub_output_open, ttstub_output_putc,
};
use bridge::_tt_abort;
use libc::{free, memcpy, strcat, strcpy, strlen};
use crate::xetex_opentype_math::get_ot_math_constant;

pub type size_t = u64;
/* tectonic/core-bridge.h: declarations of C/C++ => Rust bridge API
   Copyright 2016-2018 the Tectonic Project
   Licensed under the MIT License.
*/

use crate::{TTHistory, TTInputFormat};

use bridge::rust_input_handle_t;
pub type scaled_t = i32;
pub type Fixed = scaled_t;
pub type CFDictionaryRef = *mut libc::c_void;

use super::xetex_ini::Selector;

pub type UInt16 = u16;
pub type UInt32 = u32;
/* quasi-hack to get the primary input */
/* tectonic/xetex-xetexd.h -- many, many XeTeX symbol definitions
   Copyright 2016-2018 The Tectonic Project
   Licensed under the MIT License.
*/
/* Extra stuff used in various change files for various reasons.  */
/* Array allocations. Add 1 to size to account for Pascal indexing convention. */
/*11:*/
/*18: */
pub type UTF16_code = u16;
pub type UTF8_code = u8;
pub type UnicodeScalar = i32;
pub type eight_bits = u8;
pub type pool_pointer = i32;
pub type str_number = i32;
pub type packed_UTF16_code = u16;
pub type small_number = i16;
/* Symbolic accessors for various TeX data structures. I would loooove to turn these
 * into actual structs, but the path to doing that is not currently clear. Making
 * field references symbolic seems like a decent start. Sadly I don't see how to do
 * this conversion besides painstakingly annotating things.
 */
/* half of LLIST_info(p) */
/* the other half of LLIST_info(p) */
/* subtype; records L/R direction mode */
/* a scaled; 1 <=> WEB const `width_offset` */
/* a scaled; 2 <=> WEB const `depth_offset` */
/* a scaled; 3 <=> WEB const `height_offset` */
/* a scaled */
/* aka `link` of p+5 */
/* aka `type` of p+5 */
/* aka `subtype` of p+5 */
/* the glue ratio */
/* aka "subtype" of a node */
/* aka "rlink" in double-linked list */
/* aka "llink" in doubly-linked list */
/* was originally the `mem[x+2].int` field */
/* a scaled; "active_short" in the WEB */
/* a scaled */
/* aka "type" of a node */
/* aka "subtype" of a node */
/* the "natural width" difference */
/* the stretch difference in points */
/* the stretch difference in fil */
/* the stretch difference in fill */
/* the stretch difference in fill */
/* the shrink difference */
/* aka "subtype" of a node */
/* aka "llink" in doubly-linked list */
/* aka "rlink" in double-linked list */
/* "new left_edge position relative to cur_h" */
/* aka "llink" in doubly-linked list */
/* aka "rlink" in double-linked list */
/* "the floating_penalty to be used" */
/* a glue pointer */
/* a pointer to a vlist */
/* language number, 0..255 */
/* "minimum left fragment, range 1..63" */
/* "minimum right fragment, range 1..63" */
/* WEB: font(lig_char(p)) */
/* WEB: character(lig_char(p)) */
/* WEB: link(lig_char(p)) */
/* "head of the token list for the mark" */
/* "the mark class" */
/* To check: do these really only apply to MATH_NODEs? */
/* number of UTF16 items in the text */
/* ... or the glyph number, if subtype==GLYPH_NODE */
/* "an insertion for this class will break here if anywhere" */
/* "this insertion might break at broken_ptr" */
/* "the most recent insertion for this subtype" */
/* "the optimum most recent insertion" */
/* aka "llink" in doubly-linked list */
/* siggggghhhhh */
/* aka "rlink" in double-linked list */
/* aka "info" */
/* was originally the `mem[x+1].int` field */
/* number of bytes in the path item */
/* "reference count of token list to write" */
/* Synctex hacks various nodes to add an extra word at the end to store its
 * information, hence the need to know the node size to get the synctex
 * info. */
/* aka "link" of a link-list node */
/* aka "type" of a node */
/* aka "subtype" of a node */
/* a scaled */
/* a scaled */
/* e-TeX extended marks stuff ... not sure where to put these */
/* \topmarks<n> */
/* \firstmarks<n> */
/* \botmarks<n> */
/* \splitfirstmarks<n> */
/* \splitbotmarks<n> */
pub type glue_ord = u8;
/* enum: normal .. filll */
pub type group_code = u8;
pub type internal_font_number = i32;
pub type font_index = i32;
pub type nine_bits = i32;
pub type save_pointer = i32;

pub use super::xetex_io::UFILE;

/* xetex-pagebuilder */
/* xetex-scaledmath */
/* xetex-shipout */
/* Strings printed this way will end up in the .log as well
 * as the terminal output. */
#[inline]
unsafe extern "C" fn cur_length() -> pool_pointer {
    /*41: The length of the current string in the pool */
    pool_ptr - *str_start.offset((str_ptr - 65536i32) as isize)
}
/* xetex-xetex0.c: bulk of the WEB code translated to C
   Copyright 2016-2018 The Tectonic Project
   Licensed under the MIT License.
*/
unsafe extern "C" fn int_error(mut n: i32) {
    print_cstr(b" (\x00" as *const u8 as *const i8);
    print_int(n);
    print_char(')' as i32);
    error();
}
#[no_mangle]
pub unsafe extern "C" fn badness(mut t: scaled_t, mut s: scaled_t) -> i32 {
    let mut r: i32 = 0;
    if t == 0i32 {
        return 0i32;
    }
    if s <= 0i32 {
        return 10000i32;
    }
    if t as i64 <= 7230584 {
        /* magic constant */
        r = t * 297i32 / s
    } else if s as i64 >= 1663497 {
        /* magic constant */
        r = t / (s / 297i32)
    } else {
        r = t
    }
    if r > 1290i32 {
        /* magic constant */
        return 10000i32;
    }
    (r * r * r + 0x20000i32) / 0x40000i32
}
/*:112*/
/*118:*/
#[no_mangle]
pub unsafe extern "C" fn show_token_list(mut p: i32, mut q: i32, mut l: i32) {
    let mut m: i32 = 0;
    let mut c: i32 = 0;
    let mut match_chr: i32 = 0;
    let mut n: UTF16_code = 0;
    match_chr = '#' as i32;
    n = '0' as i32 as UTF16_code;
    tally = 0i32;
    while p != -0xfffffffi32 && tally < l {
        /*332:*/
        if p == q {
            first_count = tally;
            trick_count = tally + 1i32 + error_line - half_error_line;
            if trick_count < error_line {
                trick_count = error_line
            }
        }
        if p < hi_mem_min || p > mem_end {
            print_esc_cstr(b"CLOBBERED.\x00" as *const u8 as *const i8);
            return;
        }
        if (*mem.offset(p as isize)).b32.s0 >= 0x1ffffffi32 {
            print_cs((*mem.offset(p as isize)).b32.s0 - 0x1ffffffi32);
        } else {
            m = (*mem.offset(p as isize)).b32.s0 / 0x200000i32;
            c = (*mem.offset(p as isize)).b32.s0 % 0x200000i32;
            if (*mem.offset(p as isize)).b32.s0 < 0i32 {
                print_esc_cstr(b"BAD.\x00" as *const u8 as *const i8);
            } else {
                /*306:*/
                match m {
                    1 | 2 | 3 | 4 | 7 | 8 | 10 | 11 | 12 => {
                        print_char(c);
                    }
                    6 => {
                        print_char(c);
                        print_char(c);
                    }
                    5 => {
                        print_char(match_chr);
                        if c <= 9i32 {
                            print_char(c + 48i32);
                        } else {
                            print_char('!' as i32);
                            return;
                        }
                    }
                    13 => {
                        match_chr = c;
                        print_char(c);
                        n = n.wrapping_add(1);
                        print_char(n as i32);
                        if n as i32 > '9' as i32 {
                            return;
                        }
                    }
                    14 => {
                        if c == 0i32 {
                            print_cstr(b"->\x00" as *const u8 as *const i8);
                        }
                    }
                    _ => {
                        print_esc_cstr(b"BAD.\x00" as *const u8 as *const i8);
                    }
                }
            }
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
    if p != -0xfffffffi32 {
        print_esc_cstr(b"ETC.\x00" as *const u8 as *const i8);
    };
}
#[no_mangle]
pub unsafe extern "C" fn runaway() {
    let mut p: i32 = -0xfffffffi32;
    if scanner_status as i32 > 1i32 {
        match scanner_status as i32 {
            2 => {
                print_nl_cstr(b"Runaway definition\x00" as *const u8 as *const i8);
                p = def_ref
            }
            3 => {
                print_nl_cstr(b"Runaway argument\x00" as *const u8 as *const i8);
                p = 4999999i32 - 3i32
            }
            4 => {
                print_nl_cstr(b"Runaway preamble\x00" as *const u8 as *const i8);
                p = 4999999i32 - 4i32
            }
            5 => {
                print_nl_cstr(b"Runaway text\x00" as *const u8 as *const i8);
                p = def_ref
            }
            _ => {}
        }
        print_char('?' as i32);
        print_ln();
        show_token_list(
            (*mem.offset(p as isize)).b32.s1,
            -0xfffffffi32,
            error_line - 10i32,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn get_avail() -> i32 {
    let mut p: i32 = 0;
    p = avail;
    if p != -0xfffffffi32 {
        avail = (*mem.offset(avail as isize)).b32.s1
    } else if mem_end < 4999999i32 {
        mem_end += 1;
        p = mem_end
    } else {
        hi_mem_min -= 1;
        p = hi_mem_min;
        if is_char_node(lo_mem_max) {
            runaway();
            overflow(
                b"main memory size\x00" as *const u8 as *const i8,
                4999999i32 + 1i32,
            );
        }
    }
    (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
    p
}
#[no_mangle]
pub unsafe extern "C" fn flush_list(mut p: i32) {
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    if p != -0xfffffffi32 {
        r = p;
        loop {
            q = r;
            r = (*mem.offset(r as isize)).b32.s1;
            if r == -0xfffffffi32 {
                break;
            }
        }
        (*mem.offset(q as isize)).b32.s1 = avail;
        avail = p
    };
}
#[no_mangle]
pub unsafe extern "C" fn get_node(mut s: i32) -> i32 {
    let mut current_block: u64;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut t: i32 = 0;
    'c_12125: loop {
        p = rover;
        loop {
            /*131: */
            q = p + (*mem.offset(p as isize)).b32.s0;
            while (*mem.offset(q as isize)).b32.s1 == 0x3fffffffi32 {
                t = (*mem.offset((q + 1i32) as isize)).b32.s1;
                if q == rover {
                    rover = t
                }
                (*mem.offset((t + 1i32) as isize)).b32.s0 =
                    (*mem.offset((q + 1i32) as isize)).b32.s0;
                (*mem.offset(((*mem.offset((q + 1i32) as isize)).b32.s0 + 1i32) as isize))
                    .b32
                    .s1 = t;
                q = q + (*mem.offset(q as isize)).b32.s0
            }
            r = q - s;
            if r > p + 1i32 {
                /*132: */
                (*mem.offset(p as isize)).b32.s0 = r - p;
                rover = p;
                current_block = 15463013039495622015;
                break 'c_12125;
            } else {
                if r == p {
                    if (*mem.offset((p + 1i32) as isize)).b32.s1 != p {
                        /*133: */
                        rover = (*mem.offset((p + 1i32) as isize)).b32.s1;
                        t = (*mem.offset((p + 1i32) as isize)).b32.s0;
                        (*mem.offset((rover + 1i32) as isize)).b32.s0 = t;
                        (*mem.offset((t + 1i32) as isize)).b32.s1 = rover;
                        current_block = 15463013039495622015;
                        break 'c_12125;
                    }
                }
                (*mem.offset(p as isize)).b32.s0 = q - p;
                p = (*mem.offset((p + 1i32) as isize)).b32.s1;
                if p == rover {
                    break;
                }
            }
        }
        if s == 0x40000000i32 {
            return 0x3fffffffi32;
        }
        if !(lo_mem_max + 2i32 < hi_mem_min) {
            current_block = 16799951812150840583;
            break;
        }
        if !(lo_mem_max + 2i32 <= 0x3fffffffi32) {
            current_block = 16799951812150840583;
            break;
        }
        /*130: */
        if hi_mem_min - lo_mem_max >= 1998i32 {
            t = lo_mem_max + 1000i32
        } else {
            t = lo_mem_max + 1i32 + (hi_mem_min - lo_mem_max) / 2i32
        } /*:232 */
        p = (*mem.offset((rover + 1i32) as isize)).b32.s0;
        q = lo_mem_max;
        (*mem.offset((p + 1i32) as isize)).b32.s1 = q;
        (*mem.offset((rover + 1i32) as isize)).b32.s0 = q;
        if t > 0x3fffffffi32 {
            t = 0x3fffffffi32
        }
        (*mem.offset((q + 1i32) as isize)).b32.s1 = rover;
        (*mem.offset((q + 1i32) as isize)).b32.s0 = p;
        (*mem.offset(q as isize)).b32.s1 = 0x3fffffffi32;
        (*mem.offset(q as isize)).b32.s0 = t - lo_mem_max;
        lo_mem_max = t;
        (*mem.offset(lo_mem_max as isize)).b32.s1 = -0xfffffffi32;
        (*mem.offset(lo_mem_max as isize)).b32.s0 = -0xfffffffi32;
        rover = q
    }
    match current_block {
        16799951812150840583 => {
            overflow(
                b"main memory size\x00" as *const u8 as *const i8,
                4999999i32 + 1i32,
            );
        }
        _ => {
            (*mem.offset(r as isize)).b32.s1 = -0xfffffffi32;
            if s >= 3i32 {
                (*mem.offset((r + s - 1i32) as isize)).b32.s0 = cur_input.synctex_tag;
                (*mem.offset((r + s - 1i32) as isize)).b32.s1 = line
            }
            return r;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn free_node(mut p: i32, mut s: i32) {
    let mut q: i32 = 0;
    (*mem.offset(p as isize)).b32.s0 = s;
    (*mem.offset(p as isize)).b32.s1 = 0x3fffffffi32;
    q = (*mem.offset((rover + 1i32) as isize)).b32.s0;
    (*mem.offset((p + 1i32) as isize)).b32.s0 = q;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = rover;
    (*mem.offset((rover + 1i32) as isize)).b32.s0 = p;
    (*mem.offset((q + 1i32) as isize)).b32.s1 = p;
}
#[no_mangle]
pub unsafe extern "C" fn new_null_box() -> i32 {
    let mut p: i32 = 0;
    p = get_node(8i32);
    (*mem.offset(p as isize)).b16.s1 = 0_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = 0i32;
    (*mem.offset((p + 2i32) as isize)).b32.s1 = 0i32;
    (*mem.offset((p + 3i32) as isize)).b32.s1 = 0i32;
    (*mem.offset((p + 4i32) as isize)).b32.s1 = 0i32;
    (*mem.offset((p + 5i32) as isize)).b32.s1 = -0xfffffffi32;
    (*mem.offset((p + 5i32) as isize)).b16.s1 = 0_u16;
    (*mem.offset((p + 5i32) as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 6i32) as isize)).gr = 0.0f64;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_rule() -> i32 {
    let mut p: i32 = 0;
    p = get_node(5i32);
    (*mem.offset(p as isize)).b16.s1 = 2_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = -0x40000000i32;
    (*mem.offset((p + 2i32) as isize)).b32.s1 = -0x40000000i32;
    (*mem.offset((p + 3i32) as isize)).b32.s1 = -0x40000000i32;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_ligature(mut f: internal_font_number, mut c: u16, mut q: i32) -> i32 {
    let mut p: i32 = 0;
    p = get_node(2i32);
    (*mem.offset(p as isize)).b16.s1 = 6_u16;
    (*mem.offset((p + 1i32) as isize)).b16.s1 = f as u16;
    (*mem.offset((p + 1i32) as isize)).b16.s0 = c;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = q;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_lig_item(mut c: u16) -> i32 {
    let mut p: i32 = 0;
    p = get_node(2i32);
    (*mem.offset(p as isize)).b16.s0 = c;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = -0xfffffffi32;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_disc() -> i32 {
    let mut p: i32 = 0;
    p = get_node(2i32);
    (*mem.offset(p as isize)).b16.s1 = 7_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s0 = -0xfffffffi32;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = -0xfffffffi32;
    p
}
#[no_mangle]
pub unsafe extern "C" fn copy_native_glyph_info(mut src: i32, mut dest: i32) {
    let mut glyph_count: i32 = 0;
    if !(*mem.offset((src + 5i32) as isize)).ptr.is_null() {
        glyph_count = (*mem.offset((src + 4i32) as isize)).b16.s0 as i32;
        let ref mut fresh1 = (*mem.offset((dest + 5i32) as isize)).ptr;
        *fresh1 = xmalloc(
            ((glyph_count * 10i32 + 1i32) as u64).wrapping_mul(::std::mem::size_of::<i8>() as u64),
        );
        memcpy(
            (*mem.offset((dest + 5i32) as isize)).ptr,
            (*mem.offset((src + 5i32) as isize)).ptr,
            (glyph_count * 10i32) as usize,
        );
        (*mem.offset((dest + 4i32) as isize)).b16.s0 = glyph_count as u16
    };
}
#[no_mangle]
pub unsafe extern "C" fn new_math(mut w: scaled_t, mut s: small_number) -> i32 {
    let mut p: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 9_u16;
    (*mem.offset(p as isize)).b16.s0 = s as u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = w;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_spec(mut p: i32) -> i32 {
    let mut q: i32 = 0;
    q = get_node(4i32);
    *mem.offset(q as isize) = *mem.offset(p as isize);
    (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
    (*mem.offset((q + 1i32) as isize)).b32.s1 = (*mem.offset((p + 1i32) as isize)).b32.s1;
    (*mem.offset((q + 2i32) as isize)).b32.s1 = (*mem.offset((p + 2i32) as isize)).b32.s1;
    (*mem.offset((q + 3i32) as isize)).b32.s1 = (*mem.offset((p + 3i32) as isize)).b32.s1;
    q
}
#[no_mangle]
pub unsafe extern "C" fn new_param_glue(mut n: small_number) -> i32 {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 10_u16;
    (*mem.offset(p as isize)).b16.s0 = (n as i32 + 1i32) as u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = -0xfffffffi32;
    q = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + n as i32) as isize,
    ))
    .b32
    .s1;
    (*mem.offset((p + 1i32) as isize)).b32.s0 = q;
    let ref mut fresh2 = (*mem.offset(q as isize)).b32.s1;
    *fresh2 += 1;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_glue(mut q: i32) -> i32 {
    let mut p: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 10_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = -0xfffffffi32;
    (*mem.offset((p + 1i32) as isize)).b32.s0 = q;
    let ref mut fresh3 = (*mem.offset(q as isize)).b32.s1;
    *fresh3 += 1;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_skip_param(mut n: small_number) -> i32 {
    let mut p: i32 = 0;
    temp_ptr = new_spec(
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + n as i32) as isize,
        ))
        .b32
        .s1,
    );
    p = new_glue(temp_ptr);
    (*mem.offset(temp_ptr as isize)).b32.s1 = -0xfffffffi32;
    (*mem.offset(p as isize)).b16.s0 = (n as i32 + 1i32) as u16;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_kern(mut w: scaled_t) -> i32 {
    let mut p: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 11_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = w;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_penalty(mut m: i32) -> i32 {
    let mut p: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 12_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = m;
    p
}
/*:165*/
#[no_mangle]
pub unsafe extern "C" fn prev_rightmost(mut s: i32, mut e: i32) -> i32 {
    let mut p: i32 = 0;
    p = s;
    if p == -0xfffffffi32 {
        return -0xfffffffi32;
    }
    while (*mem.offset(p as isize)).b32.s1 != e {
        p = (*mem.offset(p as isize)).b32.s1;
        if p == -0xfffffffi32 {
            return -0xfffffffi32;
        }
    }
    p
}
#[no_mangle]
pub unsafe extern "C" fn short_display(mut p: i32) {
    let mut n: i32 = 0;
    while p > 0i32 {
        if is_char_node(p) {
            if p <= mem_end {
                if (*mem.offset(p as isize)).b16.s1 as i32 != font_in_short_display {
                    if (*mem.offset(p as isize)).b16.s1 as i32 > font_max {
                        print_char('*' as i32);
                    } else {
                        /*279:*/
                        print_esc(
                            (*hash.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + (*mem.offset(p as isize)).b16.s1 as i32)
                                    as isize,
                            ))
                            .s1,
                        );
                    }
                    print_char(' ' as i32);
                    font_in_short_display = (*mem.offset(p as isize)).b16.s1 as i32
                }
                print((*mem.offset(p as isize)).b16.s0 as i32);
            }
        } else {
            /*183:*/
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 3 | 4 | 5 | 13 => {
                    print_cstr(b"[]\x00" as *const u8 as *const i8);
                }
                8 => match (*mem.offset(p as isize)).b16.s0 as i32 {
                    40 | 41 => {
                        if (*mem.offset((p + 4i32) as isize)).b16.s2 as i32 != font_in_short_display
                        {
                            print_esc(
                                (*hash.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + (*mem.offset((p + 4i32) as isize)).b16.s2 as i32)
                                        as isize,
                                ))
                                .s1,
                            );
                            print_char(' ' as i32);
                            font_in_short_display = (*mem.offset((p + 4i32) as isize)).b16.s2 as i32
                        }
                        print_native_word(p);
                    }
                    _ => {
                        print_cstr(b"[]\x00" as *const u8 as *const i8);
                    }
                },
                2 => {
                    print_char('|' as i32);
                }
                10 => {
                    if (*mem.offset((p + 1i32) as isize)).b32.s0 != 0i32 {
                        print_char(' ' as i32);
                    }
                }
                9 => {
                    if (*mem.offset(p as isize)).b16.s0 as i32 >= 4i32 {
                        print_cstr(b"[]\x00" as *const u8 as *const i8);
                    } else {
                        print_char('$' as i32);
                    }
                }
                6 => {
                    short_display((*mem.offset((p + 1i32) as isize)).b32.s1);
                }
                7 => {
                    short_display((*mem.offset((p + 1i32) as isize)).b32.s0);
                    short_display((*mem.offset((p + 1i32) as isize)).b32.s1);
                    n = (*mem.offset(p as isize)).b16.s0 as i32;
                    while n > 0i32 {
                        if (*mem.offset(p as isize)).b32.s1 != -0xfffffffi32 {
                            p = (*mem.offset(p as isize)).b32.s1
                        }
                        n -= 1
                    }
                }
                _ => {}
            }
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
}
#[no_mangle]
pub unsafe extern "C" fn print_font_and_char(mut p: i32) {
    if p > mem_end {
        print_esc_cstr(b"CLOBBERED.\x00" as *const u8 as *const i8);
    } else {
        if (*mem.offset(p as isize)).b16.s1 as i32 > font_max {
            print_char('*' as i32);
        } else {
            /*279: */
            print_esc(
                (*hash.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + (*mem.offset(p as isize)).b16.s1 as i32) as isize,
                ))
                .s1,
            );
        }
        print_char(' ' as i32);
        print((*mem.offset(p as isize)).b16.s0 as i32);
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_mark(mut p: i32) {
    print_char('{' as i32);
    if p < hi_mem_min || p > mem_end {
        print_esc_cstr(b"CLOBBERED.\x00" as *const u8 as *const i8);
    } else {
        show_token_list(
            (*mem.offset(p as isize)).b32.s1,
            -0xfffffffi32,
            max_print_line - 10i32,
        );
    }
    print_char('}' as i32);
}
#[no_mangle]
pub unsafe extern "C" fn print_rule_dimen(mut d: scaled_t) {
    if d == -0x40000000i32 {
        print_char('*' as i32);
    } else {
        print_scaled(d);
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_glue(mut d: scaled_t, mut order: i32, mut s: *const i8) {
    print_scaled(d);
    if order < 0i32 || order > 3i32 {
        print_cstr(b"foul\x00" as *const u8 as *const i8);
    } else if order > 0i32 {
        print_cstr(b"fil\x00" as *const u8 as *const i8);
        while order > 1i32 {
            print_char('l' as i32);
            order -= 1
        }
    } else if !s.is_null() {
        print_cstr(s);
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_spec(mut p: i32, mut s: *const i8) {
    if p < 0i32 || p >= lo_mem_max {
        print_char('*' as i32);
    } else {
        print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
        if !s.is_null() {
            print_cstr(s);
        }
        if (*mem.offset((p + 2i32) as isize)).b32.s1 != 0i32 {
            print_cstr(b" plus \x00" as *const u8 as *const i8);
            print_glue(
                (*mem.offset((p + 2i32) as isize)).b32.s1,
                (*mem.offset(p as isize)).b16.s1 as i32,
                s,
            );
        }
        if (*mem.offset((p + 3i32) as isize)).b32.s1 != 0i32 {
            print_cstr(b" minus \x00" as *const u8 as *const i8);
            print_glue(
                (*mem.offset((p + 3i32) as isize)).b32.s1,
                (*mem.offset(p as isize)).b16.s0 as i32,
                s,
            );
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_fam_and_char(mut p: i32) {
    let mut c: i32 = 0;
    print_esc_cstr(b"fam\x00" as *const u8 as *const i8);
    print_int((*mem.offset(p as isize)).b16.s1 as i32 % 256i32 % 256i32);
    print_char(' ' as i32);
    c = ((*mem.offset(p as isize)).b16.s0 as i64
        + ((*mem.offset(p as isize)).b16.s1 as i32 / 256i32) as i64 * 65536) as i32;
    if (c as i64) < 65536 {
        print(c);
    } else {
        print_char(c);
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_delimiter(mut p: i32) {
    let mut a: i32 = 0;
    a = (((*mem.offset(p as isize)).b16.s3 as i32 % 256i32 * 256i32) as i64
        + ((*mem.offset(p as isize)).b16.s2 as i64
            + ((*mem.offset(p as isize)).b16.s3 as i32 / 256i32) as i64 * 65536)) as i32;
    a = ((a * 4096i32 + (*mem.offset(p as isize)).b16.s1 as i32 % 256i32 * 256i32) as i64
        + ((*mem.offset(p as isize)).b16.s0 as i64
            + ((*mem.offset(p as isize)).b16.s1 as i32 / 256i32) as i64 * 65536)) as i32;
    if a < 0i32 {
        print_int(a);
    } else {
        print_hex(a);
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_subsidiary_data(mut p: i32, mut c: UTF16_code) {
    if cur_length() >= depth_threshold {
        if (*mem.offset(p as isize)).b32.s1 != 0i32 {
            print_cstr(b" []\x00" as *const u8 as *const i8);
        }
    } else {
        *str_pool.offset(pool_ptr as isize) = c;
        pool_ptr += 1;
        temp_ptr = p;
        match (*mem.offset(p as isize)).b32.s1 {
            1 => {
                print_ln();
                print_current_string();
                print_fam_and_char(p);
            }
            2 => {
                show_info();
            }
            3 => {
                if (*mem.offset(p as isize)).b32.s0 == -0xfffffffi32 {
                    print_ln();
                    print_current_string();
                    print_cstr(b"{}\x00" as *const u8 as *const i8);
                } else {
                    show_info();
                }
            }
            _ => {}
        }
        pool_ptr -= 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_style(mut c: i32) {
    match c / 2i32 {
        0 => {
            print_esc_cstr(b"displaystyle\x00" as *const u8 as *const i8);
        }
        1 => {
            print_esc_cstr(b"textstyle\x00" as *const u8 as *const i8);
        }
        2 => {
            print_esc_cstr(b"scriptstyle\x00" as *const u8 as *const i8);
        }
        3 => {
            print_esc_cstr(b"scriptscriptstyle\x00" as *const u8 as *const i8);
        }
        _ => {
            print_cstr(b"Unknown style!\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_skip_param(mut n: i32) {
    match n {
        0 => {
            print_esc_cstr(b"lineskip\x00" as *const u8 as *const i8);
        }
        1 => {
            print_esc_cstr(b"baselineskip\x00" as *const u8 as *const i8);
        }
        2 => {
            print_esc_cstr(b"parskip\x00" as *const u8 as *const i8);
        }
        3 => {
            print_esc_cstr(b"abovedisplayskip\x00" as *const u8 as *const i8);
        }
        4 => {
            print_esc_cstr(b"belowdisplayskip\x00" as *const u8 as *const i8);
        }
        5 => {
            print_esc_cstr(b"abovedisplayshortskip\x00" as *const u8 as *const i8);
        }
        6 => {
            print_esc_cstr(b"belowdisplayshortskip\x00" as *const u8 as *const i8);
        }
        7 => {
            print_esc_cstr(b"leftskip\x00" as *const u8 as *const i8);
        }
        8 => {
            print_esc_cstr(b"rightskip\x00" as *const u8 as *const i8);
        }
        9 => {
            print_esc_cstr(b"topskip\x00" as *const u8 as *const i8);
        }
        10 => {
            print_esc_cstr(b"splittopskip\x00" as *const u8 as *const i8);
        }
        11 => {
            print_esc_cstr(b"tabskip\x00" as *const u8 as *const i8);
        }
        12 => {
            print_esc_cstr(b"spaceskip\x00" as *const u8 as *const i8);
        }
        13 => {
            print_esc_cstr(b"xspaceskip\x00" as *const u8 as *const i8);
        }
        14 => {
            print_esc_cstr(b"parfillskip\x00" as *const u8 as *const i8);
        }
        15 => {
            print_esc_cstr(b"XeTeXlinebreakskip\x00" as *const u8 as *const i8);
        }
        16 => {
            print_esc_cstr(b"thinmuskip\x00" as *const u8 as *const i8);
        }
        17 => {
            print_esc_cstr(b"medmuskip\x00" as *const u8 as *const i8);
        }
        18 => {
            print_esc_cstr(b"thickmuskip\x00" as *const u8 as *const i8);
        }
        _ => {
            print_cstr(b"[unknown glue parameter!]\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn show_node_list(mut p: i32) {
    let mut n: i32 = 0;
    let mut i: i32 = 0;
    let mut g: f64 = 0.;
    if cur_length() > depth_threshold {
        if p > -0xfffffffi32 {
            print_cstr(b" []\x00" as *const u8 as *const i8);
        }
        return;
    }
    n = 0i32;
    while p > 0i32 {
        print_ln();
        print_current_string();
        if p > mem_end {
            print_cstr(b"Bad link, display aborted.\x00" as *const u8 as *const i8);
            return;
        }
        n += 1;
        if n > breadth_max {
            print_cstr(b"etc.\x00" as *const u8 as *const i8);
            return;
        }
        if is_char_node(p) {
            print_font_and_char(p);
        } else {
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 13 => {
                    if (*mem.offset(p as isize)).b16.s1 as i32 == 0i32 {
                        print_esc('h' as i32);
                    } else if (*mem.offset(p as isize)).b16.s1 as i32 == 1i32 {
                        print_esc('v' as i32);
                    } else {
                        print_esc_cstr(b"unset\x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"box(\x00" as *const u8 as *const i8);
                    print_scaled((*mem.offset((p + 3i32) as isize)).b32.s1);
                    print_char('+' as i32);
                    print_scaled((*mem.offset((p + 2i32) as isize)).b32.s1);
                    print_cstr(b")x\x00" as *const u8 as *const i8);
                    print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
                    if (*mem.offset(p as isize)).b16.s1 as i32 == 13i32 {
                        /*193:*/
                        if (*mem.offset(p as isize)).b16.s0 as i32 != 0i32 {
                            print_cstr(b" (\x00" as *const u8 as *const i8);
                            print_int((*mem.offset(p as isize)).b16.s0 as i32 + 1i32);
                            print_cstr(b" columns)\x00" as *const u8 as *const i8);
                        }
                        if (*mem.offset((p + 6i32) as isize)).b32.s1 != 0i32 {
                            print_cstr(b", stretch \x00" as *const u8 as *const i8);
                            print_glue(
                                (*mem.offset((p + 6i32) as isize)).b32.s1,
                                (*mem.offset((p + 5i32) as isize)).b16.s0 as i32,
                                0 as *const i8,
                            );
                        }
                        if (*mem.offset((p + 4i32) as isize)).b32.s1 != 0i32 {
                            print_cstr(b", shrink \x00" as *const u8 as *const i8);
                            print_glue(
                                (*mem.offset((p + 4i32) as isize)).b32.s1,
                                (*mem.offset((p + 5i32) as isize)).b16.s1 as i32,
                                0 as *const i8,
                            );
                        }
                    } else {
                        g = (*mem.offset((p + 6i32) as isize)).gr;
                        if g != 0.0f64 && (*mem.offset((p + 5i32) as isize)).b16.s1 as i32 != 0i32 {
                            print_cstr(b", glue set \x00" as *const u8 as *const i8);
                            if (*mem.offset((p + 5i32) as isize)).b16.s1 as i32 == 2i32 {
                                print_cstr(b"- \x00" as *const u8 as *const i8);
                            }
                            if g.abs() > 20000.0f64 {
                                if g > 0.0f64 {
                                    print_char('>' as i32);
                                } else {
                                    print_cstr(b"< -\x00" as *const u8 as *const i8);
                                }
                                print_glue(
                                    (20000i32 as i64 * 65536) as scaled_t,
                                    (*mem.offset((p + 5i32) as isize)).b16.s0 as i32,
                                    0 as *const i8,
                                );
                            } else {
                                print_glue(
                                    tex_round(65536 as f64 * g),
                                    (*mem.offset((p + 5i32) as isize)).b16.s0 as i32,
                                    0 as *const i8,
                                );
                            }
                        }
                        if (*mem.offset((p + 4i32) as isize)).b32.s1 != 0i32 {
                            print_cstr(b", shifted \x00" as *const u8 as *const i8);
                            print_scaled((*mem.offset((p + 4i32) as isize)).b32.s1);
                        }
                        /*1491:*/
                        if (*mem.offset(p as isize)).b16.s1 as i32 == 0i32
                            && (*mem.offset(p as isize)).b16.s0 as i32 == 2i32
                        {
                            print_cstr(b", display\x00" as *const u8 as *const i8);
                        }
                    }
                    *str_pool.offset(pool_ptr as isize) = '.' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 5i32) as isize)).b32.s1);
                    pool_ptr -= 1
                }
                2 => {
                    print_esc_cstr(b"rule(\x00" as *const u8 as *const i8);
                    print_rule_dimen((*mem.offset((p + 3i32) as isize)).b32.s1);
                    print_char('+' as i32);
                    print_rule_dimen((*mem.offset((p + 2i32) as isize)).b32.s1);
                    print_cstr(b")x\x00" as *const u8 as *const i8);
                    print_rule_dimen((*mem.offset((p + 1i32) as isize)).b32.s1);
                }
                3 => {
                    print_esc_cstr(b"insert\x00" as *const u8 as *const i8);
                    print_int((*mem.offset(p as isize)).b16.s0 as i32);
                    print_cstr(b", natural size \x00" as *const u8 as *const i8);
                    print_scaled((*mem.offset((p + 3i32) as isize)).b32.s1);
                    print_cstr(b"; split(\x00" as *const u8 as *const i8);
                    print_spec((*mem.offset((p + 4i32) as isize)).b32.s1, 0 as *const i8);
                    print_char(',' as i32);
                    print_scaled((*mem.offset((p + 2i32) as isize)).b32.s1);
                    print_cstr(b"); float cost \x00" as *const u8 as *const i8);
                    print_int((*mem.offset((p + 1i32) as isize)).b32.s1);
                    *str_pool.offset(pool_ptr as isize) = '.' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 4i32) as isize)).b32.s0);
                    pool_ptr -= 1
                }
                8 => match (*mem.offset(p as isize)).b16.s0 as i32 {
                    0 => {
                        print_write_whatsit(b"openout\x00" as *const u8 as *const i8, p);
                        print_char('=' as i32);
                        print_file_name(
                            (*mem.offset((p + 1i32) as isize)).b32.s1,
                            (*mem.offset((p + 2i32) as isize)).b32.s0,
                            (*mem.offset((p + 2i32) as isize)).b32.s1,
                        );
                    }
                    1 => {
                        print_write_whatsit(b"write\x00" as *const u8 as *const i8, p);
                        print_mark((*mem.offset((p + 1i32) as isize)).b32.s1);
                    }
                    2 => {
                        print_write_whatsit(b"closeout\x00" as *const u8 as *const i8, p);
                    }
                    3 => {
                        print_esc_cstr(b"special\x00" as *const u8 as *const i8);
                        print_mark((*mem.offset((p + 1i32) as isize)).b32.s1);
                    }
                    4 => {
                        print_esc_cstr(b"setlanguage\x00" as *const u8 as *const i8);
                        print_int((*mem.offset((p + 1i32) as isize)).b32.s1);
                        print_cstr(b" (hyphenmin \x00" as *const u8 as *const i8);
                        print_int((*mem.offset((p + 1i32) as isize)).b16.s1 as i32);
                        print_char(',' as i32);
                        print_int((*mem.offset((p + 1i32) as isize)).b16.s0 as i32);
                        print_char(')' as i32);
                    }
                    40 | 41 => {
                        print_esc(
                            (*hash.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + (*mem.offset((p + 4i32) as isize)).b16.s2 as i32)
                                    as isize,
                            ))
                            .s1,
                        );
                        print_char(' ' as i32);
                        print_native_word(p);
                    }
                    42 => {
                        print_esc(
                            (*hash.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + (*mem.offset((p + 4i32) as isize)).b16.s2 as i32)
                                    as isize,
                            ))
                            .s1,
                        );
                        print_cstr(b" glyph#\x00" as *const u8 as *const i8);
                        print_int((*mem.offset((p + 4i32) as isize)).b16.s1 as i32);
                    }
                    43 | 44 => {
                        if (*mem.offset(p as isize)).b16.s0 as i32 == 43i32 {
                            print_esc_cstr(b"XeTeXpicfile\x00" as *const u8 as *const i8);
                        } else {
                            print_esc_cstr(b"XeTeXpdffile\x00" as *const u8 as *const i8);
                        }
                        print_cstr(b"( \x00" as *const u8 as *const i8);
                        i = 0i32;
                        while i < (*mem.offset((p + 4i32) as isize)).b16.s1 as i32 {
                            print_raw_char(
                                *(&mut *mem.offset((p + 9i32) as isize) as *mut memory_word
                                    as *mut u8)
                                    .offset(i as isize)
                                    as UTF16_code,
                                true,
                            );
                            i += 1
                        }
                        print('\"' as i32);
                    }
                    6 => {
                        print_esc_cstr(b"pdfsavepos\x00" as *const u8 as *const i8);
                    }
                    _ => {
                        print_cstr(b"whatsit?\x00" as *const u8 as *const i8);
                    }
                },
                10 => {
                    if (*mem.offset(p as isize)).b16.s0 as i32 >= 100i32 {
                        /*198: */
                        print_esc_cstr(b"\x00" as *const u8 as *const i8); /*:244 */
                        if (*mem.offset(p as isize)).b16.s0 as i32 == 101i32 {
                            print_char('c' as i32); /*214:*/
                        } else if (*mem.offset(p as isize)).b16.s0 as i32 == 102i32 {
                            print_char('x' as i32);
                        }
                        print_cstr(b"leaders \x00" as *const u8 as *const i8);
                        print_spec((*mem.offset((p + 1i32) as isize)).b32.s0, 0 as *const i8);
                        *str_pool.offset(pool_ptr as isize) = '.' as i32 as packed_UTF16_code;
                        pool_ptr += 1;
                        show_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                        pool_ptr -= 1
                    } else {
                        print_esc_cstr(b"glue\x00" as *const u8 as *const i8);
                        if (*mem.offset(p as isize)).b16.s0 as i32 != 0i32 {
                            print_char('(' as i32);
                            if ((*mem.offset(p as isize)).b16.s0 as i32) < 98i32 {
                                print_skip_param((*mem.offset(p as isize)).b16.s0 as i32 - 1i32);
                            } else if (*mem.offset(p as isize)).b16.s0 as i32 == 98i32 {
                                print_esc_cstr(b"nonscript\x00" as *const u8 as *const i8);
                            } else {
                                print_esc_cstr(b"mskip\x00" as *const u8 as *const i8);
                            }
                            print_char(')' as i32);
                        }
                        if (*mem.offset(p as isize)).b16.s0 as i32 != 98i32 {
                            print_char(' ' as i32);
                            if ((*mem.offset(p as isize)).b16.s0 as i32) < 98i32 {
                                print_spec(
                                    (*mem.offset((p + 1i32) as isize)).b32.s0,
                                    0 as *const i8,
                                );
                            } else {
                                print_spec(
                                    (*mem.offset((p + 1i32) as isize)).b32.s0,
                                    b"mu\x00" as *const u8 as *const i8,
                                );
                            }
                        }
                    }
                }
                11 => {
                    if (*mem.offset(p as isize)).b16.s0 as i32 != 99i32 {
                        print_esc_cstr(b"kern\x00" as *const u8 as *const i8);
                        if (*mem.offset(p as isize)).b16.s0 as i32 != 0i32 {
                            print_char(' ' as i32);
                        }
                        print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
                        if (*mem.offset(p as isize)).b16.s0 as i32 == 2i32 {
                            print_cstr(b" (for accent)\x00" as *const u8 as *const i8);
                        } else if (*mem.offset(p as isize)).b16.s0 as i32 == 3i32 {
                            print_cstr(b" (space adjustment)\x00" as *const u8 as *const i8);
                        }
                    } else {
                        print_esc_cstr(b"mkern\x00" as *const u8 as *const i8);
                        print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
                        print_cstr(b"mu\x00" as *const u8 as *const i8);
                    }
                }
                40 => {
                    print_esc_cstr(b"kern\x00" as *const u8 as *const i8);
                    print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
                    if (*mem.offset(p as isize)).b16.s0 as i32 == 0i32 {
                        print_cstr(b" (left margin)\x00" as *const u8 as *const i8);
                    } else {
                        print_cstr(b" (right margin)\x00" as *const u8 as *const i8);
                    }
                }
                9 => {
                    if (*mem.offset(p as isize)).b16.s0 as i32 > 1i32 {
                        if (*mem.offset(p as isize)).b16.s0 as i32 & 1i32 != 0 {
                            print_esc_cstr(b"end\x00" as *const u8 as *const i8);
                        } else {
                            print_esc_cstr(b"begin\x00" as *const u8 as *const i8);
                        }
                        if (*mem.offset(p as isize)).b16.s0 as i32 > 8i32 {
                            print_char('R' as i32);
                        } else if (*mem.offset(p as isize)).b16.s0 as i32 > 4i32 {
                            print_char('L' as i32);
                        } else {
                            print_char('M' as i32);
                        }
                    } else {
                        print_esc_cstr(b"math\x00" as *const u8 as *const i8);
                        if (*mem.offset(p as isize)).b16.s0 as i32 == 0i32 {
                            print_cstr(b"on\x00" as *const u8 as *const i8);
                        } else {
                            print_cstr(b"off\x00" as *const u8 as *const i8);
                        }
                        if (*mem.offset((p + 1i32) as isize)).b32.s1 != 0i32 {
                            print_cstr(b", surrounded \x00" as *const u8 as *const i8);
                            print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
                        }
                    }
                }
                6 => {
                    print_font_and_char(p + 1i32);
                    print_cstr(b" (ligature \x00" as *const u8 as *const i8);
                    if (*mem.offset(p as isize)).b16.s0 as i32 > 1i32 {
                        print_char('|' as i32);
                    }
                    font_in_short_display = (*mem.offset((p + 1i32) as isize)).b16.s1 as i32;
                    short_display((*mem.offset((p + 1i32) as isize)).b32.s1);
                    if (*mem.offset(p as isize)).b16.s0 as i32 & 1i32 != 0 {
                        print_char('|' as i32);
                    }
                    print_char(')' as i32);
                }
                12 => {
                    print_esc_cstr(b"penalty \x00" as *const u8 as *const i8);
                    print_int((*mem.offset((p + 1i32) as isize)).b32.s1);
                }
                7 => {
                    print_esc_cstr(b"discretionary\x00" as *const u8 as *const i8);
                    if (*mem.offset(p as isize)).b16.s0 as i32 > 0i32 {
                        print_cstr(b" replacing \x00" as *const u8 as *const i8);
                        print_int((*mem.offset(p as isize)).b16.s0 as i32);
                    }
                    *str_pool.offset(pool_ptr as isize) = '.' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 1i32) as isize)).b32.s0);
                    pool_ptr -= 1;
                    *str_pool.offset(pool_ptr as isize) = '|' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    pool_ptr -= 1
                }
                4 => {
                    print_esc_cstr(b"mark\x00" as *const u8 as *const i8);
                    if (*mem.offset((p + 1i32) as isize)).b32.s0 != 0i32 {
                        print_char('s' as i32);
                        print_int((*mem.offset((p + 1i32) as isize)).b32.s0);
                    }
                    print_mark((*mem.offset((p + 1i32) as isize)).b32.s1);
                }
                5 => {
                    print_esc_cstr(b"vadjust\x00" as *const u8 as *const i8);
                    if (*mem.offset(p as isize)).b16.s0 as i32 != 0i32 {
                        print_cstr(b" pre \x00" as *const u8 as *const i8);
                    }
                    *str_pool.offset(pool_ptr as isize) = '.' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    pool_ptr -= 1
                }
                14 => {
                    print_style((*mem.offset(p as isize)).b16.s0 as i32);
                }
                15 => {
                    print_esc_cstr(b"mathchoice\x00" as *const u8 as *const i8);
                    *str_pool.offset(pool_ptr as isize) = 'D' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 1i32) as isize)).b32.s0);
                    pool_ptr -= 1;
                    *str_pool.offset(pool_ptr as isize) = 'T' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    pool_ptr -= 1;
                    *str_pool.offset(pool_ptr as isize) = 'S' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 2i32) as isize)).b32.s0);
                    pool_ptr -= 1;
                    *str_pool.offset(pool_ptr as isize) = 's' as i32 as packed_UTF16_code;
                    pool_ptr += 1;
                    show_node_list((*mem.offset((p + 2i32) as isize)).b32.s1);
                    pool_ptr -= 1
                }
                16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 27 | 26 | 29 | 28 | 30 | 31 => {
                    match (*mem.offset(p as isize)).b16.s1 as i32 {
                        16 => {
                            print_esc_cstr(b"mathord\x00" as *const u8 as *const i8);
                        }
                        17 => {
                            print_esc_cstr(b"mathop\x00" as *const u8 as *const i8);
                        }
                        18 => {
                            print_esc_cstr(b"mathbin\x00" as *const u8 as *const i8);
                        }
                        19 => {
                            print_esc_cstr(b"mathrel\x00" as *const u8 as *const i8);
                        }
                        20 => {
                            print_esc_cstr(b"mathopen\x00" as *const u8 as *const i8);
                        }
                        21 => {
                            print_esc_cstr(b"mathclose\x00" as *const u8 as *const i8);
                        }
                        22 => {
                            print_esc_cstr(b"mathpunct\x00" as *const u8 as *const i8);
                        }
                        23 => {
                            print_esc_cstr(b"mathinner\x00" as *const u8 as *const i8);
                        }
                        27 => {
                            print_esc_cstr(b"overline\x00" as *const u8 as *const i8);
                        }
                        26 => {
                            print_esc_cstr(b"underline\x00" as *const u8 as *const i8);
                        }
                        29 => {
                            print_esc_cstr(b"vcenter\x00" as *const u8 as *const i8);
                        }
                        24 => {
                            print_esc_cstr(b"radical\x00" as *const u8 as *const i8);
                            print_delimiter(p + 4i32);
                        }
                        28 => {
                            print_esc_cstr(b"accent\x00" as *const u8 as *const i8);
                            print_fam_and_char(p + 4i32);
                        }
                        30 => {
                            print_esc_cstr(b"left\x00" as *const u8 as *const i8);
                            print_delimiter(p + 1i32);
                        }
                        31 => {
                            if (*mem.offset(p as isize)).b16.s0 as i32 == 0i32 {
                                print_esc_cstr(b"right\x00" as *const u8 as *const i8);
                            } else {
                                print_esc_cstr(b"middle\x00" as *const u8 as *const i8);
                            }
                            print_delimiter(p + 1i32);
                        }
                        _ => {}
                    }
                    if ((*mem.offset(p as isize)).b16.s1 as i32) < 30i32 {
                        if (*mem.offset(p as isize)).b16.s0 as i32 != 0i32 {
                            if (*mem.offset(p as isize)).b16.s0 as i32 == 1i32 {
                                print_esc_cstr(b"limits\x00" as *const u8 as *const i8);
                            } else {
                                print_esc_cstr(b"nolimits\x00" as *const u8 as *const i8);
                            }
                        }
                        print_subsidiary_data(p + 1i32, '.' as i32 as UTF16_code);
                    }
                    print_subsidiary_data(p + 2i32, '^' as i32 as UTF16_code);
                    print_subsidiary_data(p + 3i32, '_' as i32 as UTF16_code);
                }
                25 => {
                    print_esc_cstr(b"fraction, thickness \x00" as *const u8 as *const i8);
                    if (*mem.offset((p + 1i32) as isize)).b32.s1 == 0x40000000i32 {
                        print_cstr(b"= default\x00" as *const u8 as *const i8);
                    } else {
                        print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
                    }
                    if (*mem.offset((p + 4i32) as isize)).b16.s3 as i32 % 256i32 != 0i32
                        || (*mem.offset((p + 4i32) as isize)).b16.s2 as i64
                            + ((*mem.offset((p + 4i32) as isize)).b16.s3 as i32 / 256i32) as i64
                                * 65536
                            != 0i32 as i64
                        || (*mem.offset((p + 4i32) as isize)).b16.s1 as i32 % 256i32 != 0i32
                        || (*mem.offset((p + 4i32) as isize)).b16.s0 as i64
                            + ((*mem.offset((p + 4i32) as isize)).b16.s1 as i32 / 256i32) as i64
                                * 65536
                            != 0i32 as i64
                    {
                        print_cstr(b", left-delimiter \x00" as *const u8 as *const i8);
                        print_delimiter(p + 4i32);
                    }
                    if (*mem.offset((p + 5i32) as isize)).b16.s3 as i32 % 256i32 != 0i32
                        || (*mem.offset((p + 5i32) as isize)).b16.s2 as i64
                            + ((*mem.offset((p + 5i32) as isize)).b16.s3 as i32 / 256i32) as i64
                                * 65536
                            != 0i32 as i64
                        || (*mem.offset((p + 5i32) as isize)).b16.s1 as i32 % 256i32 != 0i32
                        || (*mem.offset((p + 5i32) as isize)).b16.s0 as i64
                            + ((*mem.offset((p + 5i32) as isize)).b16.s1 as i32 / 256i32) as i64
                                * 65536
                            != 0i32 as i64
                    {
                        print_cstr(b", right-delimiter \x00" as *const u8 as *const i8);
                        print_delimiter(p + 5i32);
                    }
                    print_subsidiary_data(p + 2i32, '\\' as i32 as UTF16_code);
                    print_subsidiary_data(p + 3i32, '/' as i32 as UTF16_code);
                }
                _ => {
                    print_cstr(b"Unknown node type!\x00" as *const u8 as *const i8);
                }
            }
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
}
#[no_mangle]
pub unsafe extern "C" fn show_box(mut p: i32) {
    depth_threshold = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 25i32) as isize,
    ))
    .b32
    .s1;
    breadth_max = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 24i32) as isize,
    ))
    .b32
    .s1;
    if breadth_max <= 0i32 {
        breadth_max = 5i32
    }
    if pool_ptr + depth_threshold >= pool_size {
        depth_threshold = pool_size - pool_ptr - 1i32
    }
    show_node_list(p);
    print_ln();
}
#[no_mangle]
pub unsafe extern "C" fn short_display_n(mut p: i32, mut m: i32) {
    breadth_max = m;
    depth_threshold = pool_size - pool_ptr - 1i32;
    show_node_list(p);
}
#[no_mangle]
pub unsafe extern "C" fn delete_token_ref(mut p: i32) {
    if (*mem.offset(p as isize)).b32.s0 == -0xfffffffi32 {
        flush_list(p);
    } else {
        let ref mut fresh4 = (*mem.offset(p as isize)).b32.s0;
        *fresh4 -= 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn delete_glue_ref(mut p: i32) {
    if (*mem.offset(p as isize)).b32.s1 == -0xfffffffi32 {
        free_node(p, 4i32);
    } else {
        let ref mut fresh5 = (*mem.offset(p as isize)).b32.s1;
        *fresh5 -= 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn flush_node_list(mut p: i32) {
    let mut current_block: u64;
    let mut q: i32 = 0;
    while p != -0xfffffffi32 {
        q = (*mem.offset(p as isize)).b32.s1;
        if is_char_node(p) {
            (*mem.offset(p as isize)).b32.s1 = avail;
            avail = p
        } else {
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 13 => {
                    flush_node_list((*mem.offset((p + 5i32) as isize)).b32.s1);
                    free_node(p, 8i32);
                    current_block = 16791665189521845338;
                }
                2 => {
                    free_node(p, 5i32);
                    current_block = 16791665189521845338;
                }
                3 => {
                    flush_node_list((*mem.offset((p + 4i32) as isize)).b32.s0);
                    delete_glue_ref((*mem.offset((p + 4i32) as isize)).b32.s1);
                    free_node(p, 5i32);
                    current_block = 16791665189521845338;
                }
                8 => {
                    match (*mem.offset(p as isize)).b16.s0 as i32 {
                        0 => {
                            free_node(p, 3i32);
                        }
                        1 | 3 => {
                            delete_token_ref((*mem.offset((p + 1i32) as isize)).b32.s1);
                            free_node(p, 2i32);
                        }
                        2 | 4 => {
                            free_node(p, 2i32);
                        }
                        40 | 41 => {
                            if !(*mem.offset((p + 5i32) as isize)).ptr.is_null() {
                                let ref mut fresh6 = (*mem.offset((p + 5i32) as isize)).ptr;
                                *fresh6 = mfree((*mem.offset((p + 5i32) as isize)).ptr);
                                (*mem.offset((p + 4i32) as isize)).b16.s0 = 0_u16
                            }
                            free_node(p, (*mem.offset((p + 4i32) as isize)).b16.s3 as i32);
                        }
                        42 => {
                            free_node(p, 5i32);
                        }
                        43 | 44 => {
                            free_node(
                                p,
                                (9i32 as u64).wrapping_add(
                                    ((*mem.offset((p + 4i32) as isize)).b16.s1 as u64)
                                        .wrapping_add(::std::mem::size_of::<memory_word>() as u64)
                                        .wrapping_sub(1i32 as u64)
                                        .wrapping_div(::std::mem::size_of::<memory_word>() as u64),
                                ) as i32,
                            );
                        }
                        6 => {
                            free_node(p, 2i32);
                        }
                        _ => {
                            confusion(b"ext3\x00" as *const u8 as *const i8);
                        }
                    }
                    current_block = 16791665189521845338;
                }
                10 => {
                    if (*mem.offset((*mem.offset((p + 1i32) as isize)).b32.s0 as isize))
                        .b32
                        .s1
                        == -0xfffffffi32
                    {
                        free_node((*mem.offset((p + 1i32) as isize)).b32.s0, 4i32);
                    } else {
                        let ref mut fresh7 = (*mem
                            .offset((*mem.offset((p + 1i32) as isize)).b32.s0 as isize))
                        .b32
                        .s1;
                        *fresh7 -= 1
                    }
                    if (*mem.offset((p + 1i32) as isize)).b32.s1 != -0xfffffffi32 {
                        flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    }
                    free_node(p, 3i32);
                    current_block = 16791665189521845338;
                }
                11 | 9 | 12 => {
                    free_node(p, 3i32);
                    current_block = 16791665189521845338;
                }
                40 => {
                    free_node(p, 3i32);
                    current_block = 16791665189521845338;
                }
                6 => {
                    flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    current_block = 8062065914618164218;
                }
                4 => {
                    delete_token_ref((*mem.offset((p + 1i32) as isize)).b32.s1);
                    current_block = 8062065914618164218;
                }
                7 => {
                    flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s0);
                    flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    current_block = 8062065914618164218;
                }
                5 => {
                    flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    current_block = 8062065914618164218;
                }
                14 => {
                    free_node(p, 3i32);
                    current_block = 16791665189521845338;
                }
                15 => {
                    flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s0);
                    flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
                    flush_node_list((*mem.offset((p + 2i32) as isize)).b32.s0);
                    flush_node_list((*mem.offset((p + 2i32) as isize)).b32.s1);
                    free_node(p, 3i32);
                    current_block = 16791665189521845338;
                }
                16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 27 | 26 | 29 | 28 => {
                    if (*mem.offset((p + 1i32) as isize)).b32.s1 >= 2i32 {
                        flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s0);
                    }
                    if (*mem.offset((p + 2i32) as isize)).b32.s1 >= 2i32 {
                        flush_node_list((*mem.offset((p + 2i32) as isize)).b32.s0);
                    }
                    if (*mem.offset((p + 3i32) as isize)).b32.s1 >= 2i32 {
                        flush_node_list((*mem.offset((p + 3i32) as isize)).b32.s0);
                    }
                    if (*mem.offset(p as isize)).b16.s1 as i32 == 24i32 {
                        free_node(p, 5i32);
                    } else if (*mem.offset(p as isize)).b16.s1 as i32 == 28i32 {
                        free_node(p, 5i32);
                    } else {
                        free_node(p, 4i32);
                    }
                    current_block = 16791665189521845338;
                }
                30 | 31 => {
                    free_node(p, 4i32);
                    current_block = 16791665189521845338;
                }
                25 => {
                    flush_node_list((*mem.offset((p + 2i32) as isize)).b32.s0);
                    flush_node_list((*mem.offset((p + 3i32) as isize)).b32.s0);
                    free_node(p, 6i32);
                    current_block = 16791665189521845338;
                }
                _ => {
                    confusion(b"flushing\x00" as *const u8 as *const i8);
                }
            }
            match current_block {
                16791665189521845338 => {}
                _ => {
                    free_node(p, 2i32);
                }
            }
        }
        p = q
    }
}
#[no_mangle]
pub unsafe extern "C" fn copy_node_list(mut p: i32) -> i32 {
    let mut h: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut words: u8 = 0;
    h = get_avail();
    q = h;
    while p != -0xfffffffi32 {
        words = 1_u8;
        if is_char_node(p) {
            r = get_avail()
        } else {
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 13 => {
                    r = get_node(8i32);
                    (*mem.offset((r + 8i32 - 1i32) as isize)).b32.s0 =
                        (*mem.offset((p + 8i32 - 1i32) as isize)).b32.s0;
                    (*mem.offset((r + 8i32 - 1i32) as isize)).b32.s1 =
                        (*mem.offset((p + 8i32 - 1i32) as isize)).b32.s1;
                    *mem.offset((r + 6i32) as isize) = *mem.offset((p + 6i32) as isize);
                    *mem.offset((r + 5i32) as isize) = *mem.offset((p + 5i32) as isize);
                    (*mem.offset((r + 5i32) as isize)).b32.s1 =
                        copy_node_list((*mem.offset((p + 5i32) as isize)).b32.s1);
                    words = 5_u8
                }
                2 => {
                    r = get_node(5i32);
                    words = (5i32 - 1i32) as u8
                }
                3 => {
                    r = get_node(5i32);
                    *mem.offset((r + 4i32) as isize) = *mem.offset((p + 4i32) as isize);
                    let ref mut fresh8 = (*mem
                        .offset((*mem.offset((p + 4i32) as isize)).b32.s1 as isize))
                    .b32
                    .s1;
                    *fresh8 += 1;
                    (*mem.offset((r + 4i32) as isize)).b32.s0 =
                        copy_node_list((*mem.offset((p + 4i32) as isize)).b32.s0);
                    words = (5i32 - 1i32) as u8
                }
                8 => match (*mem.offset(p as isize)).b16.s0 as i32 {
                    0 => {
                        r = get_node(3i32);
                        words = 3_u8
                    }
                    1 | 3 => {
                        r = get_node(2i32);
                        let ref mut fresh9 = (*mem
                            .offset((*mem.offset((p + 1i32) as isize)).b32.s1 as isize))
                        .b32
                        .s0;
                        *fresh9 += 1;
                        words = 2_u8
                    }
                    2 | 4 => {
                        r = get_node(2i32);
                        words = 2_u8
                    }
                    40 | 41 => {
                        words = (*mem.offset((p + 4i32) as isize)).b16.s3 as u8;
                        r = get_node(words as i32);
                        while words as i32 > 0i32 {
                            words = words.wrapping_sub(1);
                            *mem.offset((r + words as i32) as isize) =
                                *mem.offset((p + words as i32) as isize)
                        }
                        let ref mut fresh10 = (*mem.offset((r + 5i32) as isize)).ptr;
                        *fresh10 = 0 as *mut libc::c_void;
                        (*mem.offset((r + 4i32) as isize)).b16.s0 = 0_u16;
                        copy_native_glyph_info(p, r);
                    }
                    42 => {
                        r = get_node(5i32);
                        words = 5_u8
                    }
                    43 | 44 => {
                        words = (9i32 as u64).wrapping_add(
                            ((*mem.offset((p + 4i32) as isize)).b16.s1 as u64)
                                .wrapping_add(::std::mem::size_of::<memory_word>() as u64)
                                .wrapping_sub(1i32 as u64)
                                .wrapping_div(::std::mem::size_of::<memory_word>() as u64),
                        ) as u8;
                        r = get_node(words as i32)
                    }
                    6 => r = get_node(2i32),
                    _ => {
                        confusion(b"ext2\x00" as *const u8 as *const i8);
                    }
                },
                10 => {
                    r = get_node(3i32);
                    let ref mut fresh11 = (*mem
                        .offset((*mem.offset((p + 1i32) as isize)).b32.s0 as isize))
                    .b32
                    .s1;
                    *fresh11 += 1;
                    (*mem.offset((r + 2i32) as isize)).b32.s0 =
                        (*mem.offset((p + 2i32) as isize)).b32.s0;
                    (*mem.offset((r + 2i32) as isize)).b32.s1 =
                        (*mem.offset((p + 2i32) as isize)).b32.s1;
                    (*mem.offset((r + 1i32) as isize)).b32.s0 =
                        (*mem.offset((p + 1i32) as isize)).b32.s0;
                    (*mem.offset((r + 1i32) as isize)).b32.s1 =
                        copy_node_list((*mem.offset((p + 1i32) as isize)).b32.s1)
                }
                11 | 9 | 12 => {
                    r = get_node(3i32);
                    words = 3_u8
                }
                40 => {
                    r = get_node(3i32);
                    words = 3_u8
                }
                6 => {
                    r = get_node(2i32);
                    *mem.offset((r + 1i32) as isize) = *mem.offset((p + 1i32) as isize);
                    (*mem.offset((r + 1i32) as isize)).b32.s1 =
                        copy_node_list((*mem.offset((p + 1i32) as isize)).b32.s1)
                }
                7 => {
                    r = get_node(2i32);
                    (*mem.offset((r + 1i32) as isize)).b32.s0 =
                        copy_node_list((*mem.offset((p + 1i32) as isize)).b32.s0);
                    (*mem.offset((r + 1i32) as isize)).b32.s1 =
                        copy_node_list((*mem.offset((p + 1i32) as isize)).b32.s1)
                }
                4 => {
                    r = get_node(2i32);
                    let ref mut fresh12 = (*mem
                        .offset((*mem.offset((p + 1i32) as isize)).b32.s1 as isize))
                    .b32
                    .s0;
                    *fresh12 += 1;
                    words = 2_u8
                }
                5 => {
                    r = get_node(2i32);
                    (*mem.offset((r + 1i32) as isize)).b32.s1 =
                        copy_node_list((*mem.offset((p + 1i32) as isize)).b32.s1)
                }
                _ => {
                    confusion(b"copying\x00" as *const u8 as *const i8);
                }
            }
        }
        while words as i32 > 0i32 {
            words = words.wrapping_sub(1);
            *mem.offset((r + words as i32) as isize) = *mem.offset((p + words as i32) as isize)
        }
        (*mem.offset(q as isize)).b32.s1 = r;
        q = r;
        p = (*mem.offset(p as isize)).b32.s1
    }
    (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
    q = (*mem.offset(h as isize)).b32.s1;
    (*mem.offset(h as isize)).b32.s1 = avail;
    avail = h;
    q
}
#[no_mangle]
pub unsafe extern "C" fn print_mode(mut m: i32) {
    if m > 0i32 {
        match m / (102i32 + 1i32) {
            0 => {
                print_cstr(b"vertical mode\x00" as *const u8 as *const i8);
            }
            1 => {
                print_cstr(b"horizontal mode\x00" as *const u8 as *const i8);
            }
            2 => {
                print_cstr(b"display math mode\x00" as *const u8 as *const i8);
            }
            _ => {}
        }
    } else if m == 0i32 {
        print_cstr(b"no mode\x00" as *const u8 as *const i8);
    } else {
        match -m / (102i32 + 1i32) {
            0 => {
                print_cstr(b"internal vertical mode\x00" as *const u8 as *const i8);
            }
            1 => {
                print_cstr(b"restricted horizontal mode\x00" as *const u8 as *const i8);
            }
            2 => {
                print_cstr(b"math mode\x00" as *const u8 as *const i8);
            }
            _ => {}
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_in_mode(mut m: i32) {
    if m > 0i32 {
        match m / (102i32 + 1i32) {
            0 => {
                print_cstr(b"\' in vertical mode\x00" as *const u8 as *const i8);
            }
            1 => {
                print_cstr(b"\' in horizontal mode\x00" as *const u8 as *const i8);
            }
            2 => {
                print_cstr(b"\' in display math mode\x00" as *const u8 as *const i8);
            }
            _ => {}
        }
    } else if m == 0i32 {
        print_cstr(b"\' in no mode\x00" as *const u8 as *const i8);
    } else {
        match -m / (102i32 + 1i32) {
            0 => {
                print_cstr(b"\' in internal vertical mode\x00" as *const u8 as *const i8);
            }
            1 => {
                print_cstr(b"\' in restricted horizontal mode\x00" as *const u8 as *const i8);
            }
            2 => {
                print_cstr(b"\' in math mode\x00" as *const u8 as *const i8);
            }
            _ => {}
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn push_nest() {
    if nest_ptr > max_nest_stack {
        max_nest_stack = nest_ptr;
        if nest_ptr == nest_size {
            overflow(
                b"semantic nest size\x00" as *const u8 as *const i8,
                nest_size,
            );
        }
    }
    *nest.offset(nest_ptr as isize) = cur_list;
    nest_ptr += 1;
    cur_list.head = get_avail();
    cur_list.tail = cur_list.head;
    cur_list.prev_graf = 0i32;
    cur_list.mode_line = line;
    cur_list.eTeX_aux = -0xfffffffi32;
}
#[no_mangle]
pub unsafe extern "C" fn pop_nest() {
    (*mem.offset(cur_list.head as isize)).b32.s1 = avail;
    avail = cur_list.head;
    nest_ptr -= 1;
    cur_list = *nest.offset(nest_ptr as isize);
}
#[no_mangle]
pub unsafe extern "C" fn show_activities() {
    let mut p: i32 = 0;
    let mut m: i16 = 0;
    let mut a: memory_word = memory_word {
        b32: b32x2 { s0: 0, s1: 0 },
    };
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut t: i32 = 0;
    *nest.offset(nest_ptr as isize) = cur_list;
    print_nl_cstr(b"\x00" as *const u8 as *const i8);
    print_ln();
    let mut for_end: i32 = 0;
    p = nest_ptr;
    for_end = 0i32;
    if p >= for_end {
        loop {
            m = (*nest.offset(p as isize)).mode;
            a = (*nest.offset(p as isize)).aux;
            print_nl_cstr(b"### \x00" as *const u8 as *const i8);
            print_mode(m as i32);
            print_cstr(b" entered at line \x00" as *const u8 as *const i8);
            print_int((*nest.offset(p as isize)).mode_line.abs());
            if m as i32 == 104i32 {
                if (*nest.offset(p as isize)).prev_graf != 0x830000i32 {
                    print_cstr(b" (language\x00" as *const u8 as *const i8);
                    print_int(((*nest.offset(p as isize)).prev_graf as i64 % 65536) as i32);
                    print_cstr(b":hyphenmin\x00" as *const u8 as *const i8);
                    print_int((*nest.offset(p as isize)).prev_graf / 0x400000i32);
                    print_char(',' as i32);
                    print_int(
                        ((*nest.offset(p as isize)).prev_graf as i64 / 65536 % 64i32 as i64) as i32,
                    );
                    print_char(')' as i32);
                }
            }
            if (*nest.offset(p as isize)).mode_line < 0i32 {
                print_cstr(b" (\\output routine)\x00" as *const u8 as *const i8);
            }
            if p == 0i32 {
                if 4999999i32 - 2i32 != page_tail {
                    print_nl_cstr(b"### current page:\x00" as *const u8 as *const i8);
                    if output_active {
                        print_cstr(b" (held over for next output)\x00" as *const u8 as *const i8);
                    }
                    show_box((*mem.offset((4999999i32 - 2i32) as isize)).b32.s1);
                    if page_contents as i32 > 0i32 {
                        print_nl_cstr(b"total height \x00" as *const u8 as *const i8);
                        print_totals();
                        print_nl_cstr(b" goal height \x00" as *const u8 as *const i8);
                        print_scaled(page_so_far[0]);
                        r = (*mem.offset(4999999)).b32.s1;
                        while r != 4999999i32 {
                            print_ln();
                            print_esc_cstr(b"insert\x00" as *const u8 as *const i8);
                            t = (*mem.offset(r as isize)).b16.s0 as i32;
                            print_int(t);
                            print_cstr(b" adds \x00" as *const u8 as *const i8);
                            if (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 85i32
                                    + t) as isize,
                            ))
                            .b32
                            .s1 == 1000i32
                            {
                                t = (*mem.offset((r + 3i32) as isize)).b32.s1
                            } else {
                                t = x_over_n((*mem.offset((r + 3i32) as isize)).b32.s1, 1000i32)
                                    * (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32
                                            + 1i32
                                            + 3i32 * 256i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 85i32
                                            + t) as isize,
                                    ))
                                    .b32
                                    .s1
                            }
                            print_scaled(t);
                            if (*mem.offset(r as isize)).b16.s1 as i32 == 1i32 {
                                q = 4999999i32 - 2i32;
                                t = 0i32;
                                loop {
                                    q = (*mem.offset(q as isize)).b32.s1;
                                    if (*mem.offset(q as isize)).b16.s1 as i32 == 3i32
                                        && (*mem.offset(q as isize)).b16.s0 as i32
                                            == (*mem.offset(r as isize)).b16.s0 as i32
                                    {
                                        t += 1
                                    }
                                    if q == (*mem.offset((r + 1i32) as isize)).b32.s0 {
                                        break;
                                    }
                                }
                                print_cstr(b", #\x00" as *const u8 as *const i8);
                                print_int(t);
                                print_cstr(b" might split\x00" as *const u8 as *const i8);
                            }
                            r = (*mem.offset(r as isize)).b32.s1
                        }
                    }
                }
                if (*mem.offset((4999999i32 - 1i32) as isize)).b32.s1 != -0xfffffffi32 {
                    print_nl_cstr(b"### recent contributions:\x00" as *const u8 as *const i8);
                }
            }
            show_box(
                (*mem.offset((*nest.offset(p as isize)).head as isize))
                    .b32
                    .s1,
            );
            match (m as i32).abs() / (102i32 + 1i32) {
                0 => {
                    print_nl_cstr(b"prevdepth \x00" as *const u8 as *const i8);
                    if a.b32.s1 <= -65536000i32 {
                        print_cstr(b"ignored\x00" as *const u8 as *const i8);
                    } else {
                        print_scaled(a.b32.s1);
                    }
                    if (*nest.offset(p as isize)).prev_graf != 0i32 {
                        print_cstr(b", prevgraf \x00" as *const u8 as *const i8);
                        print_int((*nest.offset(p as isize)).prev_graf);
                        if (*nest.offset(p as isize)).prev_graf != 1i32 {
                            print_cstr(b" lines\x00" as *const u8 as *const i8);
                        } else {
                            print_cstr(b" line\x00" as *const u8 as *const i8);
                        }
                    }
                }
                1 => {
                    print_nl_cstr(b"spacefactor \x00" as *const u8 as *const i8);
                    print_int(a.b32.s0);
                    if m as i32 > 0i32 {
                        if a.b32.s1 > 0i32 {
                            print_cstr(b", current language \x00" as *const u8 as *const i8);
                            print_int(a.b32.s1);
                        }
                    }
                }
                2 => {
                    if a.b32.s1 != -0xfffffffi32 {
                        print_cstr(b"this will be denominator of:\x00" as *const u8 as *const i8);
                        show_box(a.b32.s1);
                    }
                }
                _ => {}
            }
            let fresh13 = p;
            p = p - 1;
            if !(fresh13 > for_end) {
                break;
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_param(mut n: i32) {
    match n {
        0 => {
            print_esc_cstr(b"pretolerance\x00" as *const u8 as *const i8);
        }
        1 => {
            print_esc_cstr(b"tolerance\x00" as *const u8 as *const i8);
        }
        2 => {
            print_esc_cstr(b"linepenalty\x00" as *const u8 as *const i8);
        }
        3 => {
            print_esc_cstr(b"hyphenpenalty\x00" as *const u8 as *const i8);
        }
        4 => {
            print_esc_cstr(b"exhyphenpenalty\x00" as *const u8 as *const i8);
        }
        5 => {
            print_esc_cstr(b"clubpenalty\x00" as *const u8 as *const i8);
        }
        6 => {
            print_esc_cstr(b"widowpenalty\x00" as *const u8 as *const i8);
        }
        7 => {
            print_esc_cstr(b"displaywidowpenalty\x00" as *const u8 as *const i8);
        }
        8 => {
            print_esc_cstr(b"brokenpenalty\x00" as *const u8 as *const i8);
        }
        9 => {
            print_esc_cstr(b"binoppenalty\x00" as *const u8 as *const i8);
        }
        10 => {
            print_esc_cstr(b"relpenalty\x00" as *const u8 as *const i8);
        }
        11 => {
            print_esc_cstr(b"predisplaypenalty\x00" as *const u8 as *const i8);
        }
        12 => {
            print_esc_cstr(b"postdisplaypenalty\x00" as *const u8 as *const i8);
        }
        13 => {
            print_esc_cstr(b"interlinepenalty\x00" as *const u8 as *const i8);
        }
        14 => {
            print_esc_cstr(b"doublehyphendemerits\x00" as *const u8 as *const i8);
        }
        15 => {
            print_esc_cstr(b"finalhyphendemerits\x00" as *const u8 as *const i8);
        }
        16 => {
            print_esc_cstr(b"adjdemerits\x00" as *const u8 as *const i8);
        }
        17 => {
            print_esc_cstr(b"mag\x00" as *const u8 as *const i8);
        }
        18 => {
            print_esc_cstr(b"delimiterfactor\x00" as *const u8 as *const i8);
        }
        19 => {
            print_esc_cstr(b"looseness\x00" as *const u8 as *const i8);
        }
        20 => {
            print_esc_cstr(b"time\x00" as *const u8 as *const i8);
        }
        21 => {
            print_esc_cstr(b"day\x00" as *const u8 as *const i8);
        }
        22 => {
            print_esc_cstr(b"month\x00" as *const u8 as *const i8);
        }
        23 => {
            print_esc_cstr(b"year\x00" as *const u8 as *const i8);
        }
        24 => {
            print_esc_cstr(b"showboxbreadth\x00" as *const u8 as *const i8);
        }
        25 => {
            print_esc_cstr(b"showboxdepth\x00" as *const u8 as *const i8);
        }
        26 => {
            print_esc_cstr(b"hbadness\x00" as *const u8 as *const i8);
        }
        27 => {
            print_esc_cstr(b"vbadness\x00" as *const u8 as *const i8);
        }
        28 => {
            print_esc_cstr(b"pausing\x00" as *const u8 as *const i8);
        }
        29 => {
            print_esc_cstr(b"tracingonline\x00" as *const u8 as *const i8);
        }
        30 => {
            print_esc_cstr(b"tracingmacros\x00" as *const u8 as *const i8);
        }
        31 => {
            print_esc_cstr(b"tracingstats\x00" as *const u8 as *const i8);
        }
        32 => {
            print_esc_cstr(b"tracingparagraphs\x00" as *const u8 as *const i8);
        }
        33 => {
            print_esc_cstr(b"tracingpages\x00" as *const u8 as *const i8);
        }
        34 => {
            print_esc_cstr(b"tracingoutput\x00" as *const u8 as *const i8);
        }
        35 => {
            print_esc_cstr(b"tracinglostchars\x00" as *const u8 as *const i8);
        }
        36 => {
            print_esc_cstr(b"tracingcommands\x00" as *const u8 as *const i8);
        }
        37 => {
            print_esc_cstr(b"tracingrestores\x00" as *const u8 as *const i8);
        }
        38 => {
            print_esc_cstr(b"uchyph\x00" as *const u8 as *const i8);
        }
        39 => {
            print_esc_cstr(b"outputpenalty\x00" as *const u8 as *const i8);
        }
        40 => {
            print_esc_cstr(b"maxdeadcycles\x00" as *const u8 as *const i8);
        }
        41 => {
            print_esc_cstr(b"hangafter\x00" as *const u8 as *const i8);
        }
        42 => {
            print_esc_cstr(b"floatingpenalty\x00" as *const u8 as *const i8);
        }
        43 => {
            print_esc_cstr(b"globaldefs\x00" as *const u8 as *const i8);
        }
        44 => {
            print_esc_cstr(b"fam\x00" as *const u8 as *const i8);
        }
        45 => {
            print_esc_cstr(b"escapechar\x00" as *const u8 as *const i8);
        }
        46 => {
            print_esc_cstr(b"defaulthyphenchar\x00" as *const u8 as *const i8);
        }
        47 => {
            print_esc_cstr(b"defaultskewchar\x00" as *const u8 as *const i8);
        }
        48 => {
            print_esc_cstr(b"endlinechar\x00" as *const u8 as *const i8);
        }
        49 => {
            print_esc_cstr(b"newlinechar\x00" as *const u8 as *const i8);
        }
        50 => {
            print_esc_cstr(b"language\x00" as *const u8 as *const i8);
        }
        51 => {
            print_esc_cstr(b"lefthyphenmin\x00" as *const u8 as *const i8);
        }
        52 => {
            print_esc_cstr(b"righthyphenmin\x00" as *const u8 as *const i8);
        }
        53 => {
            print_esc_cstr(b"holdinginserts\x00" as *const u8 as *const i8);
        }
        54 => {
            print_esc_cstr(b"errorcontextlines\x00" as *const u8 as *const i8);
        }
        55 => {
            print_esc_cstr(b"charsubdefmin\x00" as *const u8 as *const i8);
        }
        56 => {
            print_esc_cstr(b"charsubdefmax\x00" as *const u8 as *const i8);
        }
        57 => {
            print_esc_cstr(b"tracingcharsubdef\x00" as *const u8 as *const i8);
        }
        69 => {
            print_esc_cstr(b"XeTeXlinebreakpenalty\x00" as *const u8 as *const i8);
        }
        70 => {
            print_esc_cstr(b"XeTeXprotrudechars\x00" as *const u8 as *const i8);
        }
        83 => {
            print_esc_cstr(b"synctex\x00" as *const u8 as *const i8);
        }
        58 => {
            print_esc_cstr(b"tracingassigns\x00" as *const u8 as *const i8);
        }
        59 => {
            print_esc_cstr(b"tracinggroups\x00" as *const u8 as *const i8);
        }
        60 => {
            print_esc_cstr(b"tracingifs\x00" as *const u8 as *const i8);
        }
        61 => {
            print_esc_cstr(b"tracingscantokens\x00" as *const u8 as *const i8);
        }
        62 => {
            print_esc_cstr(b"tracingnesting\x00" as *const u8 as *const i8);
        }
        63 => {
            print_esc_cstr(b"predisplaydirection\x00" as *const u8 as *const i8);
        }
        64 => {
            print_esc_cstr(b"lastlinefit\x00" as *const u8 as *const i8);
        }
        65 => {
            print_esc_cstr(b"savingvdiscards\x00" as *const u8 as *const i8);
        }
        66 => {
            print_esc_cstr(b"savinghyphcodes\x00" as *const u8 as *const i8);
        }
        67 => {
            print_esc_cstr(b"suppressfontnotfounderror\x00" as *const u8 as *const i8);
        }
        71 => {
            print_esc_cstr(b"TeXXeTstate\x00" as *const u8 as *const i8);
        }
        73 => {
            print_esc_cstr(b"XeTeXupwardsmode\x00" as *const u8 as *const i8);
        }
        74 => {
            print_esc_cstr(b"XeTeXuseglyphmetrics\x00" as *const u8 as *const i8);
        }
        75 => {
            print_esc_cstr(b"XeTeXinterchartokenstate\x00" as *const u8 as *const i8);
        }
        72 => {
            print_esc_cstr(b"XeTeXdashbreakstate\x00" as *const u8 as *const i8);
        }
        76 => {
            print_esc_cstr(b"XeTeXinputnormalization\x00" as *const u8 as *const i8);
        }
        79 => {
            print_esc_cstr(b"XeTeXtracingfonts\x00" as *const u8 as *const i8);
        }
        80 => {
            print_esc_cstr(b"XeTeXinterwordspaceshaping\x00" as *const u8 as *const i8);
        }
        81 => {
            print_esc_cstr(b"XeTeXgenerateactualtext\x00" as *const u8 as *const i8);
        }
        82 => {
            print_esc_cstr(b"XeTeXhyphenatablelength\x00" as *const u8 as *const i8);
        }
        84 => {
            print_esc_cstr(b"pdfoutput\x00" as *const u8 as *const i8);
        }
        _ => {
            print_cstr(b"[unknown i32 parameter!]\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn begin_diagnostic() {
    old_setting = selector;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 29i32) as isize,
    ))
    .b32
    .s1 <= 0i32
        && selector == Selector::TERM_AND_LOG
    {
        selector = (u8::from(selector) - 1).into();
        if history == TTHistory::SPOTLESS {
            history = TTHistory::WARNING_ISSUED
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn end_diagnostic(mut blank_line: bool) {
    print_nl_cstr(b"\x00" as *const u8 as *const i8);
    if blank_line {
        print_ln();
    }
    selector = old_setting;
}
#[no_mangle]
pub unsafe extern "C" fn print_length_param(mut n: i32) {
    match n {
        0 => {
            print_esc_cstr(b"parindent\x00" as *const u8 as *const i8);
        }
        1 => {
            print_esc_cstr(b"mathsurround\x00" as *const u8 as *const i8);
        }
        2 => {
            print_esc_cstr(b"lineskiplimit\x00" as *const u8 as *const i8);
        }
        3 => {
            print_esc_cstr(b"hsize\x00" as *const u8 as *const i8);
        }
        4 => {
            print_esc_cstr(b"vsize\x00" as *const u8 as *const i8);
        }
        5 => {
            print_esc_cstr(b"maxdepth\x00" as *const u8 as *const i8);
        }
        6 => {
            print_esc_cstr(b"splitmaxdepth\x00" as *const u8 as *const i8);
        }
        7 => {
            print_esc_cstr(b"boxmaxdepth\x00" as *const u8 as *const i8);
        }
        8 => {
            print_esc_cstr(b"hfuzz\x00" as *const u8 as *const i8);
        }
        9 => {
            print_esc_cstr(b"vfuzz\x00" as *const u8 as *const i8);
        }
        10 => {
            print_esc_cstr(b"delimitershortfall\x00" as *const u8 as *const i8);
        }
        11 => {
            print_esc_cstr(b"nulldelimiterspace\x00" as *const u8 as *const i8);
        }
        12 => {
            print_esc_cstr(b"scriptspace\x00" as *const u8 as *const i8);
        }
        13 => {
            print_esc_cstr(b"predisplaysize\x00" as *const u8 as *const i8);
        }
        14 => {
            print_esc_cstr(b"displaywidth\x00" as *const u8 as *const i8);
        }
        15 => {
            print_esc_cstr(b"displayindent\x00" as *const u8 as *const i8);
        }
        16 => {
            print_esc_cstr(b"overfullrule\x00" as *const u8 as *const i8);
        }
        17 => {
            print_esc_cstr(b"hangindent\x00" as *const u8 as *const i8);
        }
        18 => {
            print_esc_cstr(b"hoffset\x00" as *const u8 as *const i8);
        }
        19 => {
            print_esc_cstr(b"voffset\x00" as *const u8 as *const i8);
        }
        20 => {
            print_esc_cstr(b"emergencystretch\x00" as *const u8 as *const i8);
        }
        21 => {
            print_esc_cstr(b"pdfpagewidth\x00" as *const u8 as *const i8);
        }
        22 => {
            print_esc_cstr(b"pdfpageheight\x00" as *const u8 as *const i8);
        }
        _ => {
            print_cstr(b"[unknown dimen parameter!]\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_cmd_chr(mut cmd: u16, mut chr_code: i32) {
    let mut n: i32 = 0;
    let mut font_name_str: str_number = 0;
    let mut quote_char: UTF16_code = 0;
    match cmd as i32 {
        1 => {
            print_cstr(b"begin-group character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        2 => {
            print_cstr(b"end-group character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        3 => {
            print_cstr(b"math shift character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        6 => {
            print_cstr(b"macro parameter character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        7 => {
            print_cstr(b"superscript character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        8 => {
            print_cstr(b"subscript character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        9 => {
            print_cstr(b"end of alignment template\x00" as *const u8 as *const i8);
        }
        10 => {
            print_cstr(b"blank space \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        11 => {
            print_cstr(b"the letter \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        12 => {
            print_cstr(b"the character \x00" as *const u8 as *const i8);
            if (chr_code as i64) < 65536 {
                print(chr_code);
            } else {
                print_char(chr_code);
            }
        }
        76 | 77 => {
            if chr_code
                < 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
            {
                print_skip_param(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32),
                );
            } else if chr_code
                < 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
            {
                print_esc_cstr(b"skip\x00" as *const u8 as *const i8);
                print_int(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32),
                );
            } else {
                print_esc_cstr(b"muskip\x00" as *const u8 as *const i8);
                print_int(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32),
                );
            }
        }
        73 => {
            if chr_code
                >= 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
            {
                print_esc_cstr(b"toks\x00" as *const u8 as *const i8);
                print_int(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32),
                );
            } else {
                match chr_code {
                    2252772 => {
                        print_esc_cstr(b"output\x00" as *const u8 as *const i8);
                    }
                    2252773 => {
                        print_esc_cstr(b"everypar\x00" as *const u8 as *const i8);
                    }
                    2252774 => {
                        print_esc_cstr(b"everymath\x00" as *const u8 as *const i8);
                    }
                    2252775 => {
                        print_esc_cstr(b"everydisplay\x00" as *const u8 as *const i8);
                    }
                    2252776 => {
                        print_esc_cstr(b"everyhbox\x00" as *const u8 as *const i8);
                    }
                    2252777 => {
                        print_esc_cstr(b"everyvbox\x00" as *const u8 as *const i8);
                    }
                    2252778 => {
                        print_esc_cstr(b"everyjob\x00" as *const u8 as *const i8);
                    }
                    2252779 => {
                        print_esc_cstr(b"everycr\x00" as *const u8 as *const i8);
                    }
                    2252781 => {
                        print_esc_cstr(b"everyeof\x00" as *const u8 as *const i8);
                    }
                    2252782 => {
                        print_esc_cstr(b"XeTeXinterchartoks\x00" as *const u8 as *const i8);
                    }
                    2252783 => {
                        print_esc_cstr(b"TectonicCodaTokens\x00" as *const u8 as *const i8);
                    }
                    _ => {
                        print_esc_cstr(b"errhelp\x00" as *const u8 as *const i8);
                    }
                }
            }
        }
        74 => {
            if chr_code
                < 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 85i32
            {
                print_param(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)),
                );
            } else {
                print_esc_cstr(b"count\x00" as *const u8 as *const i8);
                print_int(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 85i32),
                );
            }
        }
        75 => {
            if chr_code
                < 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 85i32
                    + 256i32
                    + (0x10ffffi32 + 1i32)
                    + 23i32
            {
                print_length_param(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 85i32
                            + 256i32
                            + (0x10ffffi32 + 1i32)),
                );
            } else {
                print_esc_cstr(b"dimen\x00" as *const u8 as *const i8);
                print_int(
                    chr_code
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 85i32
                            + 256i32
                            + (0x10ffffi32 + 1i32)
                            + 23i32),
                );
            }
        }
        45 => {
            print_esc_cstr(b"accent\x00" as *const u8 as *const i8);
        }
        92 => {
            print_esc_cstr(b"advance\x00" as *const u8 as *const i8);
        }
        40 => {
            print_esc_cstr(b"afterassignment\x00" as *const u8 as *const i8);
        }
        41 => {
            print_esc_cstr(b"aftergroup\x00" as *const u8 as *const i8);
        }
        78 => {
            print_esc_cstr(b"fontdimen\x00" as *const u8 as *const i8);
        }
        61 => {
            print_esc_cstr(b"begingroup\x00" as *const u8 as *const i8);
        }
        42 => {
            print_esc_cstr(b"penalty\x00" as *const u8 as *const i8);
        }
        16 => {
            print_esc_cstr(b"char\x00" as *const u8 as *const i8);
        }
        109 => {
            print_esc_cstr(b"csname\x00" as *const u8 as *const i8);
        }
        90 => {
            print_esc_cstr(b"font\x00" as *const u8 as *const i8);
        }
        15 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"Udelimiter\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"delimiter\x00" as *const u8 as *const i8);
            }
        }
        94 => {
            print_esc_cstr(b"divide\x00" as *const u8 as *const i8);
        }
        67 => {
            print_esc_cstr(b"endcsname\x00" as *const u8 as *const i8);
        }
        62 => {
            print_esc_cstr(b"endgroup\x00" as *const u8 as *const i8);
        }
        64 => {
            print_esc(' ' as i32);
        }
        104 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"expandafter\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"unless\x00" as *const u8 as *const i8);
            }
        }
        32 => {
            print_esc_cstr(b"halign\x00" as *const u8 as *const i8);
        }
        36 => {
            print_esc_cstr(b"hrule\x00" as *const u8 as *const i8);
        }
        39 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"ignorespaces\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"primitive\x00" as *const u8 as *const i8);
            }
        }
        37 => {
            print_esc_cstr(b"insert\x00" as *const u8 as *const i8);
        }
        44 => {
            print_esc('/' as i32);
        }
        18 => {
            print_esc_cstr(b"mark\x00" as *const u8 as *const i8);
            if chr_code > 0i32 {
                print_char('s' as i32);
            }
        }
        46 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"Umathaccent\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"mathaccent\x00" as *const u8 as *const i8);
            }
        }
        17 => {
            if chr_code == 2i32 {
                print_esc_cstr(b"Umathchar\x00" as *const u8 as *const i8);
            } else if chr_code == 1i32 {
                print_esc_cstr(b"Umathcharnum\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"mathchar\x00" as *const u8 as *const i8);
            }
        }
        54 => {
            print_esc_cstr(b"mathchoice\x00" as *const u8 as *const i8);
        }
        93 => {
            print_esc_cstr(b"multiply\x00" as *const u8 as *const i8);
        }
        34 => {
            print_esc_cstr(b"noalign\x00" as *const u8 as *const i8);
        }
        65 => {
            print_esc_cstr(b"noboundary\x00" as *const u8 as *const i8);
        }
        105 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"noexpand\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"primitive\x00" as *const u8 as *const i8);
            }
        }
        55 => {
            print_esc_cstr(b"nonscript\x00" as *const u8 as *const i8);
        }
        63 => {
            print_esc_cstr(b"omit\x00" as *const u8 as *const i8);
        }
        66 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"Uradical\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"radical\x00" as *const u8 as *const i8);
            }
        }
        98 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"read\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"readline\x00" as *const u8 as *const i8);
            }
        }
        0 => {
            print_esc_cstr(b"relax\x00" as *const u8 as *const i8);
        }
        100 => {
            print_esc_cstr(b"setbox\x00" as *const u8 as *const i8);
        }
        81 => {
            print_esc_cstr(b"prevgraf\x00" as *const u8 as *const i8);
        }
        85 => match chr_code {
            2252771 => {
                print_esc_cstr(b"parshape\x00" as *const u8 as *const i8);
            }
            2253040 => {
                print_esc_cstr(b"interlinepenalties\x00" as *const u8 as *const i8);
            }
            2253041 => {
                print_esc_cstr(b"clubpenalties\x00" as *const u8 as *const i8);
            }
            2253042 => {
                print_esc_cstr(b"widowpenalties\x00" as *const u8 as *const i8);
            }
            2253043 => {
                print_esc_cstr(b"displaywidowpenalties\x00" as *const u8 as *const i8);
            }
            _ => {}
        },
        111 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"the\x00" as *const u8 as *const i8);
            } else if chr_code == 1i32 {
                print_esc_cstr(b"unexpanded\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"detokenize\x00" as *const u8 as *const i8);
            }
        }
        72 => {
            print_esc_cstr(b"toks\x00" as *const u8 as *const i8);
            if chr_code != 0i32 {
                print_sa_num(chr_code);
            }
        }
        38 => {
            print_esc_cstr(b"vadjust\x00" as *const u8 as *const i8);
        }
        33 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"valign\x00" as *const u8 as *const i8);
            } else {
                match chr_code {
                    6 => {
                        print_esc_cstr(b"beginL\x00" as *const u8 as *const i8);
                    }
                    7 => {
                        print_esc_cstr(b"endL\x00" as *const u8 as *const i8);
                    }
                    10 => {
                        print_esc_cstr(b"beginR\x00" as *const u8 as *const i8);
                    }
                    _ => {
                        print_esc_cstr(b"endR\x00" as *const u8 as *const i8);
                    }
                }
            }
        }
        56 => {
            print_esc_cstr(b"vcenter\x00" as *const u8 as *const i8);
        }
        35 => {
            print_esc_cstr(b"vrule\x00" as *const u8 as *const i8);
        }
        13 => {
            print_esc_cstr(b"par\x00" as *const u8 as *const i8);
        }
        106 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"input\x00" as *const u8 as *const i8);
            } else if chr_code == 2i32 {
                print_esc_cstr(b"scantokens\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"endinput\x00" as *const u8 as *const i8);
            }
        }
        112 => {
            match chr_code % 5i32 {
                1 => {
                    print_esc_cstr(b"firstmark\x00" as *const u8 as *const i8);
                }
                2 => {
                    print_esc_cstr(b"botmark\x00" as *const u8 as *const i8);
                }
                3 => {
                    print_esc_cstr(b"splitfirstmark\x00" as *const u8 as *const i8);
                }
                4 => {
                    print_esc_cstr(b"splitbotmark\x00" as *const u8 as *const i8);
                }
                _ => {
                    print_esc_cstr(b"topmark\x00" as *const u8 as *const i8);
                }
            }
            if chr_code >= 5i32 {
                print_char('s' as i32);
            }
        }
        91 => {
            if chr_code < 0i32 || chr_code > 19i32 {
                /*lo_mem_stat_max*/
                cmd = ((*mem.offset(chr_code as isize)).b16.s1 as i32 / 64i32) as u16
            } else {
                cmd = chr_code as u16;
                chr_code = -0xfffffffi32
            }
            if cmd as i32 == 0i32 {
                print_esc_cstr(b"count\x00" as *const u8 as *const i8);
            } else if cmd as i32 == 1i32 {
                print_esc_cstr(b"dimen\x00" as *const u8 as *const i8);
            } else if cmd as i32 == 2i32 {
                print_esc_cstr(b"skip\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"muskip\x00" as *const u8 as *const i8);
            }
            if chr_code != -0xfffffffi32 {
                print_sa_num(chr_code);
            }
        }
        80 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"prevdepth\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"spacefactor\x00" as *const u8 as *const i8);
            }
        }
        83 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"deadcycles\x00" as *const u8 as *const i8);
            } else if chr_code == 2i32 {
                print_esc_cstr(b"interactionmode\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"insertpenalties\x00" as *const u8 as *const i8);
            }
        }
        84 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"wd\x00" as *const u8 as *const i8);
            } else if chr_code == 3i32 {
                print_esc_cstr(b"ht\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"dp\x00" as *const u8 as *const i8);
            }
        }
        71 => match chr_code {
            0 => {
                print_esc_cstr(b"lastpenalty\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"lastkern\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"lastskip\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"inputlineno\x00" as *const u8 as *const i8);
            }
            45 => {
                print_esc_cstr(b"shellescape\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"lastnodetype\x00" as *const u8 as *const i8);
            }
            6 => {
                print_esc_cstr(b"eTeXversion\x00" as *const u8 as *const i8);
            }
            14 => {
                print_esc_cstr(b"XeTeXversion\x00" as *const u8 as *const i8);
            }
            15 => {
                print_esc_cstr(b"XeTeXcountglyphs\x00" as *const u8 as *const i8);
            }
            16 => {
                print_esc_cstr(b"XeTeXcountvariations\x00" as *const u8 as *const i8);
            }
            17 => {
                print_esc_cstr(b"XeTeXvariation\x00" as *const u8 as *const i8);
            }
            18 => {
                print_esc_cstr(b"XeTeXfindvariationbyname\x00" as *const u8 as *const i8);
            }
            19 => {
                print_esc_cstr(b"XeTeXvariationmin\x00" as *const u8 as *const i8);
            }
            20 => {
                print_esc_cstr(b"XeTeXvariationmax\x00" as *const u8 as *const i8);
            }
            21 => {
                print_esc_cstr(b"XeTeXvariationdefault\x00" as *const u8 as *const i8);
            }
            22 => {
                print_esc_cstr(b"XeTeXcountfeatures\x00" as *const u8 as *const i8);
            }
            23 => {
                print_esc_cstr(b"XeTeXfeaturecode\x00" as *const u8 as *const i8);
            }
            24 => {
                print_esc_cstr(b"XeTeXfindfeaturebyname\x00" as *const u8 as *const i8);
            }
            25 => {
                print_esc_cstr(b"XeTeXisexclusivefeature\x00" as *const u8 as *const i8);
            }
            26 => {
                print_esc_cstr(b"XeTeXcountselectors\x00" as *const u8 as *const i8);
            }
            27 => {
                print_esc_cstr(b"XeTeXselectorcode\x00" as *const u8 as *const i8);
            }
            28 => {
                print_esc_cstr(b"XeTeXfindselectorbyname\x00" as *const u8 as *const i8);
            }
            29 => {
                print_esc_cstr(b"XeTeXisdefaultselector\x00" as *const u8 as *const i8);
            }
            30 => {
                print_esc_cstr(b"XeTeXOTcountscripts\x00" as *const u8 as *const i8);
            }
            31 => {
                print_esc_cstr(b"XeTeXOTcountlanguages\x00" as *const u8 as *const i8);
            }
            32 => {
                print_esc_cstr(b"XeTeXOTcountfeatures\x00" as *const u8 as *const i8);
            }
            33 => {
                print_esc_cstr(b"XeTeXOTscripttag\x00" as *const u8 as *const i8);
            }
            34 => {
                print_esc_cstr(b"XeTeXOTlanguagetag\x00" as *const u8 as *const i8);
            }
            35 => {
                print_esc_cstr(b"XeTeXOTfeaturetag\x00" as *const u8 as *const i8);
            }
            36 => {
                print_esc_cstr(b"XeTeXcharglyph\x00" as *const u8 as *const i8);
            }
            37 => {
                print_esc_cstr(b"XeTeXglyphindex\x00" as *const u8 as *const i8);
            }
            47 => {
                print_esc_cstr(b"XeTeXglyphbounds\x00" as *const u8 as *const i8);
            }
            38 => {
                print_esc_cstr(b"XeTeXfonttype\x00" as *const u8 as *const i8);
            }
            39 => {
                print_esc_cstr(b"XeTeXfirstfontchar\x00" as *const u8 as *const i8);
            }
            40 => {
                print_esc_cstr(b"XeTeXlastfontchar\x00" as *const u8 as *const i8);
            }
            41 => {
                print_esc_cstr(b"pdflastxpos\x00" as *const u8 as *const i8);
            }
            42 => {
                print_esc_cstr(b"pdflastypos\x00" as *const u8 as *const i8);
            }
            46 => {
                print_esc_cstr(b"XeTeXpdfpagecount\x00" as *const u8 as *const i8);
            }
            7 => {
                print_esc_cstr(b"currentgrouplevel\x00" as *const u8 as *const i8);
            }
            8 => {
                print_esc_cstr(b"currentgrouptype\x00" as *const u8 as *const i8);
            }
            9 => {
                print_esc_cstr(b"currentiflevel\x00" as *const u8 as *const i8);
            }
            10 => {
                print_esc_cstr(b"currentiftype\x00" as *const u8 as *const i8);
            }
            11 => {
                print_esc_cstr(b"currentifbranch\x00" as *const u8 as *const i8);
            }
            48 => {
                print_esc_cstr(b"fontcharwd\x00" as *const u8 as *const i8);
            }
            49 => {
                print_esc_cstr(b"fontcharht\x00" as *const u8 as *const i8);
            }
            50 => {
                print_esc_cstr(b"fontchardp\x00" as *const u8 as *const i8);
            }
            51 => {
                print_esc_cstr(b"fontcharic\x00" as *const u8 as *const i8);
            }
            52 => {
                print_esc_cstr(b"parshapelength\x00" as *const u8 as *const i8);
            }
            53 => {
                print_esc_cstr(b"parshapeindent\x00" as *const u8 as *const i8);
            }
            54 => {
                print_esc_cstr(b"parshapedimen\x00" as *const u8 as *const i8);
            }
            59 => {
                print_esc_cstr(b"numexpr\x00" as *const u8 as *const i8);
            }
            60 => {
                print_esc_cstr(b"dimexpr\x00" as *const u8 as *const i8);
            }
            61 => {
                print_esc_cstr(b"glueexpr\x00" as *const u8 as *const i8);
            }
            62 => {
                print_esc_cstr(b"muexpr\x00" as *const u8 as *const i8);
            }
            12 => {
                print_esc_cstr(b"gluestretchorder\x00" as *const u8 as *const i8);
            }
            13 => {
                print_esc_cstr(b"glueshrinkorder\x00" as *const u8 as *const i8);
            }
            55 => {
                print_esc_cstr(b"gluestretch\x00" as *const u8 as *const i8);
            }
            56 => {
                print_esc_cstr(b"glueshrink\x00" as *const u8 as *const i8);
            }
            57 => {
                print_esc_cstr(b"mutoglue\x00" as *const u8 as *const i8);
            }
            58 => {
                print_esc_cstr(b"gluetomu\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"badness\x00" as *const u8 as *const i8);
            }
        },
        110 => match chr_code {
            0 => {
                print_esc_cstr(b"number\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"romannumeral\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"string\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"meaning\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"fontname\x00" as *const u8 as *const i8);
            }
            43 => {
                print_esc_cstr(b"strcmp\x00" as *const u8 as *const i8);
            }
            44 => {
                print_esc_cstr(b"mdfivesum\x00" as *const u8 as *const i8);
            }
            11 => {
                print_esc_cstr(b"leftmarginkern\x00" as *const u8 as *const i8);
            }
            12 => {
                print_esc_cstr(b"rightmarginkern\x00" as *const u8 as *const i8);
            }
            5 => {
                print_esc_cstr(b"eTeXrevision\x00" as *const u8 as *const i8);
            }
            6 => {
                print_esc_cstr(b"XeTeXrevision\x00" as *const u8 as *const i8);
            }
            7 => {
                print_esc_cstr(b"XeTeXvariationname\x00" as *const u8 as *const i8);
            }
            8 => {
                print_esc_cstr(b"XeTeXfeaturename\x00" as *const u8 as *const i8);
            }
            9 => {
                print_esc_cstr(b"XeTeXselectorname\x00" as *const u8 as *const i8);
            }
            10 => {
                print_esc_cstr(b"XeTeXglyphname\x00" as *const u8 as *const i8);
            }
            13 => {
                print_esc_cstr(b"Uchar\x00" as *const u8 as *const i8);
            }
            14 => {
                print_esc_cstr(b"Ucharcat\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"jobname\x00" as *const u8 as *const i8);
            }
        },
        107 => {
            if chr_code >= 32i32 {
                print_esc_cstr(b"unless\x00" as *const u8 as *const i8);
            }
            match chr_code % 32i32 {
                1 => {
                    print_esc_cstr(b"ifcat\x00" as *const u8 as *const i8);
                }
                2 => {
                    print_esc_cstr(b"ifnum\x00" as *const u8 as *const i8);
                }
                3 => {
                    print_esc_cstr(b"ifdim\x00" as *const u8 as *const i8);
                }
                4 => {
                    print_esc_cstr(b"ifodd\x00" as *const u8 as *const i8);
                }
                5 => {
                    print_esc_cstr(b"ifvmode\x00" as *const u8 as *const i8);
                }
                6 => {
                    print_esc_cstr(b"ifhmode\x00" as *const u8 as *const i8);
                }
                7 => {
                    print_esc_cstr(b"ifmmode\x00" as *const u8 as *const i8);
                }
                8 => {
                    print_esc_cstr(b"ifinner\x00" as *const u8 as *const i8);
                }
                9 => {
                    print_esc_cstr(b"ifvoid\x00" as *const u8 as *const i8);
                }
                10 => {
                    print_esc_cstr(b"ifhbox\x00" as *const u8 as *const i8);
                }
                11 => {
                    print_esc_cstr(b"ifvbox\x00" as *const u8 as *const i8);
                }
                12 => {
                    print_esc_cstr(b"ifx\x00" as *const u8 as *const i8);
                }
                13 => {
                    print_esc_cstr(b"ifeof\x00" as *const u8 as *const i8);
                }
                14 => {
                    print_esc_cstr(b"iftrue\x00" as *const u8 as *const i8);
                }
                15 => {
                    print_esc_cstr(b"iffalse\x00" as *const u8 as *const i8);
                }
                16 => {
                    print_esc_cstr(b"ifcase\x00" as *const u8 as *const i8);
                }
                21 => {
                    print_esc_cstr(b"ifprimitive\x00" as *const u8 as *const i8);
                }
                17 => {
                    print_esc_cstr(b"ifdefined\x00" as *const u8 as *const i8);
                }
                18 => {
                    print_esc_cstr(b"ifcsname\x00" as *const u8 as *const i8);
                }
                19 => {
                    print_esc_cstr(b"iffontchar\x00" as *const u8 as *const i8);
                }
                20 => {
                    print_esc_cstr(b"ifincsname\x00" as *const u8 as *const i8);
                }
                _ => {
                    print_esc_cstr(b"if\x00" as *const u8 as *const i8);
                }
            }
        }
        108 => {
            if chr_code == 2i32 {
                print_esc_cstr(b"fi\x00" as *const u8 as *const i8);
            } else if chr_code == 4i32 {
                print_esc_cstr(b"or\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"else\x00" as *const u8 as *const i8);
            }
        }
        4 => {
            if chr_code == 0x10ffffi32 + 2i32 {
                print_esc_cstr(b"span\x00" as *const u8 as *const i8);
            } else {
                print_cstr(b"alignment tab character \x00" as *const u8 as *const i8);
                if (chr_code as i64) < 65536 {
                    print(chr_code);
                } else {
                    print_char(chr_code);
                }
            }
        }
        5 => {
            if chr_code == 0x10ffffi32 + 3i32 {
                print_esc_cstr(b"cr\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"crcr\x00" as *const u8 as *const i8);
            }
        }
        82 => {
            match chr_code {
                0 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pagegoal\x00" as *const u8 as *const i8);
                }
                1 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pagetotal\x00" as *const u8 as *const i8);
                }
                2 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pagestretch\x00" as *const u8 as *const i8);
                }
                3 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pagefilstretch\x00" as *const u8 as *const i8);
                }
                4 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pagefillstretch\x00" as *const u8 as *const i8);
                }
                5 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pagefilllstretch\x00" as *const u8 as *const i8);
                }
                6 => {
                    /* genuine literal in WEB */
                    print_esc_cstr(b"pageshrink\x00" as *const u8 as *const i8);
                }
                _ => {
                    print_esc_cstr(b"pagedepth\x00" as *const u8 as *const i8);
                }
            }
        }
        14 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"dump\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"end\x00" as *const u8 as *const i8);
            }
        }
        26 => match chr_code {
            4 => {
                print_esc_cstr(b"hskip\x00" as *const u8 as *const i8);
            }
            0 => {
                print_esc_cstr(b"hfil\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"hfill\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"hss\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"hfilneg\x00" as *const u8 as *const i8);
            }
        },
        27 => match chr_code {
            4 => {
                print_esc_cstr(b"vskip\x00" as *const u8 as *const i8);
            }
            0 => {
                print_esc_cstr(b"vfil\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"vfill\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"vss\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"vfilneg\x00" as *const u8 as *const i8);
            }
        },
        28 => {
            print_esc_cstr(b"mskip\x00" as *const u8 as *const i8);
        }
        29 => {
            print_esc_cstr(b"kern\x00" as *const u8 as *const i8);
        }
        30 => {
            print_esc_cstr(b"mkern\x00" as *const u8 as *const i8);
        }
        21 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"moveleft\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"moveright\x00" as *const u8 as *const i8);
            }
        }
        22 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"raise\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"lower\x00" as *const u8 as *const i8);
            }
        }
        20 => match chr_code {
            0 => {
                print_esc_cstr(b"box\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"copy\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"lastbox\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"vsplit\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"vtop\x00" as *const u8 as *const i8);
            }
            5 => {
                print_esc_cstr(b"vbox\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"hbox\x00" as *const u8 as *const i8);
            }
        },
        31 => {
            if chr_code == 100i32 {
                print_esc_cstr(b"leaders\x00" as *const u8 as *const i8);
            } else if chr_code == 101i32 {
                print_esc_cstr(b"cleaders\x00" as *const u8 as *const i8);
            } else if chr_code == 102i32 {
                print_esc_cstr(b"xleaders\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"shipout\x00" as *const u8 as *const i8);
            }
        }
        43 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"noindent\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"indent\x00" as *const u8 as *const i8);
            }
        }
        25 => {
            if chr_code == 10i32 {
                print_esc_cstr(b"unskip\x00" as *const u8 as *const i8);
            } else if chr_code == 11i32 {
                print_esc_cstr(b"unkern\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"unpenalty\x00" as *const u8 as *const i8);
            }
        }
        23 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"unhcopy\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"unhbox\x00" as *const u8 as *const i8);
            }
        }
        24 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"unvcopy\x00" as *const u8 as *const i8);
            } else if chr_code == 2i32 {
                print_esc_cstr(b"pagediscards\x00" as *const u8 as *const i8);
            } else if chr_code == 3i32 {
                print_esc_cstr(b"splitdiscards\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"unvbox\x00" as *const u8 as *const i8);
            }
        }
        47 => {
            if chr_code == 1i32 {
                print_esc('-' as i32);
            } else {
                print_esc_cstr(b"discretionary\x00" as *const u8 as *const i8);
            }
        }
        48 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"leqno\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"eqno\x00" as *const u8 as *const i8);
            }
        }
        50 => match chr_code {
            16 => {
                print_esc_cstr(b"mathord\x00" as *const u8 as *const i8);
            }
            17 => {
                print_esc_cstr(b"mathop\x00" as *const u8 as *const i8);
            }
            18 => {
                print_esc_cstr(b"mathbin\x00" as *const u8 as *const i8);
            }
            19 => {
                print_esc_cstr(b"mathrel\x00" as *const u8 as *const i8);
            }
            20 => {
                print_esc_cstr(b"mathopen\x00" as *const u8 as *const i8);
            }
            21 => {
                print_esc_cstr(b"mathclose\x00" as *const u8 as *const i8);
            }
            22 => {
                print_esc_cstr(b"mathpunct\x00" as *const u8 as *const i8);
            }
            23 => {
                print_esc_cstr(b"mathinner\x00" as *const u8 as *const i8);
            }
            26 => {
                print_esc_cstr(b"underline\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"overline\x00" as *const u8 as *const i8);
            }
        },
        51 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"limits\x00" as *const u8 as *const i8);
            } else if chr_code == 2i32 {
                print_esc_cstr(b"nolimits\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"displaylimits\x00" as *const u8 as *const i8);
            }
        }
        53 => {
            print_style(chr_code);
        }
        52 => match chr_code {
            1 => {
                print_esc_cstr(b"over\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"atop\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"abovewithdelims\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"overwithdelims\x00" as *const u8 as *const i8);
            }
            5 => {
                print_esc_cstr(b"atopwithdelims\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"above\x00" as *const u8 as *const i8);
            }
        },
        49 => {
            if chr_code == 30i32 {
                print_esc_cstr(b"left\x00" as *const u8 as *const i8);
            } else if chr_code == 1i32 {
                print_esc_cstr(b"middle\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"right\x00" as *const u8 as *const i8);
            }
        }
        95 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"long\x00" as *const u8 as *const i8);
            } else if chr_code == 2i32 {
                print_esc_cstr(b"outer\x00" as *const u8 as *const i8);
            } else if chr_code == 8i32 {
                print_esc_cstr(b"protected\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"global\x00" as *const u8 as *const i8);
            }
        }
        99 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"def\x00" as *const u8 as *const i8);
            } else if chr_code == 1i32 {
                print_esc_cstr(b"gdef\x00" as *const u8 as *const i8);
            } else if chr_code == 2i32 {
                print_esc_cstr(b"edef\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"xdef\x00" as *const u8 as *const i8);
            }
        }
        96 => {
            if chr_code != 0i32 {
                print_esc_cstr(b"futurelet\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"let\x00" as *const u8 as *const i8);
            }
        }
        97 => match chr_code {
            0 => {
                print_esc_cstr(b"chardef\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"mathchardef\x00" as *const u8 as *const i8);
            }
            9 => {
                print_esc_cstr(b"Umathchardef\x00" as *const u8 as *const i8);
            }
            8 => {
                print_esc_cstr(b"Umathcharnumdef\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"countdef\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"dimendef\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"skipdef\x00" as *const u8 as *const i8);
            }
            5 => {
                print_esc_cstr(b"muskipdef\x00" as *const u8 as *const i8);
            }
            7 => {
                print_esc_cstr(b"charsubdef\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"toksdef\x00" as *const u8 as *const i8);
            }
        },
        68 => {
            print_esc_cstr(b"char\x00" as *const u8 as *const i8);
            print_hex(chr_code);
        }
        69 => {
            print_esc_cstr(b"mathchar\x00" as *const u8 as *const i8);
            print_hex(chr_code);
        }
        70 => {
            print_esc_cstr(b"Umathchar\x00" as *const u8 as *const i8);
            print_hex((chr_code as u32 >> 21i32 & 0x7_u32) as i32);
            print_hex((chr_code as u32 >> 24i32 & 0xff_u32) as i32);
            print_hex((chr_code as u32 & 0x1fffff_u32) as i32);
        }
        86 => {
            if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
            {
                print_esc_cstr(b"catcode\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"mathcode\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"lccode\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"uccode\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"sfcode\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"delcode\x00" as *const u8 as *const i8);
            }
        }
        87 => {
            if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"XeTeXcharclass\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"Umathcodenum\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
            {
                print_esc_cstr(b"Umathcode\x00" as *const u8 as *const i8);
            } else if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 85i32
                    + 256i32
            {
                print_esc_cstr(b"Udelcodenum\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"Udelcode\x00" as *const u8 as *const i8);
            }
        }
        88 => {
            print_size(
                chr_code
                    - (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32),
            );
        }
        101 => {
            if chr_code == 1i32 {
                print_esc_cstr(b"patterns\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"hyphenation\x00" as *const u8 as *const i8);
            }
        }
        79 => match chr_code {
            0 => {
                print_esc_cstr(b"hyphenchar\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"skewchar\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"lpcode\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"rpcode\x00" as *const u8 as *const i8);
            }
            _ => {}
        },
        89 => {
            print_cstr(b"select font \x00" as *const u8 as *const i8);
            font_name_str = *font_name.offset(chr_code as isize);
            if font_area[chr_code as u8 as usize] as u32 == 0xffffu32
                || font_area[chr_code as u8 as usize] as u32 == 0xfffeu32
            {
                let mut for_end: i32 = length(font_name_str) - 1i32;
                quote_char = '\"' as i32 as UTF16_code;
                n = 0i32;
                while n <= for_end {
                    if *str_pool.offset(
                        (*str_start.offset((font_name_str as i64 - 65536) as isize) + n) as isize,
                    ) as i32
                        == '\"' as i32
                    {
                        quote_char = '\'' as i32 as UTF16_code
                    }
                    n += 1
                }
                print_char(quote_char as i32);
                print(font_name_str);
                print_char(quote_char as i32);
            } else {
                print(font_name_str);
            }
            if *font_size.offset(chr_code as isize) != *font_dsize.offset(chr_code as isize) {
                print_cstr(b" at \x00" as *const u8 as *const i8);
                print_scaled(*font_size.offset(chr_code as isize));
                print_cstr(b"pt\x00" as *const u8 as *const i8);
            }
        }
        102 => match chr_code {
            0 => {
                print_esc_cstr(b"batchmode\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"nonstopmode\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"scrollmode\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"errorstopmode\x00" as *const u8 as *const i8);
            }
        },
        60 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"closein\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"openin\x00" as *const u8 as *const i8);
            }
        }
        58 => {
            if chr_code == 0i32 {
                print_esc_cstr(b"message\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"errmessage\x00" as *const u8 as *const i8);
            }
        }
        57 => {
            if chr_code
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
            {
                print_esc_cstr(b"lowercase\x00" as *const u8 as *const i8);
            } else {
                print_esc_cstr(b"uppercase\x00" as *const u8 as *const i8);
            }
        }
        19 => match chr_code {
            1 => {
                print_esc_cstr(b"showbox\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"showthe\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"showlists\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"showgroups\x00" as *const u8 as *const i8);
            }
            5 => {
                print_esc_cstr(b"showtokens\x00" as *const u8 as *const i8);
            }
            6 => {
                print_esc_cstr(b"showifs\x00" as *const u8 as *const i8);
            }
            _ => {
                print_esc_cstr(b"show\x00" as *const u8 as *const i8);
            }
        },
        103 => {
            print_cstr(b"undefined\x00" as *const u8 as *const i8);
        }
        113 | 114 | 115 | 116 => {
            n = cmd as i32 - 113i32;
            if (*mem.offset((*mem.offset(chr_code as isize)).b32.s1 as isize))
                .b32
                .s0
                == 0x1c00000i32 + 1i32
            {
                n = n + 4i32
            }
            if n / 4i32 & 1i32 != 0 {
                print_esc_cstr(b"protected\x00" as *const u8 as *const i8);
            }
            if n & 1i32 != 0 {
                print_esc_cstr(b"long\x00" as *const u8 as *const i8);
            }
            if n / 2i32 & 1i32 != 0 {
                print_esc_cstr(b"outer\x00" as *const u8 as *const i8);
            }
            if n > 0i32 {
                print_char(' ' as i32);
            }
            print_cstr(b"macro\x00" as *const u8 as *const i8);
        }
        117 => {
            print_esc_cstr(b"outer endtemplate\x00" as *const u8 as *const i8);
        }
        59 => match chr_code {
            0 => {
                print_esc_cstr(b"openout\x00" as *const u8 as *const i8);
            }
            1 => {
                print_esc_cstr(b"write\x00" as *const u8 as *const i8);
            }
            2 => {
                print_esc_cstr(b"closeout\x00" as *const u8 as *const i8);
            }
            3 => {
                print_esc_cstr(b"special\x00" as *const u8 as *const i8);
            }
            4 => {
                print_esc_cstr(b"immediate\x00" as *const u8 as *const i8);
            }
            5 => {
                print_esc_cstr(b"setlanguage\x00" as *const u8 as *const i8);
            }
            41 => {
                print_esc_cstr(b"XeTeXpicfile\x00" as *const u8 as *const i8);
            }
            42 => {
                print_esc_cstr(b"XeTeXpdffile\x00" as *const u8 as *const i8);
            }
            43 => {
                print_esc_cstr(b"XeTeXglyph\x00" as *const u8 as *const i8);
            }
            46 => {
                print_esc_cstr(b"XeTeXlinebreaklocale\x00" as *const u8 as *const i8);
            }
            44 => {
                print_esc_cstr(b"XeTeXinputencoding\x00" as *const u8 as *const i8);
            }
            45 => {
                print_esc_cstr(b"XeTeXdefaultencoding\x00" as *const u8 as *const i8);
            }
            6 => {
                print_esc_cstr(b"pdfsavepos\x00" as *const u8 as *const i8);
            }
            _ => {
                print_cstr(b"[unknown extension!]\x00" as *const u8 as *const i8);
            }
        },
        _ => {
            print_cstr(b"[unknown command code!]\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn not_aat_font_error(mut cmd: i32, mut c: i32, mut f: i32) {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Cannot use \x00" as *const u8 as *const i8);
    print_cmd_chr(cmd as u16, c);
    print_cstr(b" with \x00" as *const u8 as *const i8);
    print(*font_name.offset(f as isize));
    print_cstr(b"; not an AAT font\x00" as *const u8 as *const i8);
    error();
}
#[no_mangle]
pub unsafe extern "C" fn not_aat_gr_font_error(mut cmd: i32, mut c: i32, mut f: i32) {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Cannot use \x00" as *const u8 as *const i8);
    print_cmd_chr(cmd as u16, c);
    print_cstr(b" with \x00" as *const u8 as *const i8);
    print(*font_name.offset(f as isize));
    print_cstr(b"; not an AAT or Graphite font\x00" as *const u8 as *const i8);
    error();
}
#[no_mangle]
pub unsafe extern "C" fn not_ot_font_error(mut cmd: i32, mut c: i32, mut f: i32) {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Cannot use \x00" as *const u8 as *const i8);
    print_cmd_chr(cmd as u16, c);
    print_cstr(b" with \x00" as *const u8 as *const i8);
    print(*font_name.offset(f as isize));
    print_cstr(b"; not an OpenType Layout font\x00" as *const u8 as *const i8);
    error();
}
#[no_mangle]
pub unsafe extern "C" fn not_native_font_error(mut cmd: i32, mut c: i32, mut f: i32) {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Cannot use \x00" as *const u8 as *const i8);
    print_cmd_chr(cmd as u16, c);
    print_cstr(b" with \x00" as *const u8 as *const i8);
    print(*font_name.offset(f as isize));
    print_cstr(b"; not a native platform font\x00" as *const u8 as *const i8);
    error();
}
/*:1434*/
#[no_mangle]
pub unsafe extern "C" fn id_lookup(mut j: i32, mut l: i32) -> i32 {
    let mut h: i32 = 0; /*269:*/
    let mut d: i32 = 0;
    let mut p: i32 = 0;
    let mut k: i32 = 0;
    let mut ll: i32 = 0;
    h = 0i32;
    k = j;
    while k <= j + l - 1i32 {
        h = h + h + *buffer.offset(k as isize);
        while h >= 8501i32 {
            h = h - 8501i32
        }
        k += 1
    }
    p = h + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32);
    ll = l;
    d = 0i32;
    while d <= l - 1i32 {
        if *buffer.offset((j + d) as isize) as i64 >= 65536 {
            ll += 1
        }
        d += 1
    }
    loop {
        if (*hash.offset(p as isize)).s1 > 0i32 {
            if length((*hash.offset(p as isize)).s1) == ll {
                if str_eq_buf((*hash.offset(p as isize)).s1, j) {
                    break;
                }
            }
        }
        if (*hash.offset(p as isize)).s0 == 0i32 {
            if no_new_control_sequence {
                p = 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
            } else {
                if (*hash.offset(p as isize)).s1 > 0i32 {
                    if hash_high < hash_extra {
                        hash_high += 1;
                        (*hash.offset(p as isize)).s0 = hash_high
                            + (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 85i32
                                + 256i32
                                + (0x10ffffi32 + 1i32)
                                + 23i32
                                + 256i32
                                - 1i32);
                        p = hash_high
                            + (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 85i32
                                + 256i32
                                + (0x10ffffi32 + 1i32)
                                + 23i32
                                + 256i32
                                - 1i32)
                    } else {
                        loop {
                            if hash_used
                                == 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32
                            {
                                overflow(
                                    b"hash size\x00" as *const u8 as *const i8,
                                    15000i32 + hash_extra,
                                );
                            }
                            hash_used -= 1;
                            if !((*hash.offset(hash_used as isize)).s1 != 0i32) {
                                break;
                            }
                        }
                        (*hash.offset(p as isize)).s0 = hash_used;
                        p = hash_used
                    }
                }
                if pool_ptr + ll > pool_size {
                    overflow(
                        b"pool size\x00" as *const u8 as *const i8,
                        pool_size - init_pool_ptr,
                    );
                }
                d = cur_length();
                while pool_ptr > *str_start.offset((str_ptr - 65536i32) as isize) {
                    pool_ptr -= 1;
                    *str_pool.offset((pool_ptr + l) as isize) = *str_pool.offset(pool_ptr as isize)
                }
                k = j;
                while k <= j + l - 1i32 {
                    if (*buffer.offset(k as isize) as i64) < 65536 {
                        *str_pool.offset(pool_ptr as isize) =
                            *buffer.offset(k as isize) as packed_UTF16_code;
                        pool_ptr += 1
                    } else {
                        *str_pool.offset(pool_ptr as isize) = (0xd800i32 as i64
                            + (*buffer.offset(k as isize) as i64 - 65536) / 1024i32 as i64)
                            as packed_UTF16_code;
                        pool_ptr += 1;
                        *str_pool.offset(pool_ptr as isize) = (0xdc00i32 as i64
                            + (*buffer.offset(k as isize) as i64 - 65536) % 1024i32 as i64)
                            as packed_UTF16_code;
                        pool_ptr += 1
                    }
                    k += 1
                }
                (*hash.offset(p as isize)).s1 = make_string();
                pool_ptr += d
            }
            break;
        } else {
            p = (*hash.offset(p as isize)).s0
        }
    }
    p
}
#[no_mangle]
pub unsafe extern "C" fn prim_lookup(mut s: str_number) -> i32 {
    let mut current_block: u64;
    let mut h: i32 = 0;
    let mut p: i32 = 0;
    let mut k: i32 = 0;
    let mut j: i32 = 0;
    let mut l: i32 = 0i32;
    if s <= 0xffffi32 {
        if s < 0i32 {
            p = 0i32;
            current_block = 12583739755984661121;
        } else {
            p = s % 431i32 + 1i32;
            current_block = 11307063007268554308;
        }
    } else {
        j = *str_start.offset((s as i64 - 65536) as isize);
        if s == str_ptr {
            l = cur_length()
        } else {
            l = length(s)
        }
        h = *str_pool.offset(j as isize) as i32;
        let mut for_end: i32 = 0;
        k = j + 1i32;
        for_end = j + l - 1i32;
        if k <= for_end {
            loop {
                h = h + h + *str_pool.offset(k as isize) as i32;
                while h >= 431i32 {
                    h = h - 431i32
                }
                let fresh14 = k;
                k = k + 1;
                if !(fresh14 < for_end) {
                    break;
                }
            }
        }
        p = h + 1i32;
        current_block = 11307063007268554308;
    }
    loop {
        match current_block {
            12583739755984661121 => return p,
            _ => {
                if prim[p as usize].s1 as i64 > 65536 {
                    if length(prim[p as usize].s1) - 1i32 == l {
                        if str_eq_str(prim[p as usize].s1 - 1i32, s) {
                            current_block = 12583739755984661121;
                            continue;
                        }
                    }
                } else if prim[p as usize].s1 == 1i32 + s {
                    current_block = 12583739755984661121;
                    continue;
                }
                if prim[p as usize].s0 == 0i32 {
                    if no_new_control_sequence {
                        p = 0i32
                    } else {
                        /*272:*/
                        if prim[p as usize].s1 > 0i32 {
                            loop {
                                if prim_used == 1i32 {
                                    overflow(
                                        b"primitive size\x00" as *const u8 as *const i8,
                                        500i32,
                                    );
                                }
                                prim_used -= 1;
                                if prim[prim_used as usize].s1 == 0i32 {
                                    break;
                                }
                            }
                            prim[p as usize].s0 = prim_used;
                            p = prim_used
                        }
                        prim[p as usize].s1 = s + 1i32
                    }
                    current_block = 12583739755984661121;
                } else {
                    p = prim[p as usize].s0;
                    current_block = 11307063007268554308;
                }
            }
        }
    }
}
/*:276*/
/*280: *//*296: */
#[no_mangle]
pub unsafe extern "C" fn print_group(mut e: bool) {
    match cur_group as i32 {
        0 => {
            print_cstr(b"bottom level\x00" as *const u8 as *const i8);
            return;
        }
        1 | 14 => {
            if cur_group as i32 == 14i32 {
                print_cstr(b"semi \x00" as *const u8 as *const i8);
            }
            print_cstr(b"simple\x00" as *const u8 as *const i8);
        }
        2 | 3 => {
            if cur_group as i32 == 3i32 {
                print_cstr(b"adjusted \x00" as *const u8 as *const i8);
            }
            print_cstr(b"hbox\x00" as *const u8 as *const i8);
        }
        4 => {
            print_cstr(b"vbox\x00" as *const u8 as *const i8);
        }
        5 => {
            print_cstr(b"vtop\x00" as *const u8 as *const i8);
        }
        6 | 7 => {
            if cur_group as i32 == 7i32 {
                print_cstr(b"no \x00" as *const u8 as *const i8);
            }
            print_cstr(b"align\x00" as *const u8 as *const i8);
        }
        8 => {
            print_cstr(b"output\x00" as *const u8 as *const i8);
        }
        10 => {
            print_cstr(b"disc\x00" as *const u8 as *const i8);
        }
        11 => {
            print_cstr(b"insert\x00" as *const u8 as *const i8);
        }
        12 => {
            print_cstr(b"vcenter\x00" as *const u8 as *const i8);
        }
        9 | 13 | 15 | 16 => {
            print_cstr(b"math\x00" as *const u8 as *const i8);
            if cur_group as i32 == 13i32 {
                print_cstr(b" choice\x00" as *const u8 as *const i8);
            } else if cur_group as i32 == 15i32 {
                print_cstr(b" shift\x00" as *const u8 as *const i8);
            } else if cur_group as i32 == 16i32 {
                print_cstr(b" left\x00" as *const u8 as *const i8);
            }
        }
        _ => {}
    }
    print_cstr(b" group (level \x00" as *const u8 as *const i8);
    print_int(cur_level as i32);
    print_char(')' as i32);
    if (*save_stack.offset((save_ptr - 1i32) as isize)).b32.s1 != 0i32 {
        if e {
            print_cstr(b" entered at line \x00" as *const u8 as *const i8);
        } else {
            print_cstr(b" at line \x00" as *const u8 as *const i8);
        }
        print_int((*save_stack.offset((save_ptr - 1i32) as isize)).b32.s1);
    };
}
/*:1448*/
/*1449: */
#[no_mangle]
pub unsafe extern "C" fn pseudo_input() -> bool {
    let mut p: i32 = 0;
    let mut sz: i32 = 0;
    let mut w: b16x4 = b16x4 {
        s0: 0,
        s1: 0,
        s2: 0,
        s3: 0,
    };
    let mut r: i32 = 0;
    last = first;
    p = (*mem.offset(pseudo_files as isize)).b32.s0;
    if p == -0xfffffffi32 {
        false
    } else {
        (*mem.offset(pseudo_files as isize)).b32.s0 = (*mem.offset(p as isize)).b32.s1;
        sz = (*mem.offset(p as isize)).b32.s0;
        if 4i32 * sz - 3i32 >= buf_size - last {
            /*35: */
            cur_input.loc = first;
            cur_input.limit = last - 1i32;
            overflow(b"buffer size\x00" as *const u8 as *const i8, buf_size);
        }
        last = first;
        let mut for_end: i32 = 0;
        r = p + 1i32;
        for_end = p + sz - 1i32;
        if r <= for_end {
            loop {
                w = (*mem.offset(r as isize)).b16;
                *buffer.offset(last as isize) = w.s3 as UnicodeScalar;
                *buffer.offset((last + 1i32) as isize) = w.s2 as UnicodeScalar;
                *buffer.offset((last + 2i32) as isize) = w.s1 as UnicodeScalar;
                *buffer.offset((last + 3i32) as isize) = w.s0 as UnicodeScalar;
                last = last + 4i32;
                let fresh15 = r;
                r = r + 1;
                if !(fresh15 < for_end) {
                    break;
                }
            }
        }
        if last >= max_buf_stack {
            max_buf_stack = last + 1i32
        }
        while last > first && *buffer.offset((last - 1i32) as isize) == ' ' as i32 {
            last -= 1
        }
        free_node(p, sz);
        true
    }
}
#[no_mangle]
pub unsafe extern "C" fn pseudo_close() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    p = (*mem.offset(pseudo_files as isize)).b32.s1;
    q = (*mem.offset(pseudo_files as isize)).b32.s0;
    (*mem.offset(pseudo_files as isize)).b32.s1 = avail;
    avail = pseudo_files;
    pseudo_files = p;
    while q != -0xfffffffi32 {
        p = q;
        q = (*mem.offset(p as isize)).b32.s1;
        free_node(p, (*mem.offset(p as isize)).b32.s0);
    }
}
#[no_mangle]
pub unsafe extern "C" fn group_warning() {
    let mut i: i32 = 0;
    let mut w: bool = false;
    base_ptr = input_ptr;
    *input_stack.offset(base_ptr as isize) = cur_input;
    i = in_open;
    w = false;
    while *grp_stack.offset(i as isize) == cur_boundary && i > 0i32 {
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 62i32) as isize,
        ))
        .b32
        .s1 > 0i32
        {
            while (*input_stack.offset(base_ptr as isize)).state as i32 == 0i32
                || (*input_stack.offset(base_ptr as isize)).index as i32 > i
            {
                base_ptr -= 1
            }
            if (*input_stack.offset(base_ptr as isize)).name > 17i32 {
                w = true
            }
        }
        *grp_stack.offset(i as isize) = (*save_stack.offset(save_ptr as isize)).b32.s1;
        i -= 1
    }
    if w {
        print_nl_cstr(b"Warning: end of \x00" as *const u8 as *const i8);
        print_group(1i32 != 0);
        print_cstr(b" of a different file\x00" as *const u8 as *const i8);
        print_ln();
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 62i32) as isize,
        ))
        .b32
        .s1 > 1i32
        {
            show_context();
        }
        if history == TTHistory::SPOTLESS {
            history = TTHistory::WARNING_ISSUED
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn if_warning() {
    let mut i: i32 = 0;
    let mut w: bool = false;
    base_ptr = input_ptr;
    *input_stack.offset(base_ptr as isize) = cur_input;
    i = in_open;
    w = false;
    while *if_stack.offset(i as isize) == cond_ptr {
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 62i32) as isize,
        ))
        .b32
        .s1 > 0i32
        {
            while (*input_stack.offset(base_ptr as isize)).state as i32 == 0i32
                || (*input_stack.offset(base_ptr as isize)).index as i32 > i
            {
                base_ptr -= 1
            }
            if (*input_stack.offset(base_ptr as isize)).name > 17i32 {
                w = true
            }
        }
        *if_stack.offset(i as isize) = (*mem.offset(cond_ptr as isize)).b32.s1;
        i -= 1
    }
    if w {
        print_nl_cstr(b"Warning: end of \x00" as *const u8 as *const i8);
        print_cmd_chr(107_u16, cur_if as i32);
        if if_line != 0i32 {
            print_cstr(b" entered on line \x00" as *const u8 as *const i8);
            print_int(if_line);
        }
        print_cstr(b" of a different file\x00" as *const u8 as *const i8);
        print_ln();
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 62i32) as isize,
        ))
        .b32
        .s1 > 1i32
        {
            show_context();
        }
        if history == TTHistory::SPOTLESS {
            history = TTHistory::WARNING_ISSUED
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn file_warning() {
    let mut p: i32 = 0;
    let mut l: u16 = 0;
    let mut c: u16 = 0;
    let mut i: i32 = 0;
    p = save_ptr;
    l = cur_level;
    c = cur_group as u16;
    save_ptr = cur_boundary;
    while *grp_stack.offset(in_open as isize) != save_ptr {
        cur_level = cur_level.wrapping_sub(1);
        print_nl_cstr(b"Warning: end of file when \x00" as *const u8 as *const i8);
        print_group(1i32 != 0);
        print_cstr(b" is incomplete\x00" as *const u8 as *const i8);
        cur_group = (*save_stack.offset(save_ptr as isize)).b16.s0 as group_code;
        save_ptr = (*save_stack.offset(save_ptr as isize)).b32.s1
    }
    save_ptr = p;
    cur_level = l;
    cur_group = c as group_code;
    p = cond_ptr;
    l = if_limit as u16;
    c = cur_if as u16;
    i = if_line;
    while *if_stack.offset(in_open as isize) != cond_ptr {
        print_nl_cstr(b"Warning: end of file when \x00" as *const u8 as *const i8);
        print_cmd_chr(107_u16, cur_if as i32);
        if if_limit as i32 == 2i32 {
            print_esc_cstr(b"else\x00" as *const u8 as *const i8);
        }
        if if_line != 0i32 {
            print_cstr(b" entered on line \x00" as *const u8 as *const i8);
            print_int(if_line);
        }
        print_cstr(b" is incomplete\x00" as *const u8 as *const i8);
        if_line = (*mem.offset((cond_ptr + 1i32) as isize)).b32.s1;
        cur_if = (*mem.offset(cond_ptr as isize)).b16.s0 as small_number;
        if_limit = (*mem.offset(cond_ptr as isize)).b16.s1 as u8;
        cond_ptr = (*mem.offset(cond_ptr as isize)).b32.s1
    }
    cond_ptr = p;
    if_limit = l as u8;
    cur_if = c as small_number;
    if_line = i;
    print_ln();
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 62i32) as isize,
    ))
    .b32
    .s1 > 1i32
    {
        show_context();
    }
    if history == TTHistory::SPOTLESS {
        history = TTHistory::WARNING_ISSUED
    };
}
#[no_mangle]
pub unsafe extern "C" fn delete_sa_ref(mut q: i32) {
    let mut p: i32 = 0;
    let mut i: small_number = 0;
    let mut s: small_number = 0;
    let ref mut fresh16 = (*mem.offset((q + 1i32) as isize)).b32.s0;
    *fresh16 -= 1;
    if (*mem.offset((q + 1i32) as isize)).b32.s0 != -0xfffffffi32 {
        return;
    }
    if ((*mem.offset(q as isize)).b16.s1 as i32) < 128i32 {
        if (*mem.offset((q + 2i32) as isize)).b32.s1 == 0i32 {
            s = 3i32 as small_number
        } else {
            return;
        }
    } else {
        if ((*mem.offset(q as isize)).b16.s1 as i32) < 256i32 {
            if (*mem.offset((q + 1i32) as isize)).b32.s1 == 0i32 {
                delete_glue_ref(0i32);
            } else {
                return;
            }
        } else if (*mem.offset((q + 1i32) as isize)).b32.s1 != -0xfffffffi32 {
            return;
        }
        s = 2i32 as small_number
    }
    loop {
        i = ((*mem.offset(q as isize)).b16.s1 as i32 % 64i32) as small_number;
        p = q;
        q = (*mem.offset(p as isize)).b32.s1;
        free_node(p, s as i32);
        if q == -0xfffffffi32 {
            sa_root[i as usize] = -0xfffffffi32;
            return;
        }
        if i as i32 & 1i32 != 0 {
            (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 = -0xfffffffi32
        } else {
            (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 = -0xfffffffi32
        }
        let ref mut fresh17 = (*mem.offset(q as isize)).b16.s0;
        *fresh17 = (*fresh17).wrapping_sub(1);
        s = 33i32 as small_number;
        if (*mem.offset(q as isize)).b16.s0 as i32 > 0i32 {
            break;
        }
    }
}
/*:1609*/
/*1611: */
#[no_mangle]
pub unsafe extern "C" fn sa_save(mut p: i32) {
    let mut q: i32 = 0;
    let mut i: u16 = 0;
    if cur_level as i32 != sa_level as i32 {
        if save_ptr > max_save_stack {
            max_save_stack = save_ptr;
            if max_save_stack > save_size - 7i32 {
                overflow(b"save size\x00" as *const u8 as *const i8, save_size);
            }
        }
        (*save_stack.offset(save_ptr as isize)).b16.s1 = 4_u16;
        (*save_stack.offset(save_ptr as isize)).b16.s0 = sa_level;
        (*save_stack.offset(save_ptr as isize)).b32.s1 = sa_chain;
        save_ptr += 1;
        sa_chain = -0xfffffffi32;
        sa_level = cur_level
    }
    i = (*mem.offset(p as isize)).b16.s1;
    if (i as i32) < 128i32 {
        if (*mem.offset((p + 2i32) as isize)).b32.s1 == 0i32 {
            q = get_node(2i32);
            i = 384_u16
        } else {
            q = get_node(3i32);
            (*mem.offset((q + 2i32) as isize)).b32.s1 = (*mem.offset((p + 2i32) as isize)).b32.s1
        }
        (*mem.offset((q + 1i32) as isize)).b32.s1 = -0xfffffffi32
    } else {
        q = get_node(2i32);
        (*mem.offset((q + 1i32) as isize)).b32.s1 = (*mem.offset((p + 1i32) as isize)).b32.s1
    }
    (*mem.offset((q + 1i32) as isize)).b32.s0 = p;
    (*mem.offset(q as isize)).b16.s1 = i;
    (*mem.offset(q as isize)).b16.s0 = (*mem.offset(p as isize)).b16.s0;
    (*mem.offset(q as isize)).b32.s1 = sa_chain;
    sa_chain = q;
    let ref mut fresh18 = (*mem.offset((p + 1i32) as isize)).b32.s0;
    *fresh18 += 1;
}
#[no_mangle]
pub unsafe extern "C" fn sa_destroy(mut p: i32) {
    if ((*mem.offset(p as isize)).b16.s1 as i32) < 256i32 {
        delete_glue_ref((*mem.offset((p + 1i32) as isize)).b32.s1);
    } else if (*mem.offset((p + 1i32) as isize)).b32.s1 != -0xfffffffi32 {
        if ((*mem.offset(p as isize)).b16.s1 as i32) < 320i32 {
            flush_node_list((*mem.offset((p + 1i32) as isize)).b32.s1);
        } else {
            delete_token_ref((*mem.offset((p + 1i32) as isize)).b32.s1);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sa_def(mut p: i32, mut e: i32) {
    let ref mut fresh19 = (*mem.offset((p + 1i32) as isize)).b32.s0;
    *fresh19 += 1;
    if (*mem.offset((p + 1i32) as isize)).b32.s1 == e {
        sa_destroy(p);
    } else {
        if (*mem.offset(p as isize)).b16.s0 as i32 == cur_level as i32 {
            sa_destroy(p);
        } else {
            sa_save(p);
        }
        (*mem.offset(p as isize)).b16.s0 = cur_level;
        (*mem.offset((p + 1i32) as isize)).b32.s1 = e
    }
    delete_sa_ref(p);
}
#[no_mangle]
pub unsafe extern "C" fn sa_w_def(mut p: i32, mut w: i32) {
    let ref mut fresh20 = (*mem.offset((p + 1i32) as isize)).b32.s0;
    *fresh20 += 1;
    if !((*mem.offset((p + 2i32) as isize)).b32.s1 == w) {
        if (*mem.offset(p as isize)).b16.s0 as i32 != cur_level as i32 {
            sa_save(p);
        }
        (*mem.offset(p as isize)).b16.s0 = cur_level;
        (*mem.offset((p + 2i32) as isize)).b32.s1 = w
    }
    delete_sa_ref(p);
}
#[no_mangle]
pub unsafe extern "C" fn gsa_def(mut p: i32, mut e: i32) {
    let ref mut fresh21 = (*mem.offset((p + 1i32) as isize)).b32.s0;
    *fresh21 += 1;
    sa_destroy(p);
    (*mem.offset(p as isize)).b16.s0 = 1_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = e;
    delete_sa_ref(p);
}
#[no_mangle]
pub unsafe extern "C" fn gsa_w_def(mut p: i32, mut w: i32) {
    let ref mut fresh22 = (*mem.offset((p + 1i32) as isize)).b32.s0;
    *fresh22 += 1;
    (*mem.offset(p as isize)).b16.s0 = 1_u16;
    (*mem.offset((p + 2i32) as isize)).b32.s1 = w;
    delete_sa_ref(p);
}
#[no_mangle]
pub unsafe extern "C" fn sa_restore() {
    let mut p: i32 = 0;
    loop {
        p = (*mem.offset((sa_chain + 1i32) as isize)).b32.s0;
        if (*mem.offset(p as isize)).b16.s0 as i32 == 1i32 {
            if (*mem.offset(p as isize)).b16.s1 as i32 >= 128i32 {
                sa_destroy(sa_chain);
            }
        } else {
            if ((*mem.offset(p as isize)).b16.s1 as i32) < 128i32 {
                if ((*mem.offset(sa_chain as isize)).b16.s1 as i32) < 128i32 {
                    (*mem.offset((p + 2i32) as isize)).b32.s1 =
                        (*mem.offset((sa_chain + 2i32) as isize)).b32.s1
                } else {
                    (*mem.offset((p + 2i32) as isize)).b32.s1 = 0i32
                }
            } else {
                sa_destroy(p);
                (*mem.offset((p + 1i32) as isize)).b32.s1 =
                    (*mem.offset((sa_chain + 1i32) as isize)).b32.s1
            }
            (*mem.offset(p as isize)).b16.s0 = (*mem.offset(sa_chain as isize)).b16.s0
        }
        delete_sa_ref(p);
        p = sa_chain;
        sa_chain = (*mem.offset(p as isize)).b32.s1;
        if ((*mem.offset(p as isize)).b16.s1 as i32) < 128i32 {
            free_node(p, 3i32);
        } else {
            free_node(p, 2i32);
        }
        if sa_chain == -0xfffffffi32 {
            break;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn new_save_level(mut c: group_code) {
    if save_ptr > max_save_stack {
        max_save_stack = save_ptr;
        if max_save_stack > save_size - 7i32 {
            overflow(b"save size\x00" as *const u8 as *const i8, save_size);
        }
    }
    (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 = line;
    save_ptr += 1;
    (*save_stack.offset(save_ptr as isize)).b16.s1 = 3_u16;
    (*save_stack.offset(save_ptr as isize)).b16.s0 = cur_group as u16;
    (*save_stack.offset(save_ptr as isize)).b32.s1 = cur_boundary;
    if cur_level as i32 == 65535i32 {
        overflow(b"grouping levels\x00" as *const u8 as *const i8, 65535i32);
    }
    cur_boundary = save_ptr;
    cur_group = c;
    cur_level = cur_level.wrapping_add(1);
    save_ptr += 1;
}
#[no_mangle]
pub unsafe extern "C" fn eq_destroy(mut w: memory_word) {
    let mut q: i32 = 0;
    match w.b16.s1 as i32 {
        113 | 114 | 115 | 116 => {
            delete_token_ref(w.b32.s1);
        }
        119 => {
            delete_glue_ref(w.b32.s1);
        }
        120 => {
            q = w.b32.s1;
            if q != -0xfffffffi32 {
                free_node(
                    q,
                    (*mem.offset(q as isize)).b32.s0 + (*mem.offset(q as isize)).b32.s0 + 1i32,
                );
            }
        }
        121 => {
            flush_node_list(w.b32.s1);
        }
        72 | 91 => {
            if w.b32.s1 < 0i32 || w.b32.s1 > 19i32 {
                delete_sa_ref(w.b32.s1);
            }
        }
        _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn eq_save(mut p: i32, mut l: u16) {
    if save_ptr > max_save_stack {
        max_save_stack = save_ptr;
        if max_save_stack > save_size - 7i32 {
            overflow(b"save size\x00" as *const u8 as *const i8, save_size);
        }
    }
    if l as i32 == 0i32 {
        (*save_stack.offset(save_ptr as isize)).b16.s1 = 1_u16
    } else {
        *save_stack.offset(save_ptr as isize) = *eqtb.offset(p as isize);
        save_ptr += 1;
        (*save_stack.offset(save_ptr as isize)).b16.s1 = 0_u16
    }
    (*save_stack.offset(save_ptr as isize)).b16.s0 = l;
    (*save_stack.offset(save_ptr as isize)).b32.s1 = p;
    save_ptr += 1;
}
#[no_mangle]
pub unsafe extern "C" fn eq_define(mut p: i32, mut t: u16, mut e: i32) {
    if (*eqtb.offset(p as isize)).b16.s1 as i32 == t as i32
        && (*eqtb.offset(p as isize)).b32.s1 == e
    {
        eq_destroy(*eqtb.offset(p as isize));
        return;
    }
    if (*eqtb.offset(p as isize)).b16.s0 as i32 == cur_level as i32 {
        eq_destroy(*eqtb.offset(p as isize));
    } else if cur_level as i32 > 1i32 {
        eq_save(p, (*eqtb.offset(p as isize)).b16.s0);
    }
    (*eqtb.offset(p as isize)).b16.s0 = cur_level;
    (*eqtb.offset(p as isize)).b16.s1 = t;
    (*eqtb.offset(p as isize)).b32.s1 = e;
}
#[no_mangle]
pub unsafe extern "C" fn eq_word_define(mut p: i32, mut w: i32) {
    if (*eqtb.offset(p as isize)).b32.s1 == w {
        return;
    }
    if _xeq_level_array[(p
        - (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32))) as usize] as i32
        != cur_level as i32
    {
        eq_save(
            p,
            _xeq_level_array[(p
                - (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32))) as usize],
        );
        _xeq_level_array[(p
            - (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32))) as usize] = cur_level
    }
    (*eqtb.offset(p as isize)).b32.s1 = w;
}
#[no_mangle]
pub unsafe extern "C" fn geq_define(mut p: i32, mut t: u16, mut e: i32) {
    eq_destroy(*eqtb.offset(p as isize));
    (*eqtb.offset(p as isize)).b16.s0 = 1_u16;
    (*eqtb.offset(p as isize)).b16.s1 = t;
    (*eqtb.offset(p as isize)).b32.s1 = e;
}
#[no_mangle]
pub unsafe extern "C" fn geq_word_define(mut p: i32, mut w: i32) {
    (*eqtb.offset(p as isize)).b32.s1 = w;
    _xeq_level_array[(p
        - (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32))) as usize] = 1_u16;
}
#[no_mangle]
pub unsafe extern "C" fn save_for_after(mut t: i32) {
    if cur_level as i32 > 1i32 {
        if save_ptr > max_save_stack {
            max_save_stack = save_ptr;
            if max_save_stack > save_size - 7i32 {
                overflow(b"save size\x00" as *const u8 as *const i8, save_size);
            }
        }
        (*save_stack.offset(save_ptr as isize)).b16.s1 = 2_u16;
        (*save_stack.offset(save_ptr as isize)).b16.s0 = 0_u16;
        (*save_stack.offset(save_ptr as isize)).b32.s1 = t;
        save_ptr += 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn unsave() {
    let mut p: i32 = 0;
    let mut l: u16 = 0_u16;
    let mut t: i32 = 0;
    let mut a: bool = false;
    a = false;
    if cur_level as i32 > 1i32 {
        cur_level = cur_level.wrapping_sub(1);
        loop {
            save_ptr -= 1;
            if (*save_stack.offset(save_ptr as isize)).b16.s1 as i32 == 3i32 {
                break;
            }
            p = (*save_stack.offset(save_ptr as isize)).b32.s1;
            if (*save_stack.offset(save_ptr as isize)).b16.s1 as i32 == 2i32 {
                /*338: */
                t = cur_tok;
                cur_tok = p;
                if a {
                    p = get_avail();
                    (*mem.offset(p as isize)).b32.s0 = cur_tok;
                    (*mem.offset(p as isize)).b32.s1 = cur_input.loc;
                    cur_input.loc = p;
                    cur_input.start = p;
                    if cur_tok < 0x600000i32 {
                        if cur_tok < 0x400000i32 {
                            align_state -= 1
                        } else {
                            align_state += 1
                        }
                    }
                } else {
                    back_input();
                    a = true
                }
                cur_tok = t
            } else if (*save_stack.offset(save_ptr as isize)).b16.s1 as i32 == 4i32 {
                sa_restore();
                sa_chain = p;
                sa_level = (*save_stack.offset(save_ptr as isize)).b16.s0
            } else {
                if (*save_stack.offset(save_ptr as isize)).b16.s1 as i32 == 0i32 {
                    l = (*save_stack.offset(save_ptr as isize)).b16.s0;
                    save_ptr -= 1
                } else {
                    *save_stack.offset(save_ptr as isize) = *eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32) as isize,
                    )
                }
                if p < 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    || p > 1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 85i32
                        + 256i32
                        + (0x10ffffi32 + 1i32)
                        + 23i32
                        + 256i32
                        - 1i32
                {
                    if (*eqtb.offset(p as isize)).b16.s0 as i32 == 1i32 {
                        eq_destroy(*save_stack.offset(save_ptr as isize));
                    } else {
                        eq_destroy(*eqtb.offset(p as isize));
                        *eqtb.offset(p as isize) = *save_stack.offset(save_ptr as isize)
                    }
                } else if _xeq_level_array[(p
                    - (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)))
                    as usize] as i32
                    != 1i32
                {
                    *eqtb.offset(p as isize) = *save_stack.offset(save_ptr as isize);
                    _xeq_level_array[(p
                        - (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)))
                        as usize] = l
                }
            }
        }
        if *grp_stack.offset(in_open as isize) == cur_boundary {
            group_warning();
        }
        cur_group = (*save_stack.offset(save_ptr as isize)).b16.s0 as group_code;
        cur_boundary = (*save_stack.offset(save_ptr as isize)).b32.s1;
        save_ptr -= 1
    } else {
        confusion(b"curlevel\x00" as *const u8 as *const i8);
    };
}
#[no_mangle]
pub unsafe extern "C" fn prepare_mag() {
    if mag_set > 0i32
        && (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 17i32) as isize,
        ))
        .b32
        .s1 != mag_set
    {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Incompatible magnification (\x00" as *const u8 as *const i8);
        print_int(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 17i32) as isize,
            ))
            .b32
            .s1,
        );
        print_cstr(b");\x00" as *const u8 as *const i8);
        print_nl_cstr(b" the previous value will be retained\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"I can handle only one magnification ratio per job. So I\'ve\x00"
            as *const u8 as *const i8;
        help_line[0] = b"reverted to the magnification you used earlier on this run.\x00"
            as *const u8 as *const i8;
        int_error(mag_set);
        geq_word_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 17i32,
            mag_set,
        );
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 17i32) as isize,
    ))
    .b32
    .s1 <= 0i32
        || (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 17i32) as isize,
        ))
        .b32
        .s1 as i64
            > 32768
    {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Illegal magnification has been changed to 1000\x00" as *const u8 as *const i8);
        help_ptr = 1_u8;
        help_line[0] =
            b"The magnification ratio must be between 1 and 32768.\x00" as *const u8 as *const i8;
        int_error(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 17i32) as isize,
            ))
            .b32
            .s1,
        );
        geq_word_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 17i32,
            1000i32,
        );
    }
    mag_set = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 17i32) as isize,
    ))
    .b32
    .s1;
}
#[no_mangle]
pub unsafe extern "C" fn token_show(mut p: i32) {
    if p != -0xfffffffi32 {
        show_token_list(
            (*mem.offset(p as isize)).b32.s1,
            -0xfffffffi32,
            10000000i64 as i32,
        );
    };
}
#[no_mangle]
pub unsafe extern "C" fn print_meaning() {
    print_cmd_chr(cur_cmd as u16, cur_chr);
    if cur_cmd as i32 >= 113i32 {
        print_char(':' as i32);
        print_ln();
        token_show(cur_chr);
    } else if cur_cmd as i32 == 112i32 && cur_chr < 5i32 {
        print_char(':' as i32);
        print_ln();
        token_show(cur_mark[cur_chr as usize]);
    };
}
#[no_mangle]
pub unsafe extern "C" fn show_cur_cmd_chr() {
    let mut n: i32 = 0;
    let mut l: i32 = 0;
    let mut p: i32 = 0;
    begin_diagnostic();
    print_nl('{' as i32);
    if cur_list.mode as i32 != shown_mode as i32 {
        print_mode(cur_list.mode as i32);
        print_cstr(b": \x00" as *const u8 as *const i8);
        shown_mode = cur_list.mode
    }
    print_cmd_chr(cur_cmd as u16, cur_chr);
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 60i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        if cur_cmd as i32 >= 107i32 {
            if cur_cmd as i32 <= 108i32 {
                print_cstr(b": \x00" as *const u8 as *const i8);
                if cur_cmd as i32 == 108i32 {
                    print_cmd_chr(107_u16, cur_if as i32);
                    print_char(' ' as i32);
                    n = 0i32;
                    l = if_line
                } else {
                    n = 1i32;
                    l = line
                }
                p = cond_ptr;
                while p != -0xfffffffi32 {
                    n += 1;
                    p = (*mem.offset(p as isize)).b32.s1
                }
                print_cstr(b"(level \x00" as *const u8 as *const i8);
                print_int(n);
                print_char(')' as i32);
                if l != 0i32 {
                    print_cstr(b" entered on line \x00" as *const u8 as *const i8);
                    print_int(l);
                }
            }
        }
    }
    print_char('}' as i32);
    end_diagnostic(false);
}
#[no_mangle]
pub unsafe extern "C" fn show_context() {
    let mut nn: i32 = 0;
    let mut bottom_line: bool = false;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut l: i32 = 0;
    let mut m: i32 = 0;
    let mut n: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    base_ptr = input_ptr;
    *input_stack.offset(base_ptr as isize) = cur_input;
    nn = -1i32;
    bottom_line = false;
    loop {
        cur_input = *input_stack.offset(base_ptr as isize);
        if cur_input.state as i32 != 0i32 {
            if cur_input.name > 19i32 || base_ptr == 0i32 {
                bottom_line = true
            }
        }
        if base_ptr == input_ptr
            || bottom_line as i32 != 0
            || nn
                < (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 54i32) as isize,
                ))
                .b32
                .s1
        {
            /*324: */
            if base_ptr == input_ptr
                || cur_input.state as i32 != 0i32
                || cur_input.index as i32 != 3i32
                || cur_input.loc != -0xfffffffi32
            {
                tally = 0i32;
                let old_setting_0 = selector;
                if cur_input.state as i32 != 0i32 {
                    if cur_input.name <= 17i32 {
                        if cur_input.name == 0i32 {
                            if base_ptr == 0i32 {
                                print_nl_cstr(b"<*>\x00" as *const u8 as *const i8);
                            } else {
                                print_nl_cstr(b"<insert> \x00" as *const u8 as *const i8);
                            }
                        } else {
                            print_nl_cstr(b"<read \x00" as *const u8 as *const i8);
                            if cur_input.name == 17i32 {
                                print_char('*' as i32);
                            } else {
                                print_int(cur_input.name - 1i32);
                            }
                            print_char('>' as i32);
                        }
                    } else {
                        print_nl_cstr(b"l.\x00" as *const u8 as *const i8);
                        if cur_input.index as i32 == in_open {
                            print_int(line);
                        } else {
                            print_int(*line_stack.offset((cur_input.index as i32 + 1i32) as isize));
                        }
                    }
                    print_char(' ' as i32);
                    l = tally;
                    tally = 0i32;
                    selector = Selector::PSEUDO;
                    trick_count = 1000000i64 as i32;
                    if *buffer.offset(cur_input.limit as isize)
                        == (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 48i32) as isize,
                        ))
                        .b32
                        .s1
                    {
                        j = cur_input.limit
                    } else {
                        j = cur_input.limit + 1i32
                    }
                    if j > 0i32 {
                        let mut for_end: i32 = 0;
                        i = cur_input.start;
                        for_end = j - 1i32;
                        if i <= for_end {
                            loop {
                                if i == cur_input.loc {
                                    first_count = tally;
                                    trick_count = tally + 1i32 + error_line - half_error_line;
                                    if trick_count < error_line {
                                        trick_count = error_line
                                    }
                                }
                                print_char(*buffer.offset(i as isize));
                                let fresh23 = i;
                                i = i + 1;
                                if !(fresh23 < for_end) {
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    match cur_input.index as i32 {
                        0 => {
                            print_nl_cstr(b"<argument> \x00" as *const u8 as *const i8);
                        }
                        1 | 2 => {
                            print_nl_cstr(b"<template> \x00" as *const u8 as *const i8);
                        }
                        3 | 4 => {
                            if cur_input.loc == -0xfffffffi32 {
                                print_nl_cstr(b"<recently read> \x00" as *const u8 as *const i8);
                            } else {
                                print_nl_cstr(b"<to be read again> \x00" as *const u8 as *const i8);
                            }
                        }
                        5 => {
                            print_nl_cstr(b"<inserted text> \x00" as *const u8 as *const i8);
                        }
                        6 => {
                            print_ln();
                            print_cs(cur_input.name);
                        }
                        7 => {
                            print_nl_cstr(b"<output> \x00" as *const u8 as *const i8);
                        }
                        8 => {
                            print_nl_cstr(b"<everypar> \x00" as *const u8 as *const i8);
                        }
                        9 => {
                            print_nl_cstr(b"<everymath> \x00" as *const u8 as *const i8);
                        }
                        10 => {
                            print_nl_cstr(b"<everydisplay> \x00" as *const u8 as *const i8);
                        }
                        11 => {
                            print_nl_cstr(b"<everyhbox> \x00" as *const u8 as *const i8);
                        }
                        12 => {
                            print_nl_cstr(b"<everyvbox> \x00" as *const u8 as *const i8);
                        }
                        13 => {
                            print_nl_cstr(b"<everyjob> \x00" as *const u8 as *const i8);
                        }
                        14 => {
                            print_nl_cstr(b"<everycr> \x00" as *const u8 as *const i8);
                        }
                        15 => {
                            print_nl_cstr(b"<mark> \x00" as *const u8 as *const i8);
                        }
                        16 => {
                            print_nl_cstr(b"<everyeof> \x00" as *const u8 as *const i8);
                        }
                        17 => {
                            print_nl_cstr(b"<XeTeXinterchartoks> \x00" as *const u8 as *const i8);
                        }
                        18 => {
                            print_nl_cstr(b"<write> \x00" as *const u8 as *const i8);
                        }
                        19 => {
                            print_nl_cstr(b"<TectonicCodaTokens> \x00" as *const u8 as *const i8);
                        }
                        _ => {
                            print_nl('?' as i32);
                        }
                    }
                    l = tally;
                    tally = 0i32;
                    selector = Selector::PSEUDO;
                    trick_count = 1000000i64 as i32;
                    if (cur_input.index as i32) < 6i32 {
                        show_token_list(cur_input.start, cur_input.loc, 100000i64 as i32);
                    } else {
                        show_token_list(
                            (*mem.offset(cur_input.start as isize)).b32.s1,
                            cur_input.loc,
                            100000i64 as i32,
                        );
                    }
                }
                selector = old_setting_0;
                if trick_count as i64 == 1000000 {
                    first_count = tally;
                    trick_count = tally + 1i32 + error_line - half_error_line;
                    if trick_count < error_line {
                        trick_count = error_line
                    }
                }
                if tally < trick_count {
                    m = tally - first_count
                } else {
                    m = trick_count - first_count
                }
                if l + first_count <= half_error_line {
                    p = 0i32;
                    n = l + first_count
                } else {
                    print_cstr(b"...\x00" as *const u8 as *const i8);
                    p = l + first_count - half_error_line + 3i32;
                    n = half_error_line
                }
                let mut for_end_0: i32 = 0;
                q = p;
                for_end_0 = first_count - 1i32;
                if q <= for_end_0 {
                    loop {
                        print_raw_char(trick_buf[(q % error_line) as usize], true);
                        let fresh24 = q;
                        q = q + 1;
                        if !(fresh24 < for_end_0) {
                            break;
                        }
                    }
                }
                print_ln();
                let mut for_end_1: i32 = 0;
                q = 1i32;
                for_end_1 = n;
                if q <= for_end_1 {
                    loop {
                        print_raw_char(' ' as i32 as UTF16_code, true);
                        let fresh25 = q;
                        q = q + 1;
                        if !(fresh25 < for_end_1) {
                            break;
                        }
                    }
                }
                if m + n <= error_line {
                    p = first_count + m
                } else {
                    p = first_count + (error_line - n - 3i32)
                }
                let mut for_end_2: i32 = 0;
                q = first_count;
                for_end_2 = p - 1i32;
                if q <= for_end_2 {
                    loop {
                        print_raw_char(trick_buf[(q % error_line) as usize], true);
                        let fresh26 = q;
                        q = q + 1;
                        if !(fresh26 < for_end_2) {
                            break;
                        }
                    }
                }
                if m + n > error_line {
                    print_cstr(b"...\x00" as *const u8 as *const i8);
                }
                nn += 1
            }
        } else if nn
            == (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 54i32) as isize,
            ))
            .b32
            .s1
        {
            print_nl_cstr(b"...\x00" as *const u8 as *const i8);
            nn += 1
        }
        if bottom_line {
            break;
        }
        base_ptr -= 1
    }
    cur_input = *input_stack.offset(input_ptr as isize);
}
#[no_mangle]
pub unsafe extern "C" fn begin_token_list(mut p: i32, mut t: u16) {
    if input_ptr > max_in_stack {
        max_in_stack = input_ptr;
        if input_ptr == stack_size {
            overflow(
                b"input stack size\x00" as *const u8 as *const i8,
                stack_size,
            );
        }
    }
    *input_stack.offset(input_ptr as isize) = cur_input;
    input_ptr += 1;
    cur_input.state = 0_u16;
    cur_input.start = p;
    cur_input.index = t;
    if t as i32 >= 6i32 {
        let ref mut fresh27 = (*mem.offset(p as isize)).b32.s0;
        *fresh27 += 1;
        if t as i32 == 6i32 {
            cur_input.limit = param_ptr
        } else {
            cur_input.loc = (*mem.offset(p as isize)).b32.s1;
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 30i32) as isize,
            ))
            .b32
            .s1 > 1i32
            {
                begin_diagnostic();
                print_nl_cstr(b"\x00" as *const u8 as *const i8);
                match t as i32 {
                    15 => {
                        print_esc_cstr(b"mark\x00" as *const u8 as *const i8);
                    }
                    18 => {
                        print_esc_cstr(b"write\x00" as *const u8 as *const i8);
                    }
                    _ => {
                        print_cmd_chr(
                            73_u16,
                            t as i32
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32)
                                + 1i32
                                - 7i32,
                        );
                    }
                }
                print_cstr(b"->\x00" as *const u8 as *const i8);
                token_show(p);
                end_diagnostic(false);
            }
        }
    } else {
        cur_input.loc = p
    };
}
#[no_mangle]
pub unsafe extern "C" fn end_token_list() {
    if cur_input.index as i32 >= 3i32 {
        if cur_input.index as i32 <= 5i32 {
            flush_list(cur_input.start);
        } else {
            delete_token_ref(cur_input.start);
            if cur_input.index as i32 == 6i32 {
                while param_ptr > cur_input.limit {
                    param_ptr -= 1;
                    flush_list(*param_stack.offset(param_ptr as isize));
                }
            }
        }
    } else if cur_input.index as i32 == 1i32 {
        if align_state as i64 > 500000 {
            align_state = 0i32
        } else {
            fatal_error(
                b"(interwoven alignment preambles are not allowed)\x00" as *const u8 as *const i8,
            );
        }
    }
    input_ptr -= 1;
    cur_input = *input_stack.offset(input_ptr as isize);
}
#[no_mangle]
pub unsafe extern "C" fn back_input() {
    let mut p: i32 = 0;
    while cur_input.state as i32 == 0i32
        && cur_input.loc == -0xfffffffi32
        && cur_input.index as i32 != 2i32
    {
        end_token_list();
    }
    p = get_avail();
    (*mem.offset(p as isize)).b32.s0 = cur_tok;
    if cur_tok < 0x600000i32 {
        if cur_tok < 0x400000i32 {
            align_state -= 1
        } else {
            align_state += 1
        }
    }
    if input_ptr > max_in_stack {
        max_in_stack = input_ptr;
        if input_ptr == stack_size {
            overflow(
                b"input stack size\x00" as *const u8 as *const i8,
                stack_size,
            );
        }
    }
    *input_stack.offset(input_ptr as isize) = cur_input;
    input_ptr += 1;
    cur_input.state = 0_u16;
    cur_input.start = p;
    cur_input.index = 3_u16;
    cur_input.loc = p;
}
#[no_mangle]
pub unsafe extern "C" fn back_error() {
    back_input();
    error();
}
#[no_mangle]
pub unsafe extern "C" fn ins_error() {
    back_input();
    cur_input.index = 5_u16;
    error();
}
#[no_mangle]
pub unsafe extern "C" fn begin_file_reading() {
    if in_open == max_in_open {
        overflow(
            b"text input levels\x00" as *const u8 as *const i8,
            max_in_open,
        );
    }
    if first == buf_size {
        overflow(b"buffer size\x00" as *const u8 as *const i8, buf_size);
    }
    in_open += 1;
    if input_ptr > max_in_stack {
        max_in_stack = input_ptr;
        if input_ptr == stack_size {
            overflow(
                b"input stack size\x00" as *const u8 as *const i8,
                stack_size,
            );
        }
    }
    *input_stack.offset(input_ptr as isize) = cur_input;
    input_ptr += 1;
    cur_input.index = in_open as u16;
    *source_filename_stack.offset(cur_input.index as isize) = 0i32;
    *full_source_filename_stack.offset(cur_input.index as isize) = 0i32;
    *eof_seen.offset(cur_input.index as isize) = false;
    *grp_stack.offset(cur_input.index as isize) = cur_boundary;
    *if_stack.offset(cur_input.index as isize) = cond_ptr;
    *line_stack.offset(cur_input.index as isize) = line;
    cur_input.start = first;
    cur_input.state = 1_u16;
    cur_input.name = 0i32;
    cur_input.synctex_tag = 0i32;
}
#[no_mangle]
pub unsafe extern "C" fn end_file_reading() {
    first = cur_input.start;
    line = *line_stack.offset(cur_input.index as isize);
    if cur_input.name == 18i32 || cur_input.name == 19i32 {
        pseudo_close();
    } else if cur_input.name > 17i32 {
        u_close(*input_file.offset(cur_input.index as isize));
    }
    input_ptr -= 1;
    cur_input = *input_stack.offset(input_ptr as isize);
    in_open -= 1;
}
#[no_mangle]
pub unsafe extern "C" fn check_outer_validity() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    if scanner_status as i32 != 0i32 {
        deletions_allowed = false;
        if cur_cs != 0i32 {
            if cur_input.state as i32 == 0i32 || cur_input.name < 1i32 || cur_input.name > 17i32 {
                p = get_avail();
                (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32 + cur_cs;
                begin_token_list(p, 3_u16);
            }
            cur_cmd = 10i32 as eight_bits;
            cur_chr = ' ' as i32
        }
        if scanner_status as i32 > 1i32 {
            /*350:*/
            runaway();
            if cur_cs == 0i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"File ended\x00" as *const u8 as *const i8);
            } else {
                cur_cs = 0i32;
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Forbidden control sequence found\x00" as *const u8 as *const i8);
            }
            p = get_avail();
            match scanner_status as i32 {
                2 => {
                    print_cstr(b" while scanning definition\x00" as *const u8 as *const i8);
                    (*mem.offset(p as isize)).b32.s0 = 0x400000i32 + '}' as i32
                }
                3 => {
                    print_cstr(b" while scanning use\x00" as *const u8 as *const i8);
                    (*mem.offset(p as isize)).b32.s0 = par_token;
                    long_state = 115_u8
                }
                4 => {
                    print_cstr(b" while scanning preamble\x00" as *const u8 as *const i8);
                    (*mem.offset(p as isize)).b32.s0 = 0x400000i32 + '}' as i32;
                    q = p;
                    p = get_avail();
                    (*mem.offset(p as isize)).b32.s1 = q;
                    (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
                        + (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 1i32);
                    align_state = -1000000i64 as i32
                }
                5 => {
                    print_cstr(b" while scanning text\x00" as *const u8 as *const i8);
                    (*mem.offset(p as isize)).b32.s0 = 0x400000i32 + '}' as i32
                }
                _ => {}
            }
            begin_token_list(p, 5_u16);
            print_cstr(b" of \x00" as *const u8 as *const i8);
            sprint_cs(warning_index);
            help_ptr = 4_u8;
            help_line[3] =
                b"I suspect you have forgotten a `}\', causing me\x00" as *const u8 as *const i8;
            help_line[2] =
                b"to read past where you wanted me to stop.\x00" as *const u8 as *const i8;
            help_line[1] =
                b"I\'ll try to recover; but if the error is serious,\x00" as *const u8 as *const i8;
            help_line[0] = b"you\'d better type `E\' or `X\' now and fix your file.\x00"
                as *const u8 as *const i8;
            error();
        } else {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Incomplete \x00" as *const u8 as *const i8);
            print_cmd_chr(107_u16, cur_if as i32);
            print_cstr(b"; all text was ignored after line \x00" as *const u8 as *const i8);
            print_int(skip_line);
            help_ptr = 3_u8;
            help_line[2] = b"A forbidden control sequence occurred in skipped text.\x00"
                as *const u8 as *const i8;
            help_line[1] = b"This kind of error happens when you say `\\if...\' and forget\x00"
                as *const u8 as *const i8;
            help_line[0] = b"the matching `\\fi\'. I\'ve inserted a `\\fi\'; this might work.\x00"
                as *const u8 as *const i8;
            if cur_cs != 0i32 {
                cur_cs = 0i32
            } else {
                help_line[2] = b"The file ended while I was skipping conditional text.\x00"
                    as *const u8 as *const i8
            }
            cur_tok = 0x1ffffffi32
                + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 4i32);
            ins_error();
        }
        deletions_allowed = true
    };
}
/* These macros are kinda scary, but convenient */
#[no_mangle]
pub unsafe extern "C" fn get_next() {
    let mut current_block: u64;
    let mut k: i32 = 0;
    let mut t: i32 = 0;
    let mut cat: u8 = 0;
    let mut c: UnicodeScalar = 0;
    let mut lower: UTF16_code = 0;
    let mut d: small_number = 0;
    let mut sup_count: small_number = 0;
    'c_63502: loop {
        cur_cs = 0i32;
        if cur_input.state as i32 != 0i32 {
            /*355:*/
            'c_63807: loop
            /*357:*/
            {
                if cur_input.loc <= cur_input.limit {
                    cur_chr = *buffer.offset(cur_input.loc as isize);
                    cur_input.loc += 1;
                    if cur_chr >= 0xd800i32
                        && cur_chr < 0xdc00i32
                        && cur_input.loc <= cur_input.limit
                        && *buffer.offset(cur_input.loc as isize) >= 0xdc00i32
                        && *buffer.offset(cur_input.loc as isize) < 0xe000i32
                    {
                        lower = (*buffer.offset(cur_input.loc as isize) - 0xdc00i32) as UTF16_code;
                        cur_input.loc += 1;
                        cur_chr =
                            (65536 + ((cur_chr - 0xd800i32) * 1024i32) as i64 + lower as i64) as i32
                    }
                    'c_65186: loop {
                        cur_cmd = (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + cur_chr) as isize,
                        ))
                        .b32
                        .s1 as eight_bits;
                        match cur_input.state as i32 + cur_cmd as i32 {
                            10 | 26 | 42 | 27 | 43 => {
                                break;
                            }
                            1 | 17 | 33 => {
                                if cur_input.loc > cur_input.limit {
                                    current_block = 17833034027772472439;
                                    break 'c_63807;
                                } else {
                                    current_block = 7720778817628725688;
                                    break 'c_63807;
                                }
                            }
                            14 | 30 | 46 => {
                                cur_cs = cur_chr + 1i32;
                                cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits;
                                cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
                                cur_input.state = 1_u16;
                                if cur_cmd as i32 >= 115i32 {
                                    check_outer_validity();
                                }
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            8 | 24 | 40 => {
                                if !(cur_chr == *buffer.offset(cur_input.loc as isize)) {
                                    current_block = 8567661057257693057;
                                    break 'c_63807;
                                }
                                if !(cur_input.loc < cur_input.limit) {
                                    current_block = 8567661057257693057;
                                    break 'c_63807;
                                }
                                sup_count = 2i32 as small_number;
                                while (sup_count as i32) < 6i32
                                    && cur_input.loc + 2i32 * sup_count as i32 - 2i32
                                        <= cur_input.limit
                                    && cur_chr
                                        == *buffer.offset(
                                            (cur_input.loc + sup_count as i32 - 1i32) as isize,
                                        )
                                {
                                    sup_count += 1
                                }
                                d = 1i32 as small_number;
                                while d as i32 <= sup_count as i32 {
                                    if !(*buffer.offset(
                                        (cur_input.loc + sup_count as i32 - 2i32 + d as i32)
                                            as isize,
                                    ) >= '0' as i32
                                        && *buffer.offset(
                                            (cur_input.loc + sup_count as i32 - 2i32 + d as i32)
                                                as isize,
                                        ) <= '9' as i32
                                        || *buffer.offset(
                                            (cur_input.loc + sup_count as i32 - 2i32 + d as i32)
                                                as isize,
                                        ) >= 'a' as i32
                                            && *buffer.offset(
                                                (cur_input.loc + sup_count as i32 - 2i32 + d as i32)
                                                    as isize,
                                            ) <= 'f' as i32)
                                    {
                                        c = *buffer.offset((cur_input.loc + 1i32) as isize);
                                        if !(c < 128i32) {
                                            current_block = 8567661057257693057;
                                            break 'c_63807;
                                        }
                                        cur_input.loc = cur_input.loc + 2i32;
                                        if c < 64i32 {
                                            cur_chr = c + 64i32
                                        } else {
                                            cur_chr = c - 64i32
                                        }
                                        continue 'c_65186;
                                    } else {
                                        d += 1
                                    }
                                }
                                cur_chr = 0i32;
                                d = 1i32 as small_number;
                                while d as i32 <= sup_count as i32 {
                                    c = *buffer.offset(
                                        (cur_input.loc + sup_count as i32 - 2i32 + d as i32)
                                            as isize,
                                    );
                                    if c <= '9' as i32 {
                                        cur_chr = 16i32 * cur_chr + c - '0' as i32
                                    } else {
                                        cur_chr = 16i32 * cur_chr + c - 'a' as i32 + 10i32
                                    }
                                    d += 1
                                }
                                if cur_chr > 0x10ffffi32 {
                                    cur_chr = *buffer.offset(cur_input.loc as isize);
                                    current_block = 8567661057257693057;
                                    break 'c_63807;
                                } else {
                                    cur_input.loc = cur_input.loc + 2i32 * sup_count as i32 - 1i32
                                }
                            }
                            16 | 32 | 48 => {
                                if file_line_error_style_p != 0 {
                                    print_file_line();
                                } else {
                                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                }
                                print_cstr(
                                    b"Text line contains an invalid character\x00" as *const u8
                                        as *const i8,
                                );
                                help_ptr = 2_u8;
                                help_line[1] =
                                    b"A funny symbol that I can\'t read has just been input.\x00"
                                        as *const u8
                                        as *const i8;
                                help_line[0] =
                                    b"Continue, and I\'ll forget that it ever happened.\x00"
                                        as *const u8
                                        as *const i8;
                                deletions_allowed = false;
                                error();
                                deletions_allowed = true;
                                continue 'c_63502;
                            }
                            11 => {
                                cur_input.state = 17_u16;
                                cur_chr = ' ' as i32;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            6 => {
                                cur_input.loc = cur_input.limit + 1i32;
                                cur_cmd = 10i32 as eight_bits;
                                cur_chr = ' ' as i32;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            15 | 31 | 47 | 22 => {
                                cur_input.loc = cur_input.limit + 1i32;
                                break;
                            }
                            38 => {
                                cur_input.loc = cur_input.limit + 1i32;
                                cur_cs = par_loc;
                                cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits;
                                cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
                                if cur_cmd as i32 >= 115i32 {
                                    check_outer_validity();
                                }
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            2 => {
                                align_state += 1;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            18 | 34 => {
                                cur_input.state = 1_u16;
                                align_state += 1;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            3 => {
                                align_state -= 1;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            19 | 35 => {
                                cur_input.state = 1_u16;
                                align_state -= 1;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            20 | 21 | 23 | 25 | 28 | 29 | 36 | 37 | 39 | 41 | 44 | 45 => {
                                cur_input.state = 1_u16;
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                            _ => {
                                current_block = 14956172121224201915;
                                break 'c_63807;
                            }
                        }
                    }
                } else {
                    cur_input.state = 33_u16;
                    if cur_input.name > 17i32 {
                        /*374:*/
                        line += 1; /*367:*/
                        first = cur_input.start;
                        if !force_eof {
                            if cur_input.name <= 19i32 {
                                if pseudo_input() {
                                    cur_input.limit = last
                                } else if (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 10i32) as isize,
                                ))
                                .b32
                                .s1 != -0xfffffffi32
                                    && !*eof_seen.offset(cur_input.index as isize)
                                {
                                    cur_input.limit = first - 1i32;
                                    *eof_seen.offset(cur_input.index as isize) = true;
                                    begin_token_list(
                                        (*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 10i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1,
                                        16_u16,
                                    );
                                    continue 'c_63502;
                                } else {
                                    force_eof = true
                                }
                            } else if input_line(*input_file.offset(cur_input.index as isize)) != 0
                            {
                                cur_input.limit = last
                            } else if (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 10i32) as isize,
                            ))
                            .b32
                            .s1 != -0xfffffffi32
                                && !*eof_seen.offset(cur_input.index as isize)
                            {
                                cur_input.limit = first - 1i32;
                                *eof_seen.offset(cur_input.index as isize) = true;
                                begin_token_list(
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 10i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                    16_u16,
                                );
                                continue 'c_63502;
                            } else {
                                force_eof = true
                            }
                        }
                        if force_eof {
                            if (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 62i32) as isize,
                            ))
                            .b32
                            .s1 > 0i32
                            {
                                if *grp_stack.offset(in_open as isize) != cur_boundary
                                    || *if_stack.offset(in_open as isize) != cond_ptr
                                {
                                    file_warning();
                                }
                            }
                            if cur_input.name >= 19i32 {
                                print_char(')' as i32);
                                open_parens -= 1;
                                rust_stdout.as_mut().unwrap().flush().unwrap();
                            }
                            force_eof = false;
                            end_file_reading();
                            check_outer_validity();
                            continue 'c_63502;
                        } else {
                            if (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 48i32) as isize,
                            ))
                            .b32
                            .s1 < 0i32
                                || (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 48i32) as isize,
                                ))
                                .b32
                                .s1 > 255i32
                            {
                                cur_input.limit -= 1
                            } else {
                                *buffer.offset(cur_input.limit as isize) = (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 48i32) as isize,
                                ))
                                .b32
                                .s1
                            }
                            first = cur_input.limit + 1i32;
                            cur_input.loc = cur_input.start
                        }
                    } else {
                        if cur_input.name != 0i32 {
                            cur_cmd = 0i32 as eight_bits;
                            cur_chr = 0i32;
                            return;
                        }
                        if input_ptr > 0i32 {
                            current_block = 4001239642700071046;
                            break;
                        } else {
                            current_block = 15055213890147597004;
                            break;
                        }
                    }
                }
            }
            match current_block {
                14956172121224201915 => {}
                _ => {
                    match current_block {
                        8567661057257693057 => {
                            cur_input.state = 1_u16;
                            current_block = 14956172121224201915;
                        }
                        7720778817628725688 => {
                            'c_65963: loop {
                                k = cur_input.loc;
                                cur_chr = *buffer.offset(k as isize);
                                cat = (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + cur_chr) as isize,
                                ))
                                .b32
                                .s1 as u8;
                                k += 1;
                                if cat as i32 == 11i32 {
                                    cur_input.state = 17_u16
                                } else if cat as i32 == 10i32 {
                                    cur_input.state = 17_u16
                                } else {
                                    cur_input.state = 1_u16
                                }
                                if cat as i32 == 11i32 && k <= cur_input.limit {
                                    loop
                                    /*368:*/
                                    {
                                        cur_chr = *buffer.offset(k as isize);
                                        cat = (*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 13i32
                                                + 256i32
                                                + 4i32
                                                + 256i32
                                                + 1i32
                                                + 3i32 * 256i32
                                                + cur_chr)
                                                as isize,
                                        ))
                                        .b32
                                        .s1 as u8;
                                        k += 1;
                                        if !(cat as i32 == 11i32 && k <= cur_input.limit) {
                                            break;
                                        }
                                    }
                                    if !(cat as i32 == 7i32
                                        && *buffer.offset(k as isize) == cur_chr
                                        && k < cur_input.limit)
                                    {
                                        current_block = 5873035170358615968;
                                        break;
                                    }
                                    /* Special characters: either ^^X, or up to six
                                     * ^'s followed by one hex character for each
                                     * ^. */
                                    let mut sup_count_save: i32 = 0;
                                    /* How many ^'s are there? */
                                    sup_count = 2i32 as small_number;
                                    while (sup_count as i32) < 6i32
                                        && k + 2i32 * sup_count as i32 - 2i32 <= cur_input.limit
                                        && *buffer.offset((k + sup_count as i32 - 1i32) as isize)
                                            == cur_chr
                                    {
                                        sup_count += 1
                                    }
                                    /* If they are followed by a sufficient number of
                                     * hex characters, treat it as an extended ^^^
                                     * sequence. If not, treat it as original-style
                                     * ^^X. */
                                    sup_count_save = sup_count as i32;
                                    d = 1i32 as small_number;
                                    while d as i32 <= sup_count_save {
                                        if !(*buffer.offset(
                                            (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                        ) >= '0' as i32
                                            && *buffer.offset(
                                                (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                            ) <= '9' as i32
                                            || *buffer.offset(
                                                (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                            ) >= 'a' as i32
                                                && *buffer.offset(
                                                    (k + sup_count as i32 - 2i32 + d as i32)
                                                        as isize,
                                                ) <= 'f' as i32)
                                        {
                                            /* Non-hex: do it old style */
                                            c = *buffer.offset((k + 1i32) as isize);
                                            if c < 128i32 {
                                                if c < 64i32 {
                                                    *buffer.offset((k - 1i32) as isize) = c + 64i32
                                                } else {
                                                    *buffer.offset((k - 1i32) as isize) = c - 64i32
                                                }
                                                d = 2i32 as small_number;
                                                cur_input.limit = cur_input.limit - d as i32;
                                                while k <= cur_input.limit {
                                                    *buffer.offset(k as isize) =
                                                        *buffer.offset((k + d as i32) as isize);
                                                    k += 1
                                                }
                                                continue 'c_65963;
                                            } else {
                                                sup_count = 0i32 as small_number
                                            }
                                        }
                                        d += 1
                                    }
                                    if !(sup_count as i32 > 0i32) {
                                        current_block = 5873035170358615968;
                                        break;
                                    }
                                    cur_chr = 0i32;
                                    d = 1i32 as small_number;
                                    while d as i32 <= sup_count as i32 {
                                        c = *buffer.offset(
                                            (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                        );
                                        if c <= '9' as i32 {
                                            cur_chr = 16i32 * cur_chr + c - '0' as i32
                                        } else {
                                            cur_chr = 16i32 * cur_chr + c - 'a' as i32 + 10i32
                                        }
                                        d += 1
                                    }
                                    if cur_chr > 0x10ffffi32 {
                                        cur_chr = *buffer.offset(k as isize);
                                        current_block = 5873035170358615968;
                                        break;
                                    } else {
                                        *buffer.offset((k - 1i32) as isize) = cur_chr;
                                        d = (2i32 * sup_count as i32 - 1i32) as small_number;
                                        cur_input.limit = cur_input.limit - d as i32;
                                        while k <= cur_input.limit {
                                            *buffer.offset(k as isize) =
                                                *buffer.offset((k + d as i32) as isize);
                                            k += 1
                                        }
                                    }
                                } else {
                                    if !(cat as i32 == 7i32
                                        && *buffer.offset(k as isize) == cur_chr
                                        && k < cur_input.limit)
                                    {
                                        current_block = 1604201581803946138;
                                        break;
                                    }
                                    let mut sup_count_save_0: i32 = 0;
                                    sup_count = 2i32 as small_number;
                                    while (sup_count as i32) < 6i32
                                        && k + 2i32 * sup_count as i32 - 2i32 <= cur_input.limit
                                        && *buffer.offset((k + sup_count as i32 - 1i32) as isize)
                                            == cur_chr
                                    {
                                        sup_count += 1
                                    }
                                    sup_count_save_0 = sup_count as i32;
                                    d = 1i32 as small_number;
                                    while d as i32 <= sup_count_save_0 {
                                        if !(*buffer.offset(
                                            (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                        ) >= '0' as i32
                                            && *buffer.offset(
                                                (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                            ) <= '9' as i32
                                            || *buffer.offset(
                                                (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                            ) >= 'a' as i32
                                                && *buffer.offset(
                                                    (k + sup_count as i32 - 2i32 + d as i32)
                                                        as isize,
                                                ) <= 'f' as i32)
                                        {
                                            c = *buffer.offset((k + 1i32) as isize);
                                            if c < 128i32 {
                                                if c < 64i32 {
                                                    *buffer.offset((k - 1i32) as isize) = c + 64i32
                                                } else {
                                                    *buffer.offset((k - 1i32) as isize) = c - 64i32
                                                }
                                                d = 2i32 as small_number;
                                                cur_input.limit = cur_input.limit - d as i32;
                                                while k <= cur_input.limit {
                                                    *buffer.offset(k as isize) =
                                                        *buffer.offset((k + d as i32) as isize);
                                                    k += 1
                                                }
                                                continue 'c_65963;
                                            } else {
                                                sup_count = 0i32 as small_number
                                            }
                                        }
                                        d += 1
                                    }
                                    if !(sup_count as i32 > 0i32) {
                                        current_block = 1604201581803946138;
                                        break;
                                    }
                                    cur_chr = 0i32;
                                    d = 1i32 as small_number;
                                    while d as i32 <= sup_count as i32 {
                                        c = *buffer.offset(
                                            (k + sup_count as i32 - 2i32 + d as i32) as isize,
                                        );
                                        if c <= '9' as i32 {
                                            cur_chr = 16i32 * cur_chr + c - '0' as i32
                                        } else {
                                            cur_chr = 16i32 * cur_chr + c - 'a' as i32 + 10i32
                                        }
                                        d += 1
                                    }
                                    if cur_chr > 0x10ffffi32 {
                                        cur_chr = *buffer.offset(k as isize);
                                        current_block = 1604201581803946138;
                                        break;
                                    } else {
                                        *buffer.offset((k - 1i32) as isize) = cur_chr;
                                        d = (2i32 * sup_count as i32 - 1i32) as small_number;
                                        cur_input.limit = cur_input.limit - d as i32;
                                        while k <= cur_input.limit {
                                            *buffer.offset(k as isize) =
                                                *buffer.offset((k + d as i32) as isize);
                                            k += 1
                                        }
                                    }
                                }
                            }
                            match current_block {
                                5873035170358615968 => {
                                    if cat as i32 != 11i32 {
                                        k -= 1
                                    }
                                    if k > cur_input.loc + 1i32 {
                                        cur_cs = id_lookup(cur_input.loc, k - cur_input.loc);
                                        cur_input.loc = k;
                                        current_block = 10802200937357087535;
                                    } else {
                                        current_block = 1604201581803946138;
                                    }
                                }
                                _ => {}
                            }
                            match current_block {
                                10802200937357087535 => {}
                                _ => {
                                    if *buffer.offset(cur_input.loc as isize) as i64 > 65535 {
                                        cur_cs = id_lookup(cur_input.loc, 1i32);
                                        cur_input.loc += 1
                                    } else {
                                        cur_cs = 1i32
                                            + (0x10ffffi32 + 1i32)
                                            + *buffer.offset(cur_input.loc as isize);
                                        cur_input.loc += 1
                                    }
                                    current_block = 10802200937357087535;
                                }
                            }
                        }
                        17833034027772472439 => {
                            cur_cs = 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32);
                            current_block = 10802200937357087535;
                        }
                        4001239642700071046 => {
                            end_file_reading();
                            continue;
                        }
                        _ =>
                        /* Tectonic extension: we add a \TectonicCodaTokens toklist
                         * that gets inserted at the very very end of processing if no
                         * \end or \dump has been seen. We just use a global state
                         * variable to make sure it only gets inserted once. */
                        {
                            if !used_tectonic_coda_tokens
                                && (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 12i32) as isize,
                                ))
                                .b32
                                .s1 != -0xfffffffi32
                            {
                                used_tectonic_coda_tokens = true; /* token list but no tokens left */
                                begin_token_list(
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 12i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                    19_u16,
                                );
                                continue;
                            } else {
                                if u8::from(selector) < u8::from(Selector::LOG_ONLY) {
                                    open_log_file();
                                }
                                fatal_error(
                                    b"*** (job aborted, no legal \\end found)\x00" as *const u8
                                        as *const i8,
                                );
                            }
                        }
                    }
                    match current_block {
                        14956172121224201915 => {}
                        _ => {
                            cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits;
                            cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
                            if cur_cmd as i32 >= 115i32 {
                                check_outer_validity();
                            }
                        }
                    }
                }
            }
        } else if cur_input.loc != -0xfffffffi32 {
            /* if we're inputting from a non-null token list: */
            t = (*mem.offset(cur_input.loc as isize)).b32.s0;
            cur_input.loc = (*mem.offset(cur_input.loc as isize)).b32.s1;
            if t >= 0x1ffffffi32 {
                cur_cs = t - 0x1ffffffi32;
                cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits;
                cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
                if cur_cmd as i32 >= 115i32 {
                    if cur_cmd as i32 == 118i32 {
                        /*370:*/
                        cur_cs = (*mem.offset(cur_input.loc as isize)).b32.s0 - 0x1ffffffi32;
                        cur_input.loc = -0xfffffffi32;
                        cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits;
                        cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
                        if cur_cmd as i32 > 102i32 {
                            cur_cmd = 0i32 as eight_bits;
                            cur_chr = 0x10ffffi32 + 2i32
                        }
                    } else {
                        check_outer_validity();
                    }
                }
            } else {
                cur_cmd = (t / 0x200000i32) as eight_bits;
                cur_chr = t % 0x200000i32;
                match cur_cmd as i32 {
                    1 => {
                        current_block = 17818108259648334471;
                        align_state += 1;
                    }
                    2 => {
                        current_block = 1336783539463924428;
                        align_state -= 1;
                    }
                    5 => {
                        current_block = 1132450443677887731;
                        begin_token_list(
                            *param_stack.offset((cur_input.limit + cur_chr - 1i32) as isize),
                            0_u16,
                        );
                        continue;
                    }
                    _ => {}
                }
            }
        } else {
            end_token_list();
            continue;
        }
        if cur_cmd as i32 <= 5i32 && cur_cmd as i32 >= 4i32 && align_state == 0i32 {
            /*818:*/
            if scanner_status as i32 == 4i32 || cur_align == -0xfffffffi32 {
                fatal_error(
                    b"(interwoven alignment preambles are not allowed)\x00" as *const u8
                        as *const i8,
                );
            }
            cur_cmd = (*mem.offset((cur_align + 5i32) as isize)).b32.s0 as eight_bits;
            (*mem.offset((cur_align + 5i32) as isize)).b32.s0 = cur_chr;
            if cur_cmd as i32 == 63i32 {
                begin_token_list(4999999i32 - 10i32, 2_u16);
            } else {
                begin_token_list((*mem.offset((cur_align + 2i32) as isize)).b32.s1, 2_u16);
            }
            align_state = 1000000i64 as i32
        } else {
            return;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn get_token() {
    no_new_control_sequence = false;
    get_next();
    no_new_control_sequence = true;
    if cur_cs == 0i32 {
        cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr
    } else {
        cur_tok = 0x1ffffffi32 + cur_cs
    };
}
#[no_mangle]
pub unsafe extern "C" fn macro_call() {
    let mut current_block: u64;
    let mut r: i32 = 0;
    let mut p: i32 = -0xfffffffi32;
    let mut q: i32 = 0;
    let mut s: i32 = 0;
    let mut t: i32 = 0;
    let mut u: i32 = 0;
    let mut v: i32 = 0;
    let mut rbrace_ptr: i32 = -0xfffffffi32;
    let mut n: small_number = 0;
    let mut unbalance: i32 = 0;
    let mut m: i32 = 0i32;
    let mut ref_count: i32 = 0;
    let mut save_scanner_status: small_number = 0;
    let mut save_warning_index: i32 = 0;
    let mut match_chr: UTF16_code = 0;
    save_scanner_status = scanner_status as small_number;
    save_warning_index = warning_index;
    warning_index = cur_cs;
    ref_count = cur_chr;
    r = (*mem.offset(ref_count as isize)).b32.s1;
    n = 0i32 as small_number;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 30i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        /*419:*/
        begin_diagnostic();
        print_ln();
        print_cs(warning_index);
        token_show(ref_count);
        end_diagnostic(false);
    }
    if (*mem.offset(r as isize)).b32.s0 == 0x1c00000i32 + 1i32 {
        r = (*mem.offset(r as isize)).b32.s1
    }
    if (*mem.offset(r as isize)).b32.s0 != 0x1c00000i32 {
        /*409:*/
        scanner_status = 3_u8;
        unbalance = 0i32;
        long_state = (*eqtb.offset(cur_cs as isize)).b16.s1 as u8;
        if long_state as i32 >= 115i32 {
            long_state = (long_state as i32 - 2i32) as u8
        }
        's_135: loop {
            (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 = -0xfffffffi32;
            if (*mem.offset(r as isize)).b32.s0 >= 0x1c00000i32
                || (*mem.offset(r as isize)).b32.s0 < 0x1a00000i32
            {
                s = -0xfffffffi32
            } else {
                match_chr = ((*mem.offset(r as isize)).b32.s0 - 0x1a00000i32) as UTF16_code;
                s = (*mem.offset(r as isize)).b32.s1;
                r = s;
                p = 4999999i32 - 3i32;
                m = 0i32
            }
            'c_67378: loop {
                get_token();
                if cur_tok == (*mem.offset(r as isize)).b32.s0 {
                    /*412:*/
                    r = (*mem.offset(r as isize)).b32.s1;
                    if !((*mem.offset(r as isize)).b32.s0 >= 0x1a00000i32
                        && (*mem.offset(r as isize)).b32.s0 <= 0x1c00000i32)
                    {
                        continue;
                    }
                    if cur_tok < 0x400000i32 {
                        align_state -= 1
                    }
                    break;
                } else {
                    if s != r {
                        if s == -0xfffffffi32 {
                            /*416:*/
                            if file_line_error_style_p != 0 {
                                print_file_line();
                            } else {
                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                            }
                            print_cstr(b"Use of \x00" as *const u8 as *const i8);
                            sprint_cs(warning_index);
                            print_cstr(
                                b" doesn\'t match its definition\x00" as *const u8 as *const i8,
                            );
                            help_ptr = 4_u8;
                            help_line[3] =
                                b"If you say, e.g., `\\def\\a1{...}\', then you must always\x00"
                                    as *const u8 as *const i8;
                            help_line[2] =
                                b"put `1\' after `\\a\', since control sequence names are\x00"
                                    as *const u8 as *const i8;
                            help_line[1] =
                                b"made up of letters only. The macro here has not been\x00"
                                    as *const u8 as *const i8;
                            help_line[0] =
                                b"followed by the required stuff, so I\'m ignoring it.\x00"
                                    as *const u8 as *const i8;
                            error();
                            current_block = 16670727159935121194;
                            break 's_135;
                        } else {
                            t = s;
                            loop {
                                q = get_avail();
                                (*mem.offset(p as isize)).b32.s1 = q;
                                (*mem.offset(q as isize)).b32.s0 = (*mem.offset(t as isize)).b32.s0;
                                p = q;
                                m += 1;
                                u = (*mem.offset(t as isize)).b32.s1;
                                v = s;
                                loop {
                                    if u == r {
                                        if cur_tok != (*mem.offset(v as isize)).b32.s0 {
                                            break;
                                        }
                                        r = (*mem.offset(v as isize)).b32.s1;
                                        continue 'c_67378;
                                    } else {
                                        if (*mem.offset(u as isize)).b32.s0
                                            != (*mem.offset(v as isize)).b32.s0
                                        {
                                            break;
                                        }
                                        u = (*mem.offset(u as isize)).b32.s1;
                                        v = (*mem.offset(v as isize)).b32.s1
                                    }
                                }
                                t = (*mem.offset(t as isize)).b32.s1;
                                if !(t != r) {
                                    break;
                                }
                            }
                            r = s
                        }
                    }
                    if cur_tok == par_token {
                        if long_state as i32 != 114i32 {
                            /*414:*/
                            if long_state as i32 == 113i32 {
                                runaway(); /*411:*/
                                if file_line_error_style_p != 0 {
                                    print_file_line(); /*413:*/
                                } else {
                                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                }
                                print_cstr(
                                    b"Paragraph ended before \x00" as *const u8 as *const i8,
                                );
                                sprint_cs(warning_index);
                                print_cstr(b" was complete\x00" as *const u8 as *const i8);
                                help_ptr = 3_u8;
                                help_line[2] =
                                            b"I suspect you\'ve forgotten a `}\', causing me to apply this\x00"
                                                as *const u8 as
                                                *const i8;
                                help_line[1] =
                                    b"control sequence to too much text. How can we recover?\x00"
                                        as *const u8
                                        as *const i8;
                                help_line[0] =
                                            b"My plan is to forget the whole thing and hope for the best.\x00"
                                                as *const u8 as
                                                *const i8;
                                back_error();
                            }
                            pstack[n as usize] = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
                            align_state = align_state - unbalance;
                            m = 0i32;
                            while m <= n as i32 {
                                flush_list(pstack[m as usize]);
                                m += 1
                            }
                            current_block = 16670727159935121194;
                            break 's_135;
                        }
                    }
                    if cur_tok < 0x600000i32 {
                        if cur_tok < 0x400000i32 {
                            /*417:*/
                            unbalance = 1i32;
                            loop {
                                q = avail;
                                if q == -0xfffffffi32 {
                                    q = get_avail()
                                } else {
                                    avail = (*mem.offset(q as isize)).b32.s1;
                                    (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32
                                }
                                (*mem.offset(p as isize)).b32.s1 = q;
                                (*mem.offset(q as isize)).b32.s0 = cur_tok;
                                p = q;
                                get_token();
                                if cur_tok == par_token {
                                    if long_state as i32 != 114i32 {
                                        /*414:*/
                                        if long_state as i32 == 113i32 {
                                            runaway();
                                            if file_line_error_style_p != 0 {
                                                print_file_line();
                                            } else {
                                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                            }
                                            print_cstr(
                                                b"Paragraph ended before \x00" as *const u8
                                                    as *const i8,
                                            );
                                            sprint_cs(warning_index);
                                            print_cstr(
                                                b" was complete\x00" as *const u8 as *const i8,
                                            );
                                            help_ptr = 3_u8;
                                            help_line[2] =
                                                        b"I suspect you\'ve forgotten a `}\', causing me to apply this\x00"
                                                            as *const u8 as
                                                            *const i8;
                                            help_line[1] =
                                                        b"control sequence to too much text. How can we recover?\x00"
                                                            as *const u8 as
                                                            *const i8;
                                            help_line[0] =
                                                        b"My plan is to forget the whole thing and hope for the best.\x00"
                                                            as *const u8 as
                                                            *const i8;
                                            back_error();
                                        }
                                        pstack[n as usize] =
                                            (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
                                        align_state = align_state - unbalance;
                                        m = 0i32;
                                        while m <= n as i32 {
                                            flush_list(pstack[m as usize]);
                                            m += 1
                                        }
                                        current_block = 16670727159935121194;
                                        break 's_135;
                                    }
                                }
                                if !(cur_tok < 0x600000i32) {
                                    continue;
                                }
                                if cur_tok < 0x400000i32 {
                                    unbalance += 1
                                } else {
                                    unbalance -= 1;
                                    if unbalance == 0i32 {
                                        break;
                                    }
                                }
                            }
                            rbrace_ptr = p;
                            q = get_avail();
                            (*mem.offset(p as isize)).b32.s1 = q;
                            (*mem.offset(q as isize)).b32.s0 = cur_tok;
                            p = q
                        } else {
                            back_input();
                            if file_line_error_style_p != 0 {
                                print_file_line();
                            } else {
                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                            }
                            print_cstr(b"Argument of \x00" as *const u8 as *const i8);
                            sprint_cs(warning_index);
                            print_cstr(b" has an extra }\x00" as *const u8 as *const i8);
                            help_ptr = 6_u8;
                            help_line[5] =
                                b"I\'ve run across a `}\' that doesn\'t seem to match anything.\x00"
                                    as *const u8 as *const i8;
                            help_line[4] =
                                b"For example, `\\def\\a#1{...}\' and `\\a}\' would produce\x00"
                                    as *const u8 as *const i8;
                            help_line[3] =
                                b"this error. If you simply proceed now, the `\\par\' that\x00"
                                    as *const u8 as *const i8;
                            help_line[2] =
                                b"I\'ve just inserted will cause me to report a runaway\x00"
                                    as *const u8 as *const i8;
                            help_line[1] =
                                b"argument that might be the root of the problem. But if\x00"
                                    as *const u8 as *const i8;
                            help_line[0] =
                                b"your `}\' was spurious, just type `2\' and it will go away.\x00"
                                    as *const u8 as *const i8;
                            align_state += 1;
                            long_state = 113_u8;
                            cur_tok = par_token;
                            ins_error();
                            continue;
                        }
                    } else {
                        if cur_tok == 0x1400020i32 {
                            if (*mem.offset(r as isize)).b32.s0 <= 0x1c00000i32 {
                                if (*mem.offset(r as isize)).b32.s0 >= 0x1a00000i32 {
                                    continue;
                                }
                            }
                        }
                        q = get_avail();
                        (*mem.offset(p as isize)).b32.s1 = q;
                        (*mem.offset(q as isize)).b32.s0 = cur_tok;
                        p = q
                    }
                    m += 1;
                    if (*mem.offset(r as isize)).b32.s0 > 0x1c00000i32 {
                        continue;
                    }
                    if !((*mem.offset(r as isize)).b32.s0 < 0x1a00000i32) {
                        break;
                    }
                }
            }
            if s != -0xfffffffi32 {
                /*418:*/
                if m == 1i32
                    && (*mem.offset(p as isize)).b32.s0 < 0x600000i32
                    && p != 4999999i32 - 3i32
                {
                    (*mem.offset(rbrace_ptr as isize)).b32.s1 = -0xfffffffi32;
                    (*mem.offset(p as isize)).b32.s1 = avail;
                    avail = p;
                    p = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
                    pstack[n as usize] = (*mem.offset(p as isize)).b32.s1;
                    (*mem.offset(p as isize)).b32.s1 = avail;
                    avail = p
                } else {
                    pstack[n as usize] = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1
                }
                n += 1;
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 30i32) as isize,
                ))
                .b32
                .s1 > 0i32
                {
                    begin_diagnostic();
                    print_nl(match_chr as str_number);
                    print_int(n as i32);
                    print_cstr(b"<-\x00" as *const u8 as *const i8);
                    show_token_list(pstack[(n as i32 - 1i32) as usize], -0xfffffffi32, 1000i32);
                    end_diagnostic(false);
                }
            }
            if !((*mem.offset(r as isize)).b32.s0 != 0x1c00000i32) {
                current_block = 12717620301112128284;
                break;
            }
        }
    } else {
        current_block = 12717620301112128284;
    }
    match current_block {
        12717620301112128284 => {
            while cur_input.state as i32 == 0i32
                && cur_input.loc == -0xfffffffi32
                && cur_input.index as i32 != 2i32
            {
                end_token_list();
            }
            begin_token_list(ref_count, 6_u16);
            cur_input.name = warning_index;
            cur_input.loc = (*mem.offset(r as isize)).b32.s1;
            if n as i32 > 0i32 {
                if param_ptr + n as i32 > max_param_stack {
                    max_param_stack = param_ptr + n as i32;
                    if max_param_stack > param_size {
                        overflow(
                            b"parameter stack size\x00" as *const u8 as *const i8,
                            param_size,
                        );
                    }
                }
                m = 0i32;
                while m <= n as i32 - 1i32 {
                    *param_stack.offset((param_ptr + m) as isize) = pstack[m as usize];
                    m += 1
                }
                param_ptr += n as i32
            }
        }
        _ => {}
    }
    scanner_status = save_scanner_status as u8;
    warning_index = save_warning_index;
}
#[no_mangle]
pub unsafe extern "C" fn insert_relax() {
    cur_tok = 0x1ffffffi32 + cur_cs;
    back_input();
    cur_tok = 0x1ffffffi32
        + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 7i32);
    back_input();
    cur_input.index = 5_u16;
}
#[no_mangle]
pub unsafe extern "C" fn new_index(mut i: u16, mut q: i32) {
    let mut k: small_number = 0;
    cur_ptr = get_node(33i32);
    (*mem.offset(cur_ptr as isize)).b16.s1 = i;
    (*mem.offset(cur_ptr as isize)).b16.s0 = 0_u16;
    (*mem.offset(cur_ptr as isize)).b32.s1 = q;
    let mut for_end: i32 = 0;
    k = 1i32 as small_number;
    for_end = 33i32 - 1i32;
    if k as i32 <= for_end {
        loop {
            *mem.offset((cur_ptr + k as i32) as isize) = sa_null;
            let fresh28 = k;
            k = k + 1;
            if !((fresh28 as i32) < for_end) {
                break;
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn find_sa_element(mut t: small_number, mut n: i32, mut w: bool) {
    let mut current_block: u64;
    let mut q: i32 = 0;
    let mut i: small_number = 0;
    cur_ptr = sa_root[t as usize];
    if cur_ptr == -0xfffffffi32 {
        if w {
            new_index(t as u16, -0xfffffffi32);
            sa_root[t as usize] = cur_ptr;
            q = cur_ptr;
            i = (n / 0x40000i32) as small_number
        } else {
            return;
        }
        current_block = 15806769474000922024;
    } else {
        q = cur_ptr;
        i = (n / 0x40000i32) as small_number;
        if i as i32 & 1i32 != 0 {
            cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1
        } else {
            cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0
        }
        if cur_ptr == -0xfffffffi32 {
            if w {
                current_block = 15806769474000922024;
            } else {
                return;
            }
        } else {
            q = cur_ptr;
            i = (n / 4096i32 % 64i32) as small_number;
            if i as i32 & 1i32 != 0 {
                cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1
            } else {
                cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0
            }
            if cur_ptr == -0xfffffffi32 {
                if w {
                    current_block = 14787586673191526541;
                } else {
                    return;
                }
            } else {
                q = cur_ptr;
                i = (n / 64i32 % 64i32) as small_number;
                if i as i32 & 1i32 != 0 {
                    cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1
                } else {
                    cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0
                }
                if cur_ptr == -0xfffffffi32 {
                    if w {
                        current_block = 9497429165911859091;
                    } else {
                        return;
                    }
                } else {
                    q = cur_ptr;
                    i = (n % 64i32) as small_number;
                    if i as i32 & 1i32 != 0 {
                        cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1
                    } else {
                        cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0
                    }
                    if cur_ptr == -0xfffffffi32 && w as i32 != 0 {
                        current_block = 10182473981606373355;
                    } else {
                        return;
                    }
                }
            }
        }
    }
    match current_block {
        15806769474000922024 => {
            /*not_found1 */
            new_index(i as u16, q);
            if i as i32 & 1i32 != 0 {
                (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 = cur_ptr
            } else {
                (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 = cur_ptr
            }
            let ref mut fresh29 = (*mem.offset(q as isize)).b16.s0;
            *fresh29 = (*fresh29).wrapping_add(1);
            q = cur_ptr;
            i = (n / 4096i32 % 64i32) as small_number;
            current_block = 14787586673191526541;
        }
        _ => {}
    }
    match current_block {
        14787586673191526541 => {
            /*not_found2 */
            new_index(i as u16, q);
            if i as i32 & 1i32 != 0 {
                (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 = cur_ptr
            } else {
                (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 = cur_ptr
            }
            let ref mut fresh30 = (*mem.offset(q as isize)).b16.s0;
            *fresh30 = (*fresh30).wrapping_add(1);
            q = cur_ptr;
            i = (n / 64i32 % 64i32) as small_number;
            current_block = 9497429165911859091;
        }
        _ => {}
    }
    match current_block {
        9497429165911859091 => {
            /*not_found3 */
            new_index(i as u16, q);
            if i as i32 & 1i32 != 0 {
                (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 = cur_ptr
            } else {
                (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 = cur_ptr
            }
            let ref mut fresh31 = (*mem.offset(q as isize)).b16.s0;
            *fresh31 = (*fresh31).wrapping_add(1);
            q = cur_ptr;
            i = (n % 64i32) as small_number
        }
        _ => {}
    }
    /*not_found4 *//*1608: */
    if t as i32 == 7i32 {
        cur_ptr = get_node(4i32); /*level_one *//*:1608 */
        *mem.offset((cur_ptr + 1i32) as isize) = sa_null;
        *mem.offset((cur_ptr + 2i32) as isize) = sa_null;
        *mem.offset((cur_ptr + 3i32) as isize) = sa_null
    } else {
        if t as i32 <= 1i32 {
            cur_ptr = get_node(3i32);
            (*mem.offset((cur_ptr + 2i32) as isize)).b32.s1 = 0i32;
            (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1 = n
        } else {
            cur_ptr = get_node(2i32);
            if t as i32 <= 3i32 {
                (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1 = 0i32;
                let ref mut fresh32 = (*mem.offset(0)).b32.s1;
                *fresh32 += 1
            } else {
                (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1 = -0xfffffffi32
            }
        }
        (*mem.offset((cur_ptr + 1i32) as isize)).b32.s0 = -0xfffffffi32
    }
    (*mem.offset(cur_ptr as isize)).b16.s1 = (64i32 * t as i32 + i as i32) as u16;
    (*mem.offset(cur_ptr as isize)).b16.s0 = 1_u16;
    (*mem.offset(cur_ptr as isize)).b32.s1 = q;
    if i as i32 & 1i32 != 0 {
        (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 = cur_ptr
    } else {
        (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 = cur_ptr
    }
    let ref mut fresh33 = (*mem.offset(q as isize)).b16.s0;
    *fresh33 = (*fresh33).wrapping_add(1);
}
#[no_mangle]
pub unsafe extern "C" fn expand() {
    let mut t: i32 = 0;
    let mut b: bool = false;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut j: i32 = 0;
    let mut cv_backup: i32 = 0;
    let mut cvl_backup: small_number = 0;
    let mut radix_backup: small_number = 0;
    let mut co_backup: small_number = 0;
    let mut backup_backup: i32 = 0;
    let mut save_scanner_status: small_number = 0;
    expand_depth_count += 1;
    if expand_depth_count >= expand_depth {
        overflow(
            b"expansion depth\x00" as *const u8 as *const i8,
            expand_depth,
        );
    }
    cv_backup = cur_val;
    cvl_backup = cur_val_level as small_number;
    radix_backup = radix;
    co_backup = cur_order as small_number;
    backup_backup = (*mem.offset((4999999i32 - 13i32) as isize)).b32.s1;
    loop {
        if (cur_cmd as i32) < 113i32 {
            /*384:*/
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 36i32) as isize,
            ))
            .b32
            .s1 > 1i32
            {
                show_cur_cmd_chr(); /*1612:*/
            }
            match cur_cmd as i32 {
                112 => {
                    t = cur_chr % 5i32;
                    if cur_chr >= 5i32 {
                        scan_register_num();
                    } else {
                        cur_val = 0i32
                    }
                    if cur_val == 0i32 {
                        cur_ptr = cur_mark[t as usize]
                    } else {
                        find_sa_element(7i32 as small_number, cur_val, false);
                        if cur_ptr != -0xfffffffi32 {
                            if t & 1i32 != 0 {
                                cur_ptr = (*mem.offset((cur_ptr + t / 2i32 + 1i32) as isize)).b32.s1
                            } else {
                                cur_ptr = (*mem.offset((cur_ptr + t / 2i32 + 1i32) as isize)).b32.s0
                            }
                        }
                    }
                    if cur_ptr != -0xfffffffi32 {
                        begin_token_list(cur_ptr, 15_u16);
                    }
                    break;
                }
                104 => {
                    /*385:*/
                    if cur_chr == 0i32 {
                        get_token(); /*1553: "\unless" implementation */
                        t = cur_tok;
                        get_token();
                        if cur_cmd as i32 > 102i32 {
                            expand();
                        } else {
                            back_input();
                        }
                        cur_tok = t;
                        back_input();
                        break;
                    } else {
                        get_token();
                        if cur_cmd as i32 == 107i32 && cur_chr != 16i32 {
                            cur_chr = cur_chr + 32i32
                        } else {
                            if file_line_error_style_p != 0 {
                                print_file_line();
                            } else {
                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                            }
                            print_cstr(b"You can\'t use `\x00" as *const u8 as *const i8);
                            print_esc_cstr(b"unless\x00" as *const u8 as *const i8);
                            print_cstr(b"\' before `\x00" as *const u8 as *const i8);
                            print_cmd_chr(cur_cmd as u16, cur_chr);
                            print_char('\'' as i32);
                            help_ptr = 1_u8;
                            help_line[0] = b"Continue, and I\'ll forget that it ever happened.\x00"
                                as *const u8
                                as *const i8;
                            back_error();
                            break;
                        }
                    }
                }
                105 => {
                    /*386:*/
                    if cur_chr == 0i32 {
                        save_scanner_status = scanner_status as small_number; /*387: \primitive implementation */
                        scanner_status = 0_u8;
                        get_token();
                        scanner_status = save_scanner_status as u8;
                        t = cur_tok;
                        back_input();
                        if t >= 0x1ffffffi32 {
                            p = get_avail();
                            (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 9i32);
                            (*mem.offset(p as isize)).b32.s1 = cur_input.loc;
                            cur_input.start = p;
                            cur_input.loc = p
                        }
                        break;
                    } else {
                        save_scanner_status = scanner_status as small_number;
                        scanner_status = 0_u8;
                        get_token();
                        scanner_status = save_scanner_status as u8;
                        if cur_cs < 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 {
                            cur_cs = prim_lookup(cur_cs - (1i32 + (0x10ffffi32 + 1i32)))
                        } else {
                            cur_cs = prim_lookup((*hash.offset(cur_cs as isize)).s1)
                        }
                        if !(cur_cs != 0i32) {
                            break;
                        }
                        t = prim_eqtb[cur_cs as usize].b16.s1 as i32;
                        if t > 102i32 {
                            cur_cmd = t as eight_bits;
                            cur_chr = prim_eqtb[cur_cs as usize].b32.s1;
                            cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr;
                            cur_cs = 0i32
                        } else {
                            back_input();
                            p = get_avail();
                            (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 11i32);
                            (*mem.offset(p as isize)).b32.s1 = cur_input.loc;
                            cur_input.loc = p;
                            cur_input.start = p;
                            break;
                        }
                    }
                }
                109 => {
                    r = get_avail();
                    p = r;
                    b = is_in_csname;
                    is_in_csname = true;
                    loop {
                        get_x_token();
                        if cur_cs == 0i32 {
                            q = get_avail();
                            (*mem.offset(p as isize)).b32.s1 = q;
                            (*mem.offset(q as isize)).b32.s0 = cur_tok;
                            p = q
                        }
                        if !(cur_cs == 0i32) {
                            break;
                        }
                    }
                    if cur_cmd as i32 != 67i32 {
                        /*391:*/
                        if file_line_error_style_p != 0 {
                            print_file_line();
                        } else {
                            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                        }
                        print_cstr(b"Missing \x00" as *const u8 as *const i8);
                        print_esc_cstr(b"endcsname\x00" as *const u8 as *const i8);
                        print_cstr(b" inserted\x00" as *const u8 as *const i8);
                        help_ptr = 2_u8;
                        help_line[1] = b"The control sequence marked <to be read again> should\x00"
                            as *const u8 as *const i8;
                        help_line[0] = b"not appear between \\csname and \\endcsname.\x00"
                            as *const u8 as *const i8;
                        back_error();
                    }
                    is_in_csname = b;
                    j = first;
                    p = (*mem.offset(r as isize)).b32.s1;
                    while p != -0xfffffffi32 {
                        if j >= max_buf_stack {
                            max_buf_stack = j + 1i32;
                            if max_buf_stack == buf_size {
                                overflow(b"buffer size\x00" as *const u8 as *const i8, buf_size);
                            }
                        }
                        *buffer.offset(j as isize) = (*mem.offset(p as isize)).b32.s0 % 0x200000i32;
                        j += 1;
                        p = (*mem.offset(p as isize)).b32.s1
                    }
                    if j > first + 1i32 || *buffer.offset(first as isize) as i64 > 65535 {
                        no_new_control_sequence = false;
                        cur_cs = id_lookup(first, j - first);
                        no_new_control_sequence = true
                    } else if j == first {
                        cur_cs = 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32)
                    } else {
                        cur_cs = 1i32 + (0x10ffffi32 + 1i32) + *buffer.offset(first as isize)
                        /*:392*/
                    }
                    flush_list(r);
                    if (*eqtb.offset(cur_cs as isize)).b16.s1 as i32 == 103i32 {
                        eq_define(cur_cs, 0_u16, 0x10ffffi32 + 1i32);
                    }
                    cur_tok = cur_cs + 0x1ffffffi32;
                    back_input();
                    break;
                }
                110 => {
                    conv_toks();
                    break;
                }
                111 => {
                    ins_the_toks();
                    break;
                }
                107 => {
                    conditional();
                    break;
                }
                108 => {
                    if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 60i32) as isize,
                    ))
                    .b32
                    .s1 > 0i32
                    {
                        if (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 36i32) as isize,
                        ))
                        .b32
                        .s1 <= 1i32
                        {
                            show_cur_cmd_chr();
                        }
                    }
                    if cur_chr > if_limit as i32 {
                        if if_limit as i32 == 1i32 {
                            insert_relax();
                        } else {
                            if file_line_error_style_p != 0 {
                                print_file_line();
                            } else {
                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                            }
                            print_cstr(b"Extra \x00" as *const u8 as *const i8);
                            print_cmd_chr(108_u16, cur_chr);
                            help_ptr = 1_u8;
                            help_line[0] = b"I\'m ignoring this; it doesn\'t match any \\if.\x00"
                                as *const u8
                                as *const i8;
                            error();
                        }
                    } else {
                        while cur_chr != 2i32 {
                            pass_text();
                        }
                        if *if_stack.offset(in_open as isize) == cond_ptr {
                            if_warning();
                        }
                        p = cond_ptr;
                        if_line = (*mem.offset((p + 1i32) as isize)).b32.s1;
                        cur_if = (*mem.offset(p as isize)).b16.s0 as small_number;
                        if_limit = (*mem.offset(p as isize)).b16.s1 as u8;
                        cond_ptr = (*mem.offset(p as isize)).b32.s1;
                        free_node(p, 2i32);
                    }
                    break;
                }
                106 => {
                    if cur_chr == 1i32 {
                        /* \endinput */
                        force_eof = true
                    } else if cur_chr == 2i32 {
                        /*1537:*/
                        /* \scantokens */
                        pseudo_start();
                    } else if name_in_progress {
                        insert_relax();
                    } else {
                        /* \input */
                        start_input(0 as *const i8); /*393:*/
                    }
                    break;
                }
                _ => {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Undefined control sequence\x00" as *const u8 as *const i8);
                    help_ptr = 5_u8;
                    help_line[4] = b"The control sequence at the end of the top line\x00"
                        as *const u8 as *const i8;
                    help_line[3] = b"of your error message was never \\def\'ed. If you have\x00"
                        as *const u8 as *const i8;
                    help_line[2] = b"misspelled it (e.g., `\\hobx\'), type `I\' and the correct\x00"
                        as *const u8 as *const i8;
                    help_line[1] = b"spelling (e.g., `I\\hbox\'). Otherwise just continue,\x00"
                        as *const u8 as *const i8;
                    help_line[0] = b"and I\'ll forget about whatever was undefined.\x00"
                        as *const u8 as *const i8;
                    error();
                    break;
                }
            }
        } else {
            if (cur_cmd as i32) < 117i32 {
                macro_call();
            } else {
                cur_tok = 0x1ffffffi32
                    + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 6i32);
                back_input();
            }
            break;
        }
    }
    cur_val = cv_backup;
    cur_val_level = cvl_backup as u8;
    radix = radix_backup;
    cur_order = co_backup as glue_ord;
    (*mem.offset((4999999i32 - 13i32) as isize)).b32.s1 = backup_backup;
    expand_depth_count -= 1;
}
#[no_mangle]
pub unsafe extern "C" fn get_x_token() {
    loop {
        get_next();
        if cur_cmd as i32 <= 102i32 {
            break;
        }
        if cur_cmd as i32 >= 113i32 {
            if (cur_cmd as i32) < 117i32 {
                macro_call();
            } else {
                cur_cs =
                    1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 6i32;
                cur_cmd = 9i32 as eight_bits;
                break;
            }
        } else {
            expand();
        }
    }
    if cur_cs == 0i32 {
        cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr
    } else {
        cur_tok = 0x1ffffffi32 + cur_cs
    };
}
#[no_mangle]
pub unsafe extern "C" fn x_token() {
    while cur_cmd as i32 > 102i32 {
        expand();
        get_next();
    }
    if cur_cs == 0i32 {
        cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr
    } else {
        cur_tok = 0x1ffffffi32 + cur_cs
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_left_brace() {
    loop {
        get_x_token();
        if !(cur_cmd as i32 == 10i32 || cur_cmd as i32 == 0i32) {
            break;
        }
    }
    if cur_cmd as i32 != 1i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Missing { inserted\x00" as *const u8 as *const i8);
        help_ptr = 4_u8;
        help_line[3] =
            b"A left brace was mandatory here, so I\'ve put one in.\x00" as *const u8 as *const i8;
        help_line[2] = b"You might want to delete and/or insert some corrections\x00" as *const u8
            as *const i8;
        help_line[1] =
            b"so that I will find a matching right brace soon.\x00" as *const u8 as *const i8;
        help_line[0] = b"(If you\'re confused by all this, try typing `I}\' now.)\x00" as *const u8
            as *const i8;
        back_error();
        cur_tok = 0x200000i32 + '{' as i32;
        cur_cmd = 1i32 as eight_bits;
        cur_chr = '{' as i32;
        align_state += 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_optional_equals() {
    loop {
        get_x_token();
        if !(cur_cmd as i32 == 10i32) {
            break;
        }
    }
    if cur_tok != 0x1800000i32 + 61i32 {
        /*"="*/
        back_input();
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_keyword(mut s: *const i8) -> bool {
    let mut p: i32 = 4999999i32 - 13i32;
    let mut q: i32 = 0;
    (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
    if strlen(s) == 1 {
        let mut c: i8 = *s.offset(0);
        loop {
            get_x_token();
            if cur_cs == 0i32 && (cur_chr == c as i32 || cur_chr == c as i32 - 32i32) {
                q = get_avail();
                (*mem.offset(p as isize)).b32.s1 = q;
                (*mem.offset(q as isize)).b32.s0 = cur_tok;
                p = q;
                flush_list((*mem.offset((4999999i32 - 13i32) as isize)).b32.s1);
                return true;
            } else {
                if cur_cmd as i32 != 10i32 || p != 4999999i32 - 13i32 {
                    back_input();
                    if p != 4999999i32 - 13i32 {
                        begin_token_list(
                            (*mem.offset((4999999i32 - 13i32) as isize)).b32.s1,
                            3_u16,
                        );
                    }
                    return false;
                }
            }
        }
    }
    let slen = strlen(s);
    let mut i = 0;
    while i < slen {
        get_x_token();
        if cur_cs == 0i32
            && (cur_chr == *s.offset(i as isize) as i32
                || cur_chr == *s.offset(i as isize) as i32 - 32i32)
        {
            q = get_avail();
            (*mem.offset(p as isize)).b32.s1 = q;
            (*mem.offset(q as isize)).b32.s0 = cur_tok;
            p = q;
            i = i.wrapping_add(1)
        } else if cur_cmd as i32 != 10i32 || p != 4999999i32 - 13i32 {
            back_input();
            if p != 4999999i32 - 13i32 {
                begin_token_list((*mem.offset((4999999i32 - 13i32) as isize)).b32.s1, 3_u16);
            }
            return false;
        }
    }
    flush_list((*mem.offset((4999999i32 - 13i32) as isize)).b32.s1);
    true
}
#[no_mangle]
pub unsafe extern "C" fn mu_error() {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Incompatible glue units\x00" as *const u8 as *const i8);
    help_ptr = 1_u8;
    help_line[0] =
        b"I\'m going to assume that 1mu=1pt when they\'re mixed.\x00" as *const u8 as *const i8;
    error();
}
#[no_mangle]
pub unsafe extern "C" fn scan_glyph_number(mut f: internal_font_number) {
    if scan_keyword(b"/\x00" as *const u8 as *const i8) {
        scan_and_pack_name();
        cur_val = map_glyph_to_index(f);
        cur_val_level = 0_u8
    } else if scan_keyword(b"u\x00" as *const u8 as *const i8) {
        scan_char_num();
        cur_val = map_char_to_glyph(f, cur_val);
        cur_val_level = 0_u8
    } else {
        scan_int();
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_char_class() {
    scan_int();
    if cur_val < 0i32 || cur_val > 4096i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad character class\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"A character class must be between 0 and 4096.\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_char_class_not_ignored() {
    scan_int();
    if cur_val < 0i32 || cur_val > 4096i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad character class\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"A class for inter-character transitions must be between 0 and 4095.\x00"
            as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_eight_bit_int() {
    scan_int();
    if cur_val < 0i32 || cur_val > 255i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad register code\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"A register code or char class must be between 0 and 255.\x00" as *const u8
            as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_usv_num() {
    scan_int();
    if cur_val < 0i32 || cur_val > 0x10ffffi32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad character code\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"A Unicode scalar value must be between 0 and \"10FFFF.\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_char_num() {
    scan_int();
    if cur_val < 0i32 || cur_val > 0xffffi32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad character code\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"A character number must be between 0 and 65535.\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_xetex_math_char_int() {
    scan_int();
    if cur_val as u32 & 0x1fffff_u32 == 0x1fffff_u32 {
        if cur_val != 0x1fffffi32 {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Bad active XeTeX math code\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] = b"Since I ignore class and family for active math chars,\x00"
                as *const u8 as *const i8;
            help_line[0] = b"I changed this one to \"1FFFFF.\x00" as *const u8 as *const i8;
            int_error(cur_val);
            cur_val = 0x1fffffi32
        }
    } else if cur_val as u32 & 0x1fffff_u32 > 0x10ffff_u32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad XeTeX math character code\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"Since I expected a character number between 0 and \"10FFFF,\x00"
            as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_math(mut p: i32) {
    let mut c: i32 = 0;
    'c_118470: loop {
        loop
        /*422:*/
        {
            get_x_token();
            if !(cur_cmd as i32 == 10i32 || cur_cmd as i32 == 0i32) {
                break;
            }
        }
        loop {
            match cur_cmd as i32 {
                11 | 12 | 68 => {
                    c = (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + cur_chr) as isize,
                    ))
                    .b32
                    .s1;
                    if !(c as u32 & 0x1fffff_u32 == 0x1fffff_u32) {
                        break 'c_118470;
                    }
                    cur_cs = cur_chr + 1i32;
                    cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits;
                    cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
                    x_token();
                    back_input();
                    break;
                }
                16 => {
                    scan_char_num();
                    cur_chr = cur_val;
                    cur_cmd = 68i32 as eight_bits
                }
                17 => {
                    if cur_chr == 2i32 {
                        scan_math_class_int();
                        c = ((cur_val as u32 & 0x7_u32) << 21i32) as i32;
                        scan_math_fam_int();
                        c = (c as u32).wrapping_add((cur_val as u32 & 0xff_u32) << 24i32) as i32;
                        scan_usv_num();
                        c = c + cur_val
                    } else if cur_chr == 1i32 {
                        scan_xetex_math_char_int();
                        c = cur_val
                    } else {
                        scan_fifteen_bit_int();
                        c = (((cur_val / 4096i32) as u32 & 0x7_u32) << 21i32)
                            .wrapping_add(((cur_val % 4096i32 / 256i32) as u32 & 0xff_u32) << 24i32)
                            .wrapping_add((cur_val % 256i32) as u32)
                            as i32
                    }
                    break 'c_118470;
                }
                69 => {
                    c = (((cur_chr / 4096i32) as u32 & 0x7_u32) << 21i32)
                        .wrapping_add(((cur_chr % 4096i32 / 256i32) as u32 & 0xff_u32) << 24i32)
                        .wrapping_add((cur_chr % 256i32) as u32) as i32;
                    break 'c_118470;
                }
                70 => {
                    c = cur_chr;
                    break 'c_118470;
                }
                15 => {
                    if cur_chr == 1i32 {
                        scan_math_class_int();
                        c = ((cur_val as u32 & 0x7_u32) << 21i32) as i32;
                        scan_math_fam_int();
                        c = (c as u32).wrapping_add((cur_val as u32 & 0xff_u32) << 24i32) as i32;
                        scan_usv_num();
                        c = c + cur_val
                    } else {
                        scan_delimiter_int();
                        c = cur_val / 4096i32;
                        c = (((c / 4096i32) as u32 & 0x7_u32) << 21i32)
                            .wrapping_add(((c % 4096i32 / 256i32) as u32 & 0xff_u32) << 24i32)
                            .wrapping_add((c % 256i32) as u32) as i32
                    }
                    break 'c_118470;
                }
                _ => {
                    back_input();
                    scan_left_brace();
                    (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 = p;
                    save_ptr += 1;
                    push_math(9i32 as group_code);
                    return;
                }
            }
        }
    }
    (*mem.offset(p as isize)).b32.s1 = 1i32;
    (*mem.offset(p as isize)).b16.s0 = (c as i64 % 65536) as u16;
    if c as u32 >> 21i32 & 0x7_u32 == 7_u32
        && ((*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 44i32) as isize,
        ))
        .b32
        .s1 >= 0i32
            && (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 44i32) as isize,
            ))
            .b32
            .s1 < 256i32)
    {
        (*mem.offset(p as isize)).b16.s1 = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 44i32) as isize,
        ))
        .b32
        .s1 as u16
    } else {
        (*mem.offset(p as isize)).b16.s1 = (c as u32 >> 24i32 & 0xff_u32) as u16
    }
    (*mem.offset(p as isize)).b16.s1 = ((*mem.offset(p as isize)).b16.s1 as i64
        + (c as u32 & 0x1fffff_u32) as i64 / 65536 * 256i32 as i64)
        as u16;
}
#[no_mangle]
pub unsafe extern "C" fn set_math_char(mut c: i32) {
    let mut p: i32 = 0;
    let mut ch: UnicodeScalar = 0;
    if c as u32 & 0x1fffff_u32 == 0x1fffff_u32 {
        /*1187: */
        cur_cs = cur_chr + 1i32; /* ... "between 0 and 15" */
        cur_cmd = (*eqtb.offset(cur_cs as isize)).b16.s1 as eight_bits; /* ... "between 0 and 15" */
        cur_chr = (*eqtb.offset(cur_cs as isize)).b32.s1;
        x_token();
        back_input();
    } else {
        p = new_noad();
        (*mem.offset((p + 1i32) as isize)).b32.s1 = 1i32;
        ch = (c as u32 & 0x1fffff_u32) as UnicodeScalar;
        (*mem.offset((p + 1i32) as isize)).b16.s0 = (ch as i64 % 65536) as u16;
        (*mem.offset((p + 1i32) as isize)).b16.s1 = (c as u32 >> 24i32 & 0xff_u32) as u16;
        if c as u32 >> 21i32 & 0x7_u32 == 7_u32 {
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 44i32) as isize,
            ))
            .b32
            .s1 >= 0i32
                && (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 44i32) as isize,
                ))
                .b32
                .s1 < 256i32
            {
                (*mem.offset((p + 1i32) as isize)).b16.s1 = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 44i32) as isize,
                ))
                .b32
                .s1 as u16
            }
            (*mem.offset(p as isize)).b16.s1 = 16_u16
        } else {
            (*mem.offset(p as isize)).b16.s1 =
                (16_u32).wrapping_add(c as u32 >> 21i32 & 0x7_u32) as u16
        }
        (*mem.offset((p + 1i32) as isize)).b16.s1 =
            ((*mem.offset((p + 1i32) as isize)).b16.s1 as i64 + ch as i64 / 65536 * 256i32 as i64)
                as u16;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        cur_list.tail = p
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_math_class_int() {
    scan_int();
    if cur_val < 0i32 || cur_val > 7i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad math class\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"Since I expected to read a number between 0 and 7,\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_math_fam_int() {
    scan_int();
    if cur_val < 0i32 || cur_val > 256i32 - 1i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad math family\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"Since I expected to read a number between 0 and 255,\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_four_bit_int() {
    scan_int();
    if cur_val < 0i32 || cur_val > 15i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad number\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"Since I expected to read a number between 0 and 15,\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_fifteen_bit_int() {
    scan_int();
    if cur_val < 0i32 || cur_val > 32767i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad mathchar\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"A mathchar number must be between 0 and 32767.\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_delimiter_int() {
    scan_int();
    if cur_val < 0i32 || cur_val > 0x7ffffffi32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad delimiter code\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"A numeric delimiter code must be between 0 and 2^{27}-1.\x00" as *const u8
            as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_register_num() {
    scan_int();
    if cur_val < 0i32 || cur_val > max_reg_num {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad register code\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = max_reg_help_line;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_four_bit_int_or_18() {
    scan_int();
    if cur_val < 0i32 || cur_val > 15i32 && cur_val != 18i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad number\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"Since I expected to read a number between 0 and 15,\x00" as *const u8 as *const i8;
        help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
        int_error(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn get_x_or_protected() {
    loop {
        get_token();
        if cur_cmd as i32 <= 102i32 {
            return;
        }
        if cur_cmd as i32 >= 113i32 && (cur_cmd as i32) < 117i32 {
            if (*mem.offset((*mem.offset(cur_chr as isize)).b32.s1 as isize))
                .b32
                .s0
                == 0x1c00000i32 + 1i32
            {
                return;
            }
        }
        expand();
    }
}
#[no_mangle]
pub unsafe extern "C" fn effective_char(
    mut err_p: bool,
    mut f: internal_font_number,
    mut c: u16,
) -> i32 {
    if !xtx_ligature_present && !(*font_mapping.offset(f as isize)).is_null() {
        c = apply_tfm_font_mapping(*font_mapping.offset(f as isize), c as i32) as u16
    }
    xtx_ligature_present = false;
    c as i32
}
#[no_mangle]
pub unsafe extern "C" fn scan_font_ident() {
    let mut f: internal_font_number = 0;
    let mut m: i32 = 0;
    loop {
        get_x_token();
        if !(cur_cmd as i32 == 10i32) {
            break;
        }
    }
    if cur_cmd as i32 == 90i32 {
        f = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32) as isize,
        ))
        .b32
        .s1
    } else if cur_cmd as i32 == 89i32 {
        f = cur_chr
    } else if cur_cmd as i32 == 88i32 {
        m = cur_chr;
        scan_math_fam_int();
        f = (*eqtb.offset((m + cur_val) as isize)).b32.s1
    } else {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Missing font identifier\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"I was looking for a control sequence whose\x00" as *const u8 as *const i8;
        help_line[0] = b"current meaning has been defined by \\font.\x00" as *const u8 as *const i8;
        back_error();
        f = 0i32
    }
    cur_val = f;
}
#[no_mangle]
pub unsafe extern "C" fn find_font_dimen(mut writing: bool) {
    let mut f: internal_font_number = 0;
    let mut n: i32 = 0;
    scan_int();
    n = cur_val;
    scan_font_ident();
    f = cur_val;
    if n <= 0i32 {
        cur_val = fmem_ptr
    } else {
        if writing as i32 != 0
            && n <= 4i32
            && n >= 2i32
            && *font_glue.offset(f as isize) != -0xfffffffi32
        {
            delete_glue_ref(*font_glue.offset(f as isize));
            *font_glue.offset(f as isize) = -0xfffffffi32
        }
        if n > *font_params.offset(f as isize) {
            if f < font_ptr {
                cur_val = fmem_ptr
            } else {
                loop
                /*599: */
                {
                    if fmem_ptr == font_mem_size {
                        overflow(b"font memory\x00" as *const u8 as *const i8, font_mem_size);
                    }
                    (*font_info.offset(fmem_ptr as isize)).b32.s1 = 0i32;
                    fmem_ptr += 1;
                    let ref mut fresh34 = *font_params.offset(f as isize);
                    *fresh34 += 1;
                    if n == *font_params.offset(f as isize) {
                        break;
                    }
                }
                cur_val = fmem_ptr - 1i32
            }
        } else {
            cur_val = n + *param_base.offset(f as isize)
        }
    }
    if cur_val == fmem_ptr {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Font \x00" as *const u8 as *const i8);
        print_esc(
            (*hash.offset(
                (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 12i32 + f)
                    as isize,
            ))
            .s1,
        );
        print_cstr(b" has only \x00" as *const u8 as *const i8);
        print_int(*font_params.offset(f as isize));
        print_cstr(b" fontdimen parameters\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"To increase the number of font parameters, you must\x00" as *const u8 as *const i8;
        help_line[0] = b"use \\fontdimen immediately after the \\font is loaded.\x00" as *const u8
            as *const i8;
        error();
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_something_internal(mut level: small_number, mut negative: bool) {
    let mut m: i32 = 0;
    let mut n: i32 = 0;
    let mut k: i32 = 0;
    let mut kk: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut tx: i32 = 0;
    let mut i: b16x4 = b16x4 {
        s0: 0,
        s1: 0,
        s2: 0,
        s3: 0,
    };
    let mut p: i32 = 0;
    m = cur_chr;
    match cur_cmd as i32 {
        86 => {
            scan_usv_num();
            if m == 1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
            {
                cur_val1 = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + cur_val) as isize,
                ))
                .b32
                .s1;
                if cur_val1 as u32 & 0x1fffff_u32 == 0x1fffff_u32 {
                    cur_val1 = 0x8000i32
                } else if cur_val1 as u32 >> 21i32 & 0x7_u32 > 7_u32
                    || cur_val1 as u32 >> 24i32 & 0xff_u32 > 15_u32
                    || cur_val1 as u32 & 0x1fffff_u32 > 255_u32
                {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Extended mathchar used as mathchar\x00" as *const u8 as *const i8);
                    help_ptr = 2_u8;
                    help_line[1] = b"A mathchar number must be between 0 and \"7FFF.\x00"
                        as *const u8 as *const i8;
                    help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
                    int_error(cur_val1);
                    cur_val1 = 0i32
                }
                cur_val1 = (cur_val1 as u32 >> 21i32 & 0x7_u32)
                    .wrapping_mul(0x1000_u32)
                    .wrapping_add((cur_val1 as u32 >> 24i32 & 0xff_u32).wrapping_mul(0x100_u32))
                    .wrapping_add(cur_val1 as u32 & 0x1fffff_u32) as i32;
                cur_val = cur_val1;
                cur_val_level = 0_u8
            } else if m
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 85i32
                    + 256i32
            {
                cur_val1 = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 85i32
                        + 256i32
                        + cur_val) as isize,
                ))
                .b32
                .s1;
                if cur_val1 >= 0x40000000i32 {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Extended delcode used as delcode\x00" as *const u8 as *const i8);
                    help_ptr = 2_u8;
                    help_line[1] = b"I can only go up to 2147483647=\'17777777777=\"7FFFFFFF,\x00"
                        as *const u8 as *const i8;
                    help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
                    error();
                    cur_val = 0i32;
                    cur_val_level = 0_u8
                } else {
                    cur_val = cur_val1;
                    cur_val_level = 0_u8
                }
            } else if m < 1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
            {
                cur_val = (*eqtb.offset((m + cur_val) as isize)).b32.s1;
                cur_val_level = 0_u8
            } else if m < 1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
            {
                cur_val = ((*eqtb.offset((m + cur_val) as isize)).b32.s1 as i64 % 65536) as i32;
                cur_val_level = 0_u8
            } else {
                cur_val = (*eqtb.offset((m + cur_val) as isize)).b32.s1;
                cur_val_level = 0_u8
            }
        }
        87 => {
            scan_usv_num();
            if m == 1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
            {
                cur_val = ((*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + cur_val) as isize,
                ))
                .b32
                .s1 as i64
                    / 65536) as i32;
                cur_val_level = 0_u8
            } else if m
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
            {
                cur_val = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + cur_val) as isize,
                ))
                .b32
                .s1;
                cur_val_level = 0_u8
            } else if m
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
            {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(
                    b"Can\'t use \\Umathcode as a number (try \\Umathcodenum)\x00" as *const u8
                        as *const i8,
                );
                help_ptr = 2_u8;
                help_line[1] = b"\\Umathcode is for setting a mathcode from separate values;\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"use \\Umathcodenum to access them as single values.\x00"
                    as *const u8 as *const i8;
                error();
                cur_val = 0i32;
                cur_val_level = 0_u8
            } else if m
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 85i32
                    + 256i32
            {
                cur_val = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 85i32
                        + 256i32
                        + cur_val) as isize,
                ))
                .b32
                .s1;
                cur_val_level = 0_u8
            } else {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(
                    b"Can\'t use \\Udelcode as a number (try \\Udelcodenum)\x00" as *const u8
                        as *const i8,
                );
                help_ptr = 2_u8;
                help_line[1] = b"\\Udelcode is for setting a delcode from separate values;\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"use \\Udelcodenum to access them as single values.\x00"
                    as *const u8 as *const i8;
                error();
                cur_val = 0i32;
                cur_val_level = 0_u8
            }
        }
        72 | 73 | 88 | 89 | 90 => {
            if level as i32 != 5i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Missing number, treated as zero\x00" as *const u8 as *const i8);
                help_ptr = 3_u8;
                help_line[2] = b"A number should have been here; I inserted `0\'.\x00" as *const u8
                    as *const i8;
                help_line[1] = b"(If you can\'t figure out why I needed to see a number,\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"look up `weird error\' in the index to The TeXbook.)\x00"
                    as *const u8 as *const i8;
                back_error();
                cur_val = 0i32;
                cur_val_level = 1_u8
            } else if cur_cmd as i32 <= 73i32 {
                if (cur_cmd as i32) < 73i32 {
                    if m == 0i32 {
                        scan_register_num();
                        if cur_val < 256i32 {
                            cur_val = (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + cur_val) as isize,
                            ))
                            .b32
                            .s1
                        } else {
                            find_sa_element(5i32 as small_number, cur_val, false);
                            if cur_ptr == -0xfffffffi32 {
                                cur_val = -0xfffffffi32
                            } else {
                                cur_val = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                            }
                        }
                    } else {
                        cur_val = (*mem.offset((m + 1i32) as isize)).b32.s1
                    }
                } else if cur_chr
                    == 1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 11i32
                {
                    scan_char_class_not_ignored();
                    cur_ptr = cur_val;
                    scan_char_class_not_ignored();
                    find_sa_element(6i32 as small_number, cur_ptr * 4096i32 + cur_val, false);
                    if cur_ptr == -0xfffffffi32 {
                        cur_val = -0xfffffffi32
                    } else {
                        cur_val = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                    }
                } else {
                    cur_val = (*eqtb.offset(m as isize)).b32.s1
                }
                cur_val_level = 5_u8
            } else {
                back_input();
                scan_font_ident();
                cur_val = 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + cur_val;
                cur_val_level = 4_u8
            }
        }
        74 => {
            cur_val = (*eqtb.offset(m as isize)).b32.s1;
            cur_val_level = 0_u8
        }
        75 => {
            cur_val = (*eqtb.offset(m as isize)).b32.s1;
            cur_val_level = 1_u8
        }
        76 => {
            cur_val = (*eqtb.offset(m as isize)).b32.s1;
            cur_val_level = 2_u8
        }
        77 => {
            cur_val = (*eqtb.offset(m as isize)).b32.s1;
            cur_val_level = 3_u8
        }
        80 => {
            if (cur_list.mode as i32).abs() != m {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Improper \x00" as *const u8 as *const i8);
                print_cmd_chr(80_u16, m);
                help_ptr = 4_u8;
                help_line[3] = b"You can refer to \\spacefactor only in horizontal mode;\x00"
                    as *const u8 as *const i8;
                help_line[2] = b"you can refer to \\prevdepth only in vertical mode; and\x00"
                    as *const u8 as *const i8;
                help_line[1] = b"neither of these is meaningful inside \\write. So\x00" as *const u8
                    as *const i8;
                help_line[0] = b"I\'m forgetting what you said and using zero instead.\x00"
                    as *const u8 as *const i8;
                error();
                if level as i32 != 5i32 {
                    cur_val = 0i32;
                    cur_val_level = 1_u8
                } else {
                    cur_val = 0i32;
                    cur_val_level = 0_u8
                }
            } else if m == 1i32 {
                cur_val = cur_list.aux.b32.s1;
                cur_val_level = 1_u8
            } else {
                cur_val = cur_list.aux.b32.s0;
                cur_val_level = 0_u8
            }
        }
        81 => {
            if cur_list.mode as i32 == 0i32 {
                cur_val = 0i32;
                cur_val_level = 0_u8
            } else {
                *nest.offset(nest_ptr as isize) = cur_list;
                p = nest_ptr;
                while ((*nest.offset(p as isize)).mode as i32).abs() != 1i32 {
                    p -= 1
                }
                cur_val = (*nest.offset(p as isize)).prev_graf;
                cur_val_level = 0_u8
            }
        }
        83 => {
            if m == 0i32 {
                cur_val = dead_cycles
            } else if m == 2i32 {
                cur_val = interaction as i32
            } else {
                cur_val = insert_penalties
            }
            cur_val_level = 0_u8
        }
        82 => {
            if page_contents as i32 == 0i32 && !output_active {
                if m == 0i32 {
                    cur_val = 0x3fffffffi32
                } else {
                    cur_val = 0i32
                }
            } else {
                cur_val = page_so_far[m as usize]
            }
            cur_val_level = 1_u8
        }
        85 => {
            if m > 1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 0i32
            {
                /*1654:*/
                scan_int();
                if (*eqtb.offset(m as isize)).b32.s1 == -0xfffffffi32 || cur_val < 0i32 {
                    cur_val = 0i32
                } else {
                    if cur_val
                        > (*mem.offset(((*eqtb.offset(m as isize)).b32.s1 + 1i32) as isize))
                            .b32
                            .s1
                    {
                        cur_val = (*mem.offset(((*eqtb.offset(m as isize)).b32.s1 + 1i32) as isize))
                            .b32
                            .s1
                    }
                    cur_val = (*mem
                        .offset(((*eqtb.offset(m as isize)).b32.s1 + cur_val + 1i32) as isize))
                    .b32
                    .s1
                }
            } else if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 0i32) as isize,
            ))
            .b32
            .s1 == -0xfffffffi32
            {
                cur_val = 0i32
            } else {
                cur_val = (*mem.offset(
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 0i32) as isize,
                    ))
                    .b32
                    .s1 as isize,
                ))
                .b32
                .s0
            }
            cur_val_level = 0_u8
        }
        84 => {
            scan_register_num();
            if cur_val < 256i32 {
                q = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr == -0xfffffffi32 {
                    q = -0xfffffffi32
                } else {
                    q = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                }
            }
            if q == -0xfffffffi32 {
                cur_val = 0i32
            } else {
                cur_val = (*mem.offset((q + m) as isize)).b32.s1
            }
            cur_val_level = 1_u8
        }
        68 | 69 => {
            cur_val = cur_chr;
            cur_val_level = 0_u8
        }
        78 => {
            find_font_dimen(false);
            (*font_info.offset(fmem_ptr as isize)).b32.s1 = 0i32;
            cur_val = (*font_info.offset(cur_val as isize)).b32.s1;
            cur_val_level = 1_u8
        }
        79 => {
            scan_font_ident();
            if m == 0i32 {
                cur_val = *hyphen_char.offset(cur_val as isize);
                cur_val_level = 0_u8
            } else if m == 1i32 {
                cur_val = *skew_char.offset(cur_val as isize);
                cur_val_level = 0_u8
            } else {
                n = cur_val;
                if font_area[n as usize] as u32 == 0xffffu32
                    || font_area[n as usize] as u32 == 0xfffeu32
                {
                    scan_glyph_number(n);
                } else {
                    scan_char_num();
                }
                k = cur_val;
                match m {
                    2 => {
                        cur_val = get_cp_code(n, k as u32, 0i32);
                        cur_val_level = 0_u8
                    }
                    3 => {
                        cur_val = get_cp_code(n, k as u32, 1i32);
                        cur_val_level = 0_u8
                    }
                    _ => {}
                }
            }
        }
        91 => {
            if m < 0i32 || m > 19i32 {
                /* 19 = "lo_mem_stat_max" */
                cur_val_level = ((*mem.offset(m as isize)).b16.s1 as i32 / 64i32) as u8;
                if (cur_val_level as i32) < 2i32 {
                    cur_val = (*mem.offset((m + 2i32) as isize)).b32.s1
                } else {
                    cur_val = (*mem.offset((m + 1i32) as isize)).b32.s1
                }
            } else {
                scan_register_num();
                cur_val_level = m as u8;
                if cur_val > 255i32 {
                    find_sa_element(cur_val_level as small_number, cur_val, false);
                    if cur_ptr == -0xfffffffi32 {
                        cur_val = 0i32
                    } else if (cur_val_level as i32) < 2i32 {
                        cur_val = (*mem.offset((cur_ptr + 2i32) as isize)).b32.s1
                    } else {
                        cur_val = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                    }
                } else {
                    match cur_val_level as i32 {
                        0 => {
                            cur_val = (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 85i32
                                    + cur_val) as isize,
                            ))
                            .b32
                            .s1
                        }
                        1 => {
                            cur_val = (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 85i32
                                    + 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + 23i32
                                    + cur_val) as isize,
                            ))
                            .b32
                            .s1
                        }
                        2 => {
                            cur_val = (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + cur_val) as isize,
                            ))
                            .b32
                            .s1
                        }
                        3 => {
                            cur_val = (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + cur_val) as isize,
                            ))
                            .b32
                            .s1
                        }
                        _ => {}
                    }
                }
            }
        }
        71 => {
            if m >= 4i32 {
                if m >= 57i32 {
                    /*1568:*/
                    if m < 58i32 {
                        match m {
                            57 => {
                                /*1595:*/
                                scan_mu_glue();
                            }
                            _ => {}
                        }
                        cur_val_level = 2_u8
                    } else if m < 59i32 {
                        match m {
                            58 => {
                                /*1596:*/
                                scan_normal_glue(); /* if(m >= XETEX_DIM) */
                            }
                            _ => {}
                        }
                        cur_val_level = 3_u8
                    } else {
                        cur_val_level = (m - 59i32) as u8;
                        scan_expr();
                    }
                    while cur_val_level as i32 > level as i32 {
                        if cur_val_level as i32 == 2i32 {
                            m = cur_val;
                            cur_val = (*mem.offset((m + 1i32) as isize)).b32.s1;
                            delete_glue_ref(m);
                        } else if cur_val_level as i32 == 3i32 {
                            mu_error();
                        }
                        cur_val_level = cur_val_level.wrapping_sub(1)
                    }
                    if negative {
                        if cur_val_level as i32 >= 2i32 {
                            m = cur_val;
                            cur_val = new_spec(m);
                            delete_glue_ref(m);
                            (*mem.offset((cur_val + 1i32) as isize)).b32.s1 =
                                -(*mem.offset((cur_val + 1i32) as isize)).b32.s1;
                            (*mem.offset((cur_val + 2i32) as isize)).b32.s1 =
                                -(*mem.offset((cur_val + 2i32) as isize)).b32.s1;
                            (*mem.offset((cur_val + 3i32) as isize)).b32.s1 =
                                -(*mem.offset((cur_val + 3i32) as isize)).b32.s1
                        } else {
                            cur_val = -cur_val
                        }
                    }
                    return;
                }
                if m >= 47i32 {
                    match m {
                        47 => {
                            /*1435:*/
                            if font_area[
                                (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32) as isize,
                                ))
                                .b32
                                .s1 as usize] as u32 == 0xffffu32
                                || font_area[
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1 as usize] as u32 == 0xfffeu32
                            {
                                scan_int(); /* shellenabledp */
                                n = cur_val;
                                if n < 1i32 || n > 4i32 {
                                    if file_line_error_style_p != 0 {
                                        print_file_line();
                                    } else {
                                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                    }
                                    print_cstr(b"\\\\XeTeXglyphbounds requires an edge index from 1 to 4;\x00"
                                                   as *const u8 as
                                                   *const i8);
                                    print_nl_cstr(
                                        b"I don\'t know anything about edge \x00" as *const u8
                                            as *const i8,
                                    );
                                    print_int(n);
                                    error();
                                    cur_val = 0i32
                                } else {
                                    scan_int();
                                    cur_val = get_glyph_bounds(
                                        (*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 13i32
                                                + 256i32
                                                + 4i32
                                                + 256i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1,
                                        n,
                                        cur_val,
                                    )
                                }
                            } else {
                                not_native_font_error(
                                    71i32,
                                    m,
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                );
                                cur_val = 0i32
                            }
                        }
                        48 | 49 | 50 | 51 => {
                            scan_font_ident();
                            q = cur_val;
                            scan_usv_num();
                            if font_area[q as usize] as u32 == 0xffffu32
                                || font_area[q as usize] as u32 == 0xfffeu32
                            {
                                match m {
                                    48 => cur_val = getnativecharwd(q, cur_val),
                                    49 => cur_val = getnativecharht(q, cur_val),
                                    50 => cur_val = getnativechardp(q, cur_val),
                                    51 => cur_val = getnativecharic(q, cur_val),
                                    _ => {}
                                }
                            } else if *font_bc.offset(q as isize) as i32 <= cur_val
                                && *font_ec.offset(q as isize) as i32 >= cur_val
                            {
                                i = (*font_info.offset(
                                    (*char_base.offset(q as isize)
                                        + effective_char(1i32 != 0, q, cur_val as u16))
                                        as isize,
                                ))
                                .b16;
                                match m {
                                    48 => {
                                        cur_val = (*font_info.offset(
                                            (*width_base.offset(q as isize) + i.s3 as i32) as isize,
                                        ))
                                        .b32
                                        .s1
                                    }
                                    49 => {
                                        cur_val = (*font_info.offset(
                                            (*height_base.offset(q as isize) + i.s2 as i32 / 16i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1
                                    }
                                    50 => {
                                        cur_val = (*font_info.offset(
                                            (*depth_base.offset(q as isize) + i.s2 as i32 % 16i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1
                                    }
                                    51 => {
                                        cur_val = (*font_info.offset(
                                            (*italic_base.offset(q as isize) + i.s1 as i32 / 4i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1
                                    }
                                    _ => {}
                                }
                            } else {
                                cur_val = 0i32
                            }
                        }
                        52 | 53 | 54 => {
                            q = cur_chr - 52i32;
                            scan_int();
                            if (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 0i32) as isize,
                            ))
                            .b32
                            .s1 == -0xfffffffi32
                                || cur_val <= 0i32
                            {
                                cur_val = 0i32
                            } else {
                                if q == 2i32 {
                                    q = cur_val % 2i32;
                                    cur_val = (cur_val + q) / 2i32
                                }
                                if cur_val
                                    > (*mem.offset(
                                        (*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 0i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1 as isize,
                                    ))
                                    .b32
                                    .s0
                                {
                                    cur_val = (*mem.offset(
                                        (*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 0i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1 as isize,
                                    ))
                                    .b32
                                    .s0
                                }
                                cur_val = (*mem.offset(
                                    ((*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 0i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1 + 2i32 * cur_val
                                        - q) as isize,
                                ))
                                .b32
                                .s1
                            }
                            cur_val_level = 1_u8
                        }
                        55 | 56 => {
                            scan_normal_glue();
                            q = cur_val;
                            if m == 55i32 {
                                cur_val = (*mem.offset((q + 2i32) as isize)).b32.s1
                            } else {
                                cur_val = (*mem.offset((q + 3i32) as isize)).b32.s1
                            }
                            delete_glue_ref(q);
                        }
                        _ => {}
                    }
                    cur_val_level = 1_u8
                } else {
                    match m {
                        4 => cur_val = line,
                        5 => cur_val = last_badness,
                        45 => cur_val = 0i32,
                        6 => cur_val = 2i32,
                        14 => cur_val = 0i32,
                        15 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    cur_val = aat::aat_font_get(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                    )
                                }
                                0xfffeu32 => {
                                    cur_val = ot_font_get(
                                        m - 14i32,
                                        *font_layout_engine.offset(n as isize),
                                    )
                                }
                                _ => cur_val = 0i32,
                            }
                        }
                        22 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    cur_val = aat::aat_font_get(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                    )
                                }
                                #[cfg(not(target_os = "macos"))]
                                0xffffu32 => {
                                    cur_val = -1;
                                }
                                0xfffeu32 => {
                                    if usingGraphite(
                                        *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                    ) as i32
                                        != 0
                                    {
                                        cur_val = ot_font_get(
                                            m - 14i32,
                                            *font_layout_engine.offset(n as isize),
                                        );
                                    } else {
                                        cur_val = 0;
                                    }
                                }
                                _ => {
                                    cur_val = 0;
                                }
                            }
                        }
                        17 | 19 | 20 | 21 | 16 => {
                            scan_font_ident();
                            n = cur_val;
                            cur_val = 0i32
                        }
                        23 | 25 | 26 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    scan_int();
                                    k = cur_val;
                                    cur_val = aat::aat_font_get_1(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                        k,
                                    )
                                }
                                #[cfg(not(target_os = "macos"))]
                                0xffffu32 => {
                                    scan_int();
                                    k = cur_val;
                                    cur_val = -1;
                                }
                                0xfffeu32 => {
                                    if usingGraphite(
                                        *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                    ) as i32
                                        != 0
                                    {
                                        scan_int();
                                        k = cur_val;
                                        cur_val = ot_font_get_1(
                                            m - 14i32,
                                            *font_layout_engine.offset(n as isize),
                                            k,
                                        )
                                    } else {
                                        not_aat_gr_font_error(71i32, m, n);
                                        cur_val = -1i32
                                    }
                                }
                                _ => {
                                    not_aat_gr_font_error(71i32, m, n);
                                    cur_val = -1i32
                                }
                            }
                        }
                        27 | 29 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    scan_int();
                                    k = cur_val;
                                    scan_int();
                                    cur_val = aat::aat_font_get_2(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                        k,
                                        cur_val,
                                    )
                                }
                                #[cfg(not(target_os = "macos"))]
                                0xffffu32 => {
                                    scan_int();
                                    k = cur_val;
                                    scan_int();
                                    cur_val = -1;
                                }
                                0xfffeu32 => {
                                    if usingGraphite(
                                        *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                    ) as i32
                                        != 0
                                    {
                                        scan_int();
                                        k = cur_val;
                                        scan_int();
                                        cur_val = ot_font_get_2(
                                            m - 14i32,
                                            *font_layout_engine.offset(n as isize),
                                            k,
                                            cur_val,
                                        )
                                    } else {
                                        not_aat_gr_font_error(71i32, m, n);
                                        cur_val = -1i32
                                    }
                                }
                                _ => {
                                    not_aat_gr_font_error(71i32, m, n);
                                    cur_val = -1i32
                                }
                            }
                        }
                        18 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    scan_and_pack_name();
                                    cur_val = aat::aat_font_get_named(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                    );
                                }
                                #[cfg(not(target_os = "macos"))]
                                0xffffu32 => {
                                    scan_and_pack_name();
                                    cur_val = -1;
                                }
                                _ => {
                                    not_aat_font_error(71i32, m, n);
                                    cur_val = -1i32
                                }
                            }
                        }
                        24 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    scan_and_pack_name();
                                    cur_val = aat::aat_font_get_named(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                    );
                                }
                                #[cfg(not(target_os = "macos"))]
                                0xffffu32 => {
                                    scan_and_pack_name();
                                    cur_val = -1;
                                }
                                0xfffeu32 => {
                                    if usingGraphite(
                                        *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                    ) as i32
                                        != 0
                                    {
                                        scan_and_pack_name();
                                        cur_val = gr_font_get_named(
                                            m - 14i32,
                                            *font_layout_engine.offset(n as isize),
                                        )
                                    } else {
                                        not_aat_gr_font_error(71i32, m, n);
                                        cur_val = -1i32
                                    }
                                }
                                _ => {
                                    not_aat_gr_font_error(71i32, m, n);
                                    cur_val = -1i32
                                }
                            }
                        }
                        28 => {
                            scan_font_ident();
                            n = cur_val;
                            match font_area[n as usize] as u32 {
                                #[cfg(target_os = "macos")]
                                0xffffu32 => {
                                    scan_int();
                                    k = cur_val;
                                    scan_and_pack_name();
                                    cur_val = aat::aat_font_get_named_1(
                                        m - 14i32,
                                        (*font_layout_engine.offset(n as isize)) as _,
                                        k,
                                    );
                                }
                                #[cfg(not(target_os = "macos"))]
                                0xffffu32 => {
                                    scan_int();
                                    k = cur_val;
                                    scan_and_pack_name();
                                    cur_val = -1;
                                }
                                0xfffeu32 => {
                                    if usingGraphite(
                                        *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                    ) as i32
                                        != 0
                                    {
                                        scan_int();
                                        k = cur_val;
                                        scan_and_pack_name();
                                        cur_val = gr_font_get_named_1(
                                            m - 14i32,
                                            *font_layout_engine.offset(n as isize),
                                            k,
                                        )
                                    } else {
                                        not_aat_gr_font_error(71i32, m, n);
                                        cur_val = -1i32
                                    }
                                }
                                _ => {
                                    not_aat_gr_font_error(71i32, m, n);
                                    cur_val = -1i32
                                }
                            }
                        }
                        30 => {
                            scan_font_ident();
                            n = cur_val;
                            if font_area[n as usize] as u32 == 0xfffeu32
                                && usingOpenType(
                                    *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                ) as i32
                                    != 0
                            {
                                cur_val =
                                    ot_font_get(m - 14i32, *font_layout_engine.offset(n as isize))
                            } else {
                                cur_val = 0i32
                            }
                        }
                        31 | 33 => {
                            scan_font_ident();
                            n = cur_val;
                            if font_area[n as usize] as u32 == 0xfffeu32
                                && usingOpenType(
                                    *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                ) as i32
                                    != 0
                            {
                                scan_int();
                                cur_val = ot_font_get_1(
                                    m - 14i32,
                                    *font_layout_engine.offset(n as isize),
                                    cur_val,
                                )
                            } else {
                                not_ot_font_error(71i32, m, n);
                                cur_val = -1i32
                            }
                        }
                        32 | 34 => {
                            scan_font_ident();
                            n = cur_val;
                            if font_area[n as usize] as u32 == 0xfffeu32
                                && usingOpenType(
                                    *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                ) as i32
                                    != 0
                            {
                                scan_int();
                                k = cur_val;
                                scan_int();
                                cur_val = ot_font_get_2(
                                    m - 14i32,
                                    *font_layout_engine.offset(n as isize),
                                    k,
                                    cur_val,
                                )
                            } else {
                                not_ot_font_error(71i32, m, n);
                                cur_val = -1i32
                            }
                        }
                        35 => {
                            scan_font_ident();
                            n = cur_val;
                            if font_area[n as usize] as u32 == 0xfffeu32
                                && usingOpenType(
                                    *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                ) as i32
                                    != 0
                            {
                                scan_int();
                                k = cur_val;
                                scan_int();
                                kk = cur_val;
                                scan_int();
                                cur_val = ot_font_get_3(
                                    m - 14i32,
                                    *font_layout_engine.offset(n as isize),
                                    k,
                                    kk,
                                    cur_val,
                                )
                            } else {
                                not_ot_font_error(71i32, m, n);
                                cur_val = -1i32
                            }
                        }
                        36 => {
                            if font_area[
                                (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32) as isize,
                                ))
                                .b32
                                .s1 as usize] as u32 == 0xffffu32
                                || font_area[
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1 as usize] as u32 == 0xfffeu32
                            {
                                scan_int();
                                n = cur_val;
                                cur_val = map_char_to_glyph(
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                    n,
                                )
                            } else {
                                not_native_font_error(
                                    71i32,
                                    m,
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                );
                                cur_val = 0i32
                            }
                        }
                        37 => {
                            if font_area[
                                (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32) as isize,
                                ))
                                .b32
                                .s1 as usize] as u32 == 0xffffu32
                                || font_area[
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1 as usize] as u32 == 0xfffeu32
                            {
                                scan_and_pack_name();
                                cur_val = map_glyph_to_index(
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                )
                            } else {
                                not_native_font_error(
                                    71i32,
                                    m,
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                );
                                cur_val = 0i32
                            }
                        }
                        38 => {
                            scan_font_ident();
                            n = cur_val;
                            if font_area[n as usize] as u32 == 0xffffu32 {
                                cur_val = 1i32
                            } else if font_area[n as usize] as u32 == 0xfffeu32
                                && usingOpenType(
                                    *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                ) as i32
                                    != 0
                            {
                                cur_val = 2i32
                            } else if font_area[n as usize] as u32 == 0xfffeu32
                                && usingGraphite(
                                    *font_layout_engine.offset(n as isize) as XeTeXLayoutEngine
                                ) as i32
                                    != 0
                            {
                                cur_val = 3i32
                            } else {
                                cur_val = 0i32
                            }
                        }
                        39 | 40 => {
                            scan_font_ident();
                            n = cur_val;
                            if font_area[n as usize] as u32 == 0xffffu32
                                || font_area[n as usize] as u32 == 0xfffeu32
                            {
                                cur_val = get_font_char_range(n, (m == 39i32) as i32)
                            } else if m == 39i32 {
                                cur_val = *font_bc.offset(n as isize) as i32
                            } else {
                                cur_val = *font_ec.offset(n as isize) as i32
                            }
                        }
                        41 => cur_val = pdf_last_x_pos,
                        42 => cur_val = pdf_last_y_pos,
                        46 => {
                            scan_and_pack_name();
                            cur_val = count_pdf_file_pages()
                        }
                        7 => cur_val = cur_level as i32 - 1i32,
                        8 => cur_val = cur_group as i32,
                        9 => {
                            q = cond_ptr;
                            cur_val = 0i32;
                            while q != -0xfffffffi32 {
                                cur_val += 1;
                                q = (*mem.offset(q as isize)).b32.s1
                            }
                        }
                        10 => {
                            if cond_ptr == -0xfffffffi32 {
                                cur_val = 0i32
                            } else if (cur_if as i32) < 32i32 {
                                cur_val = cur_if as i32 + 1i32
                            } else {
                                cur_val = -(cur_if as i32 - 31i32)
                            }
                        }
                        11 => {
                            if if_limit as i32 == 4i32 || if_limit as i32 == 3i32 {
                                cur_val = 1i32
                            } else if if_limit as i32 == 2i32 {
                                cur_val = -1i32
                            } else {
                                cur_val = 0i32
                            }
                        }
                        12 | 13 => {
                            scan_normal_glue();
                            q = cur_val;
                            if m == 12i32 {
                                cur_val = (*mem.offset(q as isize)).b16.s1 as i32
                            } else {
                                cur_val = (*mem.offset(q as isize)).b16.s0 as i32
                            }
                            delete_glue_ref(q);
                        }
                        _ => {}
                    }
                    cur_val_level = 0_u8
                }
            } else {
                cur_val = 0i32;
                tx = cur_list.tail;
                if tx < hi_mem_min {
                    if (*mem.offset(tx as isize)).b16.s1 as i32 == 9i32
                        && (*mem.offset(tx as isize)).b16.s0 as i32 == 3i32
                    {
                        r = cur_list.head;
                        loop {
                            q = r;
                            r = (*mem.offset(q as isize)).b32.s1;
                            if !(r != tx) {
                                break;
                            }
                        }
                        tx = q
                    }
                }
                if cur_chr == 3i32 {
                    cur_val_level = 0_u8;
                    if tx == cur_list.head || cur_list.mode as i32 == 0i32 {
                        cur_val = -1i32
                    }
                } else {
                    cur_val_level = cur_chr as u8
                }
                if tx < hi_mem_min && cur_list.mode as i32 != 0i32 {
                    match cur_chr {
                        0 => {
                            if (*mem.offset(tx as isize)).b16.s1 as i32 == 12i32 {
                                cur_val = (*mem.offset((tx + 1i32) as isize)).b32.s1
                            }
                        }
                        1 => {
                            if (*mem.offset(tx as isize)).b16.s1 as i32 == 11i32 {
                                cur_val = (*mem.offset((tx + 1i32) as isize)).b32.s1
                            }
                        }
                        2 => {
                            if (*mem.offset(tx as isize)).b16.s1 as i32 == 10i32 {
                                cur_val = (*mem.offset((tx + 1i32) as isize)).b32.s0;
                                if (*mem.offset(tx as isize)).b16.s0 as i32 == 99i32 {
                                    cur_val_level = 3_u8
                                }
                            }
                        }
                        3 => {
                            if (*mem.offset(tx as isize)).b16.s1 as i32 <= 13i32 {
                                cur_val = (*mem.offset(tx as isize)).b16.s1 as i32 + 1i32
                            } else {
                                cur_val = 13i32 + 2i32
                            }
                        }
                        _ => {}
                    }
                } else if cur_list.mode as i32 == 1i32 && tx == cur_list.head {
                    match cur_chr {
                        0 => cur_val = last_penalty,
                        1 => cur_val = last_kern,
                        2 => {
                            if last_glue != 0x3fffffffi32 {
                                cur_val = last_glue
                            }
                        }
                        3 => cur_val = last_node_type,
                        _ => {}
                    }
                }
            }
        }
        _ => {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"You can\'t use `\x00" as *const u8 as *const i8);
            print_cmd_chr(cur_cmd as u16, cur_chr);
            print_cstr(b"\' after \x00" as *const u8 as *const i8);
            print_esc_cstr(b"the\x00" as *const u8 as *const i8);
            help_ptr = 1_u8;
            help_line[0] = b"I\'m forgetting what you said and using zero instead.\x00" as *const u8
                as *const i8;
            error();
            cur_val = 0i32;
            if level as i32 != 5i32 {
                cur_val_level = 1_u8
            } else {
                cur_val_level = 0_u8
            }
        }
    }
    while cur_val_level as i32 > level as i32 {
        /*447:*/
        if cur_val_level as i32 == 2i32 {
            cur_val = (*mem.offset((cur_val + 1i32) as isize)).b32.s1
        } else if cur_val_level as i32 == 3i32 {
            mu_error();
        }
        cur_val_level = cur_val_level.wrapping_sub(1)
    }
    if negative {
        if cur_val_level as i32 >= 2i32 {
            cur_val = new_spec(cur_val);
            (*mem.offset((cur_val + 1i32) as isize)).b32.s1 =
                -(*mem.offset((cur_val + 1i32) as isize)).b32.s1;
            (*mem.offset((cur_val + 2i32) as isize)).b32.s1 =
                -(*mem.offset((cur_val + 2i32) as isize)).b32.s1;
            (*mem.offset((cur_val + 3i32) as isize)).b32.s1 =
                -(*mem.offset((cur_val + 3i32) as isize)).b32.s1
        } else {
            cur_val = -cur_val
        }
    } else if cur_val_level as i32 >= 2i32 && cur_val_level as i32 <= 3i32 {
        let ref mut fresh35 = (*mem.offset(cur_val as isize)).b32.s1;
        *fresh35 += 1
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_int() {
    let mut negative: bool = false;
    let mut m: i32 = 0;
    let mut d: small_number = 0;
    let mut vacuous: bool = false;
    let mut OK_so_far: bool = false;
    radix = 0i32 as small_number;
    OK_so_far = true;
    negative = false;
    loop {
        loop
        /*424:*/
        {
            get_x_token();
            if !(cur_cmd as i32 == 10i32) {
                break;
            }
        }
        if cur_tok == 0x1800000i32 + '-' as i32 {
            negative = !negative;
            cur_tok = 0x1800000i32 + '+' as i32
        }
        if !(cur_tok == 0x1800000i32 + '+' as i32) {
            break;
        }
    }
    if cur_tok == 0x1800000i32 + '`' as i32 {
        /*460:*/
        get_token(); /*461:*/
        if cur_tok < 0x1ffffffi32 {
            cur_val = cur_chr; /*462:*/
            if cur_cmd as i32 <= 2i32 {
                if cur_cmd as i32 == 2i32 {
                    align_state += 1
                } else {
                    align_state -= 1
                }
            }
        } else if cur_tok < 0x1ffffffi32 + (1i32 + (0x10ffffi32 + 1i32)) {
            cur_val = cur_tok - (0x1ffffffi32 + 1i32)
        } else {
            cur_val = cur_tok - (0x1ffffffi32 + (1i32 + (0x10ffffi32 + 1i32)))
        } /*:463*/
        if cur_val > 0x10ffffi32 {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Improper alphabetic constant\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] = b"A one-character control sequence belongs after a ` mark.\x00"
                as *const u8 as *const i8;
            help_line[0] = b"So I\'m essentially inserting \\0 here.\x00" as *const u8 as *const i8;
            cur_val = '0' as i32;
            back_error();
        } else {
            get_x_token();
            if cur_cmd as i32 != 10i32 {
                back_input();
            }
        }
    } else if cur_cmd as i32 >= 68i32 && cur_cmd as i32 <= 91i32 {
        scan_something_internal(0i32 as small_number, false);
    } else {
        radix = 10i32 as small_number;
        m = 0xccccccci32;
        if cur_tok == 0x1800000i32 + '\'' as i32 {
            radix = 8i32 as small_number;
            m = 0x10000000i32;
            get_x_token();
        } else if cur_tok == 0x1800000i32 + '\"' as i32 {
            radix = 16i32 as small_number;
            m = 0x8000000i32;
            get_x_token();
        }
        vacuous = true;
        cur_val = 0i32;
        loop {
            if cur_tok < 0x1800000i32 + '0' as i32 + radix as i32
                && cur_tok >= 0x1800000i32 + '0' as i32
                && cur_tok <= 0x1800000i32 + '0' as i32 + 9i32
            {
                d = (cur_tok - (0x1800000i32 + '0' as i32)) as small_number
            } else {
                if !(radix as i32 == 16i32) {
                    break;
                }
                if cur_tok <= 0x1600000i32 + 'A' as i32 + 5i32
                    && cur_tok >= 0x1600000i32 + 'A' as i32
                {
                    d = (cur_tok - (0x1600000i32 + 'A' as i32) + 10i32) as small_number
                } else {
                    if !(cur_tok <= 0x1800000i32 + 'A' as i32 + 5i32
                        && cur_tok >= 0x1800000i32 + 'A' as i32)
                    {
                        break;
                    }
                    d = (cur_tok - (0x1800000i32 + 'A' as i32) + 10i32) as small_number
                }
            }
            vacuous = false;
            if cur_val >= m && (cur_val > m || d as i32 > 7i32 || radix as i32 != 10i32) {
                if OK_so_far {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Number too big\x00" as *const u8 as *const i8);
                    help_ptr = 2_u8;
                    help_line[1] = b"I can only go up to 2147483647=\'17777777777=\"7FFFFFFF,\x00"
                        as *const u8 as *const i8;
                    help_line[0] = b"so I\'m using that number instead of yours.\x00" as *const u8
                        as *const i8;
                    error();
                    cur_val = 0x7fffffffi32;
                    OK_so_far = false
                }
            } else {
                cur_val = cur_val * radix as i32 + d as i32
            }
            get_x_token();
        }
        if vacuous {
            /*464:*/
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Missing number, treated as zero\x00" as *const u8 as *const i8);
            help_ptr = 3_u8;
            help_line[2] =
                b"A number should have been here; I inserted `0\'.\x00" as *const u8 as *const i8;
            help_line[1] = b"(If you can\'t figure out why I needed to see a number,\x00"
                as *const u8 as *const i8;
            help_line[0] = b"look up `weird error\' in the index to The TeXbook.)\x00" as *const u8
                as *const i8;
            back_error();
        } else if cur_cmd as i32 != 10i32 {
            back_input();
        }
    }
    if negative {
        cur_val = -cur_val
    };
}
unsafe extern "C" fn round_decimals(mut k: small_number) -> scaled_t {
    let mut a: i32 = 0i32;
    while k as i32 > 0i32 {
        k -= 1;
        a = (a + dig[k as usize] as i32 * 0x20000i32) / 10i32
    }
    (a + 1i32) / 2i32
}
#[no_mangle]
pub unsafe extern "C" fn xetex_scan_dimen(
    mut mu: bool,
    mut inf: bool,
    mut shortcut: bool,
    mut requires_units: bool,
) {
    let mut current_block: u64;
    let mut negative: bool = false;
    let mut f: i32 = 0;
    let mut num: i32 = 0;
    let mut denom: i32 = 0;
    let mut k: small_number = 0;
    let mut kk: small_number = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut v: scaled_t = 0;
    let mut save_cur_val: i32 = 0;
    f = 0i32;
    arith_error = false;
    cur_order = 0i32 as glue_ord;
    negative = false;
    if !shortcut {
        negative = false;
        loop {
            loop {
                get_x_token();
                if !(cur_cmd as i32 == 10i32) {
                    break;
                }
            }
            if cur_tok == 0x1800000i32 + '-' as i32 {
                negative = !negative;
                cur_tok = 0x1800000i32 + '+' as i32
            }
            if !(cur_tok == 0x1800000i32 + '+' as i32) {
                break;
            }
        }
        if cur_cmd as i32 >= 68i32 && cur_cmd as i32 <= 91i32 {
            /*468:*/
            if mu {
                scan_something_internal(3i32 as small_number, false);
                if cur_val_level as i32 >= 2i32 {
                    v = (*mem.offset((cur_val + 1i32) as isize)).b32.s1;
                    delete_glue_ref(cur_val);
                    cur_val = v
                }
                if cur_val_level as i32 == 3i32 {
                    current_block = 16246449912548656671;
                } else {
                    if cur_val_level as i32 != 0i32 {
                        mu_error();
                    }
                    current_block = 5028470053297453708;
                }
            } else {
                scan_something_internal(1i32 as small_number, false);
                if cur_val_level as i32 == 1i32 {
                    current_block = 16246449912548656671;
                } else {
                    current_block = 5028470053297453708;
                }
            }
        } else {
            back_input();
            if cur_tok == 0x1800000i32 + ',' as i32 {
                cur_tok = 0x1800000i32 + '.' as i32
            }
            if cur_tok != 0x1800000i32 + '.' as i32 {
                scan_int();
            } else {
                radix = 10i32 as small_number;
                cur_val = 0i32
            }
            if cur_tok == 0x1800000i32 + ',' as i32 {
                cur_tok = 0x1800000i32 + '.' as i32
            }
            if radix as i32 == 10i32 && cur_tok == 0x1800000i32 + '.' as i32 {
                /*471:*/
                k = 0i32 as small_number; /* if(requires_units) */
                p = -0xfffffffi32;
                get_token();
                loop {
                    get_x_token();
                    if cur_tok > 0x1800000i32 + '0' as i32 + 9i32
                        || cur_tok < 0x1800000i32 + '0' as i32
                    {
                        break;
                    }
                    if (k as i32) < 17i32 {
                        q = get_avail();
                        (*mem.offset(q as isize)).b32.s1 = p;
                        (*mem.offset(q as isize)).b32.s0 = cur_tok - (0x1800000i32 + '0' as i32);
                        p = q;
                        k += 1
                    }
                }
                kk = k;
                while kk as i32 >= 1i32 {
                    dig[(kk as i32 - 1i32) as usize] = (*mem.offset(p as isize)).b32.s0 as u8;
                    q = p;
                    p = (*mem.offset(p as isize)).b32.s1;
                    (*mem.offset(q as isize)).b32.s1 = avail;
                    avail = q;
                    kk -= 1
                }
                f = round_decimals(k);
                if cur_cmd as i32 != 10i32 {
                    back_input();
                }
            }
            current_block = 5028470053297453708;
        }
    } else {
        current_block = 5028470053297453708;
    }
    match current_block {
        5028470053297453708 => {
            if cur_val < 0i32 {
                negative = !negative;
                cur_val = -cur_val
            }
            if requires_units {
                if inf {
                    /*473:*/
                    if scan_keyword(b"fil\x00" as *const u8 as *const i8) {
                        cur_order = 1i32 as glue_ord;
                        while scan_keyword(b"l\x00" as *const u8 as *const i8) {
                            if cur_order as i32 == 3i32 {
                                if file_line_error_style_p != 0 {
                                    print_file_line();
                                } else {
                                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                }
                                print_cstr(
                                    b"Illegal unit of measure (\x00" as *const u8 as *const i8,
                                );
                                print_cstr(b"replaced by filll)\x00" as *const u8 as *const i8);
                                help_ptr = 1_u8;
                                help_line[0] = b"I dddon\'t go any higher than filll.\x00"
                                    as *const u8
                                    as *const i8;
                                error();
                            } else {
                                cur_order = cur_order.wrapping_add(1)
                            }
                        }
                        current_block = 6063453238281986051;
                    } else {
                        current_block = 2750570471926810434;
                    }
                } else {
                    current_block = 2750570471926810434;
                }
                match current_block {
                    2750570471926810434 => {
                        save_cur_val = cur_val;
                        loop {
                            get_x_token();
                            if !(cur_cmd as i32 == 10i32) {
                                break;
                            }
                        }
                        if (cur_cmd as i32) < 68i32 || cur_cmd as i32 > 91i32 {
                            back_input();
                            if mu {
                                current_block = 17751730340908002208;
                            } else {
                                if scan_keyword(b"em\x00" as *const u8 as *const i8) {
                                    v = (*font_info.offset(
                                        (6i32
                                            + *param_base.offset(
                                                (*eqtb.offset(
                                                    (1i32
                                                        + (0x10ffffi32 + 1i32)
                                                        + (0x10ffffi32 + 1i32)
                                                        + 1i32
                                                        + 15000i32
                                                        + 12i32
                                                        + 9000i32
                                                        + 1i32
                                                        + 1i32
                                                        + 19i32
                                                        + 256i32
                                                        + 256i32
                                                        + 13i32
                                                        + 256i32
                                                        + 4i32
                                                        + 256i32)
                                                        as isize,
                                                ))
                                                .b32
                                                .s1
                                                    as isize,
                                            )) as isize,
                                    ))
                                    .b32
                                    .s1;
                                    current_block = 5195798230510548452;
                                } else if scan_keyword(b"ex\x00" as *const u8 as *const i8) {
                                    v = (*font_info.offset(
                                        (5i32
                                            + *param_base.offset(
                                                (*eqtb.offset(
                                                    (1i32
                                                        + (0x10ffffi32 + 1i32)
                                                        + (0x10ffffi32 + 1i32)
                                                        + 1i32
                                                        + 15000i32
                                                        + 12i32
                                                        + 9000i32
                                                        + 1i32
                                                        + 1i32
                                                        + 19i32
                                                        + 256i32
                                                        + 256i32
                                                        + 13i32
                                                        + 256i32
                                                        + 4i32
                                                        + 256i32)
                                                        as isize,
                                                ))
                                                .b32
                                                .s1
                                                    as isize,
                                            )) as isize,
                                    ))
                                    .b32
                                    .s1;
                                    current_block = 5195798230510548452;
                                } else {
                                    current_block = 17751730340908002208;
                                }
                                match current_block {
                                    17751730340908002208 => {}
                                    _ => {
                                        get_x_token();
                                        if cur_cmd as i32 != 10i32 {
                                            back_input();
                                        }
                                        current_block = 7531702508219610202;
                                    }
                                }
                            }
                            match current_block {
                                7531702508219610202 => {}
                                _ => {
                                    if mu {
                                        /*475:*/
                                        if scan_keyword(b"mu\x00" as *const u8 as *const i8) {
                                            current_block = 6063453238281986051;
                                        } else {
                                            if file_line_error_style_p != 0 {
                                                print_file_line();
                                            } else {
                                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                            }
                                            print_cstr(
                                                b"Illegal unit of measure (\x00" as *const u8
                                                    as *const i8,
                                            );
                                            print_cstr(
                                                b"mu inserted)\x00" as *const u8 as *const i8,
                                            );
                                            help_ptr = 4_u8;
                                            help_line[3] =
                                                b"The unit of measurement in math glue must be mu.\x00"
                                                    as *const u8 as
                                                    *const i8;
                                            help_line[2] =
                                                b"To recover gracefully from this error, it\'s best to\x00"
                                                    as *const u8 as
                                                    *const i8;
                                            help_line[1] =
                                                b"delete the erroneous units; e.g., type `2\' to delete\x00"
                                                    as *const u8 as
                                                    *const i8;
                                            help_line[0] =
                                                b"two letters. (See Chapter 27 of The TeXbook.)\x00"
                                                    as *const u8
                                                    as *const i8;
                                            error();
                                            current_block = 6063453238281986051;
                                        }
                                    } else {
                                        if scan_keyword(b"true\x00" as *const u8 as *const i8) {
                                            /*476:*/
                                            prepare_mag(); /* magic ratio consant */
                                            if (*eqtb.offset(
                                                (1i32
                                                    + (0x10ffffi32 + 1i32)
                                                    + (0x10ffffi32 + 1i32)
                                                    + 1i32
                                                    + 15000i32
                                                    + 12i32
                                                    + 9000i32
                                                    + 1i32
                                                    + 1i32
                                                    + 19i32
                                                    + 256i32
                                                    + 256i32
                                                    + 13i32
                                                    + 256i32
                                                    + 4i32
                                                    + 256i32
                                                    + 1i32
                                                    + 3i32 * 256i32
                                                    + (0x10ffffi32 + 1i32)
                                                    + (0x10ffffi32 + 1i32)
                                                    + (0x10ffffi32 + 1i32)
                                                    + (0x10ffffi32 + 1i32)
                                                    + (0x10ffffi32 + 1i32)
                                                    + (0x10ffffi32 + 1i32)
                                                    + 17i32)
                                                    as isize,
                                            ))
                                            .b32
                                            .s1 != 1000i32
                                            {
                                                cur_val = xn_over_d(
                                                    cur_val,
                                                    1000i32,
                                                    (*eqtb.offset(
                                                        (1i32
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + 1i32
                                                            + 15000i32
                                                            + 12i32
                                                            + 9000i32
                                                            + 1i32
                                                            + 1i32
                                                            + 19i32
                                                            + 256i32
                                                            + 256i32
                                                            + 13i32
                                                            + 256i32
                                                            + 4i32
                                                            + 256i32
                                                            + 1i32
                                                            + 3i32 * 256i32
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + 17i32)
                                                            as isize,
                                                    ))
                                                    .b32
                                                    .s1,
                                                ); /* magic ratio consant */
                                                f = (((1000i32 * f) as i64
                                                    + 65536 * tex_remainder as i64)
                                                    / (*eqtb.offset(
                                                        (1i32
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + 1i32
                                                            + 15000i32
                                                            + 12i32
                                                            + 9000i32
                                                            + 1i32
                                                            + 1i32
                                                            + 19i32
                                                            + 256i32
                                                            + 256i32
                                                            + 13i32
                                                            + 256i32
                                                            + 4i32
                                                            + 256i32
                                                            + 1i32
                                                            + 3i32 * 256i32
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + (0x10ffffi32 + 1i32)
                                                            + 17i32)
                                                            as isize,
                                                    ))
                                                    .b32
                                                    .s1
                                                        as i64)
                                                    as i32;
                                                cur_val =
                                                    (cur_val as i64 + f as i64 / 65536) as i32;
                                                f = (f as i64 % 65536) as i32
                                            }
                                        }
                                        if scan_keyword(b"pt\x00" as *const u8 as *const i8) {
                                            current_block = 6063453238281986051;
                                        } else {
                                            if scan_keyword(b"in\x00" as *const u8 as *const i8) {
                                                num = 7227i32;
                                                denom = 100i32;
                                                current_block = 15908231092227701503;
                                            } else if scan_keyword(
                                                b"pc\x00" as *const u8 as *const i8,
                                            ) {
                                                num = 12i32;
                                                denom = 1i32;
                                                current_block = 15908231092227701503;
                                            } else if scan_keyword(
                                                b"cm\x00" as *const u8 as *const i8,
                                            ) {
                                                num = 7227i32;
                                                denom = 254i32;
                                                current_block = 15908231092227701503;
                                            /* magic ratio consant */
                                            } else if scan_keyword(
                                                b"mm\x00" as *const u8 as *const i8,
                                            ) {
                                                num = 7227i32;
                                                denom = 2540i32;
                                                current_block = 15908231092227701503;
                                            /* magic ratio consant */
                                            /* magic ratio consant */
                                            } else if scan_keyword(
                                                b"bp\x00" as *const u8 as *const i8,
                                            ) {
                                                num = 7227i32;
                                                denom = 7200i32;
                                                current_block = 15908231092227701503;
                                            /* magic ratio consant */
                                            /* magic ratio consant */
                                            } else if scan_keyword(
                                                b"dd\x00" as *const u8 as *const i8,
                                            ) {
                                                num = 1238i32;
                                                denom = 1157i32;
                                                current_block = 15908231092227701503;
                                            /* magic ratio consant */
                                            /* magic ratio consant */
                                            } else if scan_keyword(
                                                b"cc\x00" as *const u8 as *const i8,
                                            ) {
                                                num = 14856i32;
                                                denom = 1157i32;
                                                current_block = 15908231092227701503;
                                            /* magic ratio consant */
                                            /* magic ratio consant */
                                            } else if scan_keyword(
                                                b"sp\x00" as *const u8 as *const i8,
                                            ) {
                                                current_block = 8982780081639585757;
                                            /*478:*/
                                            } else {
                                                if file_line_error_style_p != 0 {
                                                    print_file_line();
                                                } else {
                                                    print_nl_cstr(
                                                        b"! \x00" as *const u8 as *const i8,
                                                    );
                                                }
                                                print_cstr(
                                                    b"Illegal unit of measure (\x00" as *const u8
                                                        as *const i8,
                                                );
                                                print_cstr(
                                                    b"pt inserted)\x00" as *const u8 as *const i8,
                                                );
                                                help_ptr = 6_u8;
                                                help_line[5] =
                                                    b"Dimensions can be in units of em, ex, in, pt, pc,\x00"
                                                        as *const u8 as
                                                        *const i8;
                                                help_line[4] =
                                                    b"cm, mm, dd, cc, bp, or sp; but yours is a new one!\x00"
                                                        as *const u8 as
                                                        *const i8;
                                                help_line[3] =
                                                    b"I\'ll assume that you meant to say pt, for printer\'s points.\x00"
                                                        as *const u8 as
                                                        *const i8;
                                                help_line[2] =
                                                    b"To recover gracefully from this error, it\'s best to\x00"
                                                        as *const u8 as
                                                        *const i8;
                                                help_line[1] =
                                                    b"delete the erroneous units; e.g., type `2\' to delete\x00"
                                                        as *const u8 as
                                                        *const i8;
                                                help_line[0] =
                                                    b"two letters. (See Chapter 27 of The TeXbook.)\x00"
                                                        as *const u8 as
                                                        *const i8;
                                                error();
                                                current_block = 6063453238281986051;
                                            }
                                            match current_block {
                                                6063453238281986051 => {}
                                                8982780081639585757 => {}
                                                _ => {
                                                    cur_val = xn_over_d(cur_val, num, denom);
                                                    f = (((num * f) as i64
                                                        + 65536 * tex_remainder as i64)
                                                        / denom as i64)
                                                        as i32;
                                                    cur_val =
                                                        (cur_val as i64 + f as i64 / 65536) as i32;
                                                    f = (f as i64 % 65536) as i32;
                                                    current_block = 6063453238281986051;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if mu {
                                scan_something_internal(3i32 as small_number, false);
                                if cur_val_level as i32 >= 2i32 {
                                    v = (*mem.offset((cur_val + 1i32) as isize)).b32.s1;
                                    delete_glue_ref(cur_val);
                                    cur_val = v
                                }
                                if cur_val_level as i32 != 3i32 {
                                    mu_error();
                                }
                            } else {
                                scan_something_internal(1i32 as small_number, false);
                            }
                            v = cur_val;
                            current_block = 7531702508219610202;
                        }
                        match current_block {
                            6063453238281986051 => {}
                            8982780081639585757 => {}
                            _ => {
                                cur_val = mult_and_add(
                                    save_cur_val,
                                    v,
                                    xn_over_d(v, f, 65536 as i32),
                                    0x3fffffffi32,
                                );
                                current_block = 16246449912548656671;
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    16246449912548656671 => {}
                    _ => {
                        match current_block {
                            6063453238281986051 => {
                                if cur_val >= 16384i32 {
                                    arith_error = true
                                } else {
                                    cur_val = (cur_val as i64 * 65536 + f as i64) as i32
                                }
                            }
                            _ => {}
                        }
                        get_x_token();
                        if cur_cmd as i32 != 10i32 {
                            back_input();
                        }
                    }
                }
            } else if cur_val >= 16384i32 {
                arith_error = true
            } else {
                cur_val = (cur_val as i64 * 65536 + f as i64) as i32
            }
        }
        _ => {}
    }
    if arith_error as i32 != 0 || cur_val.abs() >= 0x40000000i32 {
        /*479:*/
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Dimension too large\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"I can\'t work with sizes bigger than about 19 feet.\x00" as *const u8 as *const i8;
        help_line[0] =
            b"Continue and I\'ll use the largest value I can.\x00" as *const u8 as *const i8;
        error();
        cur_val = 0x3fffffffi32;
        arith_error = false
    }
    if negative {
        cur_val = -cur_val
    };
}
#[no_mangle]
pub unsafe extern "C" fn scan_dimen(mut mu: bool, mut inf: bool, mut shortcut: bool) {
    xetex_scan_dimen(mu, inf, shortcut, true);
}
#[no_mangle]
pub unsafe extern "C" fn scan_decimal() {
    xetex_scan_dimen(false, false, false, false);
}
#[no_mangle]
pub unsafe extern "C" fn scan_glue(mut level: small_number) {
    let mut negative: bool = false;
    let mut q: i32 = 0;
    let mut mu: bool = false;
    mu = level as i32 == 3i32;
    negative = false;
    loop {
        loop {
            get_x_token();
            if !(cur_cmd as i32 == 10i32) {
                break;
            }
        }
        if cur_tok == 0x1800000i32 + 45i32 {
            /*"-"*/
            negative = !negative;
            cur_tok = 0x1800000i32 + 43i32
            /*"+"*/
        }
        if !(cur_tok == 0x1800000i32 + 43i32) {
            break;
        }
        /*"+"*/
    }
    if cur_cmd as i32 >= 68i32 && cur_cmd as i32 <= 91i32 {
        scan_something_internal(level, negative);
        if cur_val_level as i32 >= 2i32 {
            if cur_val_level as i32 != level as i32 {
                mu_error();
            }
            return;
        }
        if cur_val_level as i32 == 0i32 {
            scan_dimen(mu, false, true);
        } else if level as i32 == 3i32 {
            mu_error();
        }
    } else {
        back_input();
        scan_dimen(mu, false, false);
        if negative {
            cur_val = -cur_val
        }
    }
    q = new_spec(0i32);
    (*mem.offset((q + 1i32) as isize)).b32.s1 = cur_val;
    if scan_keyword(b"plus\x00" as *const u8 as *const i8) {
        scan_dimen(mu, true, false);
        (*mem.offset((q + 2i32) as isize)).b32.s1 = cur_val;
        (*mem.offset(q as isize)).b16.s1 = cur_order as u16
    }
    if scan_keyword(b"minus\x00" as *const u8 as *const i8) {
        scan_dimen(mu, true, false);
        (*mem.offset((q + 3i32) as isize)).b32.s1 = cur_val;
        (*mem.offset(q as isize)).b16.s0 = cur_order as u16
    }
    cur_val = q;
    /*:481*/
}
#[no_mangle]
pub unsafe extern "C" fn add_or_sub(
    mut x: i32,
    mut y: i32,
    mut max_answer: i32,
    mut negative: bool,
) -> i32 {
    let mut a: i32 = 0;
    if negative {
        y = -y
    }
    if x >= 0i32 {
        if y <= max_answer - x {
            a = x + y
        } else {
            arith_error = true;
            a = 0i32
        }
    } else if y >= -max_answer - x {
        a = x + y
    } else {
        arith_error = true;
        a = 0i32
    }
    a
}
#[no_mangle]
pub unsafe extern "C" fn quotient(mut n: i32, mut d: i32) -> i32 {
    let mut negative: bool = false;
    let mut a: i32 = 0;
    if d == 0i32 {
        arith_error = true;
        a = 0i32
    } else {
        if d > 0i32 {
            negative = false
        } else {
            d = -d;
            negative = true
        }
        if n < 0i32 {
            n = -n;
            negative = !negative
        }
        a = n / d;
        n = n - a * d;
        d = n - d;
        if d + n >= 0i32 {
            a += 1
        }
        if negative {
            a = -a
        }
    }
    a
}
#[no_mangle]
pub unsafe extern "C" fn fract(mut x: i32, mut n: i32, mut d: i32, mut max_answer: i32) -> i32 {
    let mut current_block: u64;
    let mut negative: bool = false;
    let mut a: i32 = 0;
    let mut f: i32 = 0;
    let mut h: i32 = 0;
    let mut r: i32 = 0;
    let mut t: i32 = 0;
    if d == 0i32 {
        current_block = 17166748944382662577;
    } else {
        a = 0i32;
        if d > 0i32 {
            negative = false
        } else {
            d = -d;
            negative = true
        }
        if x < 0i32 {
            x = -x;
            negative = !negative;
            current_block = 12349973810996921269;
        } else if x == 0i32 {
            current_block = 8704816881991807296;
        } else {
            current_block = 12349973810996921269;
        }
        match current_block {
            8704816881991807296 => {}
            _ => {
                if n < 0i32 {
                    n = -n;
                    negative = !negative
                }
                t = n / d;
                if t > max_answer / x {
                    current_block = 17166748944382662577;
                } else {
                    a = t * x;
                    n = n - t * d;
                    if n == 0i32 {
                        current_block = 8791566675823797574;
                    } else {
                        t = x / d;
                        if t > (max_answer - a) / n {
                            current_block = 17166748944382662577;
                        } else {
                            a = a + t * n;
                            x = x - t * d;
                            if x == 0i32 {
                                current_block = 8791566675823797574;
                            } else {
                                if x < n {
                                    t = x;
                                    x = n;
                                    n = t
                                }
                                f = 0i32;
                                r = d / 2i32 - d;
                                h = -r;
                                loop {
                                    if n & 1i32 != 0 {
                                        r = r + x;
                                        if r >= 0i32 {
                                            r = r - d;
                                            f += 1
                                        }
                                    }
                                    n = n / 2i32;
                                    if n == 0i32 {
                                        break;
                                    }
                                    if x < h {
                                        x = x + x
                                    } else {
                                        t = x - d;
                                        x = t + x;
                                        f = f + n;
                                        if !(x < n) {
                                            continue;
                                        }
                                        if x == 0i32 {
                                            break;
                                        }
                                        t = x;
                                        x = n;
                                        n = t
                                    }
                                }
                                if f > max_answer - a {
                                    current_block = 17166748944382662577;
                                } else {
                                    a = a + f;
                                    current_block = 8791566675823797574;
                                }
                            }
                        }
                    }
                    match current_block {
                        17166748944382662577 => {}
                        _ => {
                            if negative {
                                a = -a
                            }
                            current_block = 8704816881991807296;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        17166748944382662577 => {
            arith_error = true;
            a = 0i32
        }
        _ => {}
    }
    a
}
#[no_mangle]
pub unsafe extern "C" fn scan_expr() {
    let mut a: bool = false;
    let mut b: bool = false;
    let mut l: small_number = 0;
    let mut r: small_number = 0;
    let mut s: small_number = 0;
    let mut o: small_number = 0;
    let mut e: i32 = 0;
    let mut t: i32 = 0;
    let mut f: i32 = 0;
    let mut n: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    l = cur_val_level as small_number;
    a = arith_error;
    b = false;
    p = -0xfffffffi32;
    'c_78022: loop {
        r = 0i32 as small_number;
        e = 0i32;
        s = 0i32 as small_number;
        t = 0i32;
        n = 0i32;
        loop {
            if s as i32 == 0i32 {
                o = l
            } else {
                o = 0i32 as small_number
            }
            loop {
                get_x_token();
                if !(cur_cmd as i32 == 10i32) {
                    break;
                }
            }
            if cur_tok == 0x1800000i32 + 40i32 {
                break;
            }
            back_input();
            if o as i32 == 0i32 {
                scan_int();
            } else if o as i32 == 1i32 {
                scan_dimen(false, false, false);
            } else if o as i32 == 2i32 {
                scan_normal_glue();
            } else {
                scan_mu_glue();
            }
            f = cur_val;
            loop {
                loop
                /*1572:*//*424:*/
                {
                    get_x_token();
                    if !(cur_cmd as i32 == 10i32) {
                        break;
                    }
                }
                if cur_tok == 0x1800000i32 + 43i32 {
                    o = 1i32 as small_number
                } else if cur_tok == 0x1800000i32 + 45i32 {
                    o = 2i32 as small_number
                } else if cur_tok == 0x1800000i32 + 42i32 {
                    o = 3i32 as small_number
                } else if cur_tok == 0x1800000i32 + 47i32 {
                    o = 4i32 as small_number
                } else {
                    o = 0i32 as small_number;
                    if p == -0xfffffffi32 {
                        if cur_cmd as i32 != 0i32 {
                            back_input();
                        }
                    } else if cur_tok != 0x1800000i32 + 41i32 {
                        if file_line_error_style_p != 0 {
                            print_file_line();
                        } else {
                            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                        }
                        print_cstr(
                            b"Missing ) inserted for expression\x00" as *const u8 as *const i8,
                        );
                        help_ptr = 1_u8;
                        help_line[0] =
                            b"I was expecting to see `+\', `-\', `*\', `/\', or `)\'. Didn\'t.\x00"
                                as *const u8 as *const i8;
                        back_error();
                    }
                }
                arith_error = b;
                if l as i32 == 0i32 || s as i32 > 2i32 {
                    if f > 0x7fffffffi32 || f < -0x7fffffffi32 {
                        arith_error = true;
                        f = 0i32
                    }
                } else if l as i32 == 1i32 {
                    if f.abs() > 0x3fffffffi32 {
                        arith_error = true;
                        f = 0i32
                    }
                } else if ((*mem.offset((f + 1i32) as isize)).b32.s1).abs() > 0x3fffffffi32
                    || ((*mem.offset((f + 2i32) as isize)).b32.s1).abs() > 0x3fffffffi32
                    || ((*mem.offset((f + 3i32) as isize)).b32.s1).abs() > 0x3fffffffi32
                {
                    arith_error = true;
                    delete_glue_ref(f);
                    f = new_spec(0i32)
                }
                match s as i32 {
                    0 => {
                        /*1579: */
                        if l as i32 >= 2i32 && o as i32 != 0i32 {
                            t = new_spec(f);
                            delete_glue_ref(f);
                            if (*mem.offset((t + 2i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset(t as isize)).b16.s1 = 0_u16
                            }
                            if (*mem.offset((t + 3i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset(t as isize)).b16.s0 = 0_u16
                            }
                        } else {
                            t = f
                        }
                    }
                    3 => {
                        if o as i32 == 4i32 {
                            n = f;
                            o = 5i32 as small_number
                        } else if l as i32 == 0i32 {
                            t = mult_and_add(t, f, 0i32, 0x7fffffffi32)
                        } else if l as i32 == 1i32 {
                            t = mult_and_add(t, f, 0i32, 0x3fffffffi32)
                        } else {
                            (*mem.offset((t + 1i32) as isize)).b32.s1 = mult_and_add(
                                (*mem.offset((t + 1i32) as isize)).b32.s1,
                                f,
                                0i32,
                                0x3fffffffi32,
                            );
                            (*mem.offset((t + 2i32) as isize)).b32.s1 = mult_and_add(
                                (*mem.offset((t + 2i32) as isize)).b32.s1,
                                f,
                                0i32,
                                0x3fffffffi32,
                            );
                            (*mem.offset((t + 3i32) as isize)).b32.s1 = mult_and_add(
                                (*mem.offset((t + 3i32) as isize)).b32.s1,
                                f,
                                0i32,
                                0x3fffffffi32,
                            )
                        }
                    }
                    4 => {
                        if (l as i32) < 2i32 {
                            t = quotient(t, f)
                        } else {
                            (*mem.offset((t + 1i32) as isize)).b32.s1 =
                                quotient((*mem.offset((t + 1i32) as isize)).b32.s1, f);
                            (*mem.offset((t + 2i32) as isize)).b32.s1 =
                                quotient((*mem.offset((t + 2i32) as isize)).b32.s1, f);
                            (*mem.offset((t + 3i32) as isize)).b32.s1 =
                                quotient((*mem.offset((t + 3i32) as isize)).b32.s1, f)
                        }
                    }
                    5 => {
                        if l as i32 == 0i32 {
                            t = fract(t, n, f, 0x7fffffffi32)
                        } else if l as i32 == 1i32 {
                            t = fract(t, n, f, 0x3fffffffi32)
                        } else {
                            (*mem.offset((t + 1i32) as isize)).b32.s1 = fract(
                                (*mem.offset((t + 1i32) as isize)).b32.s1,
                                n,
                                f,
                                0x3fffffffi32,
                            );
                            (*mem.offset((t + 2i32) as isize)).b32.s1 = fract(
                                (*mem.offset((t + 2i32) as isize)).b32.s1,
                                n,
                                f,
                                0x3fffffffi32,
                            );
                            (*mem.offset((t + 3i32) as isize)).b32.s1 = fract(
                                (*mem.offset((t + 3i32) as isize)).b32.s1,
                                n,
                                f,
                                0x3fffffffi32,
                            )
                        }
                    }
                    _ => {}
                }
                if o as i32 > 2i32 {
                    s = o
                } else {
                    /*1580: */
                    s = 0i32 as small_number;
                    if r as i32 == 0i32 {
                        e = t
                    } else if l as i32 == 0i32 {
                        e = add_or_sub(e, t, 0x7fffffffi32, r as i32 == 2i32)
                    } else if l as i32 == 1i32 {
                        e = add_or_sub(e, t, 0x3fffffffi32, r as i32 == 2i32)
                    } else {
                        /*1582: */
                        (*mem.offset((e + 1i32) as isize)).b32.s1 = add_or_sub(
                            (*mem.offset((e + 1i32) as isize)).b32.s1,
                            (*mem.offset((t + 1i32) as isize)).b32.s1,
                            0x3fffffffi32,
                            r as i32 == 2i32,
                        );
                        if (*mem.offset(e as isize)).b16.s1 as i32
                            == (*mem.offset(t as isize)).b16.s1 as i32
                        {
                            (*mem.offset((e + 2i32) as isize)).b32.s1 = add_or_sub(
                                (*mem.offset((e + 2i32) as isize)).b32.s1,
                                (*mem.offset((t + 2i32) as isize)).b32.s1,
                                0x3fffffffi32,
                                r as i32 == 2i32,
                            )
                        } else if ((*mem.offset(e as isize)).b16.s1 as i32)
                            < (*mem.offset(t as isize)).b16.s1 as i32
                            && (*mem.offset((t + 2i32) as isize)).b32.s1 != 0i32
                        {
                            (*mem.offset((e + 2i32) as isize)).b32.s1 =
                                (*mem.offset((t + 2i32) as isize)).b32.s1;
                            (*mem.offset(e as isize)).b16.s1 = (*mem.offset(t as isize)).b16.s1
                        }
                        if (*mem.offset(e as isize)).b16.s0 as i32
                            == (*mem.offset(t as isize)).b16.s0 as i32
                        {
                            (*mem.offset((e + 3i32) as isize)).b32.s1 = add_or_sub(
                                (*mem.offset((e + 3i32) as isize)).b32.s1,
                                (*mem.offset((t + 3i32) as isize)).b32.s1,
                                0x3fffffffi32,
                                r as i32 == 2i32,
                            )
                        } else if ((*mem.offset(e as isize)).b16.s0 as i32)
                            < (*mem.offset(t as isize)).b16.s0 as i32
                            && (*mem.offset((t + 3i32) as isize)).b32.s1 != 0i32
                        {
                            (*mem.offset((e + 3i32) as isize)).b32.s1 =
                                (*mem.offset((t + 3i32) as isize)).b32.s1;
                            (*mem.offset(e as isize)).b16.s0 = (*mem.offset(t as isize)).b16.s0
                        }
                        delete_glue_ref(t);
                        if (*mem.offset((e + 2i32) as isize)).b32.s1 == 0i32 {
                            (*mem.offset(e as isize)).b16.s1 = 0_u16
                        }
                        if (*mem.offset((e + 3i32) as isize)).b32.s1 == 0i32 {
                            (*mem.offset(e as isize)).b16.s0 = 0_u16
                        }
                    }
                    r = o
                }
                b = arith_error;
                if o as i32 != 0i32 {
                    break;
                }
                if !(p != -0xfffffffi32) {
                    break 'c_78022;
                }
                /*1577: */
                f = e;
                q = p;
                e = (*mem.offset((q + 1i32) as isize)).b32.s1;
                t = (*mem.offset((q + 2i32) as isize)).b32.s1;
                n = (*mem.offset((q + 3i32) as isize)).b32.s1;
                s = ((*mem.offset(q as isize)).b16.s0 as i32 / 4i32) as small_number;
                r = ((*mem.offset(q as isize)).b16.s0 as i32 % 4i32) as small_number;
                l = (*mem.offset(q as isize)).b16.s1 as small_number;
                p = (*mem.offset(q as isize)).b32.s1;
                free_node(q, 4i32);
            }
        }
        /*1576: */
        q = get_node(4i32);
        (*mem.offset(q as isize)).b32.s1 = p;
        (*mem.offset(q as isize)).b16.s1 = l as u16;
        (*mem.offset(q as isize)).b16.s0 = (4i32 * s as i32 + r as i32) as u16;
        (*mem.offset((q + 1i32) as isize)).b32.s1 = e;
        (*mem.offset((q + 2i32) as isize)).b32.s1 = t;
        (*mem.offset((q + 3i32) as isize)).b32.s1 = n;
        p = q;
        l = o
    }
    if b {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Arithmetic overflow\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] = b"I can\'t evaluate this expression,\x00" as *const u8 as *const i8;
        help_line[0] = b"since the result is out of range.\x00" as *const u8 as *const i8;
        error();
        if l as i32 >= 2i32 {
            delete_glue_ref(e);
            e = 0i32;
            let ref mut fresh36 = (*mem.offset(e as isize)).b32.s1;
            *fresh36 += 1
        } else {
            e = 0i32
        }
    }
    arith_error = a;
    cur_val = e;
    cur_val_level = l as u8;
}
#[no_mangle]
pub unsafe extern "C" fn scan_normal_glue() {
    scan_glue(2i32 as small_number);
}
#[no_mangle]
pub unsafe extern "C" fn scan_mu_glue() {
    scan_glue(3i32 as small_number);
}
#[no_mangle]
pub unsafe extern "C" fn scan_rule_spec() -> i32 {
    let mut q: i32 = 0;
    q = new_rule();
    if cur_cmd as i32 == 35i32 {
        (*mem.offset((q + 1i32) as isize)).b32.s1 = 26214i32
    } else {
        (*mem.offset((q + 3i32) as isize)).b32.s1 = 26214i32;
        (*mem.offset((q + 2i32) as isize)).b32.s1 = 0i32
    }
    loop {
        if scan_keyword(b"width\x00" as *const u8 as *const i8) {
            scan_dimen(false, false, false);
            (*mem.offset((q + 1i32) as isize)).b32.s1 = cur_val
        } else if scan_keyword(b"height\x00" as *const u8 as *const i8) {
            scan_dimen(false, false, false);
            (*mem.offset((q + 3i32) as isize)).b32.s1 = cur_val
        } else {
            if !scan_keyword(b"depth\x00" as *const u8 as *const i8) {
                break;
            }
            scan_dimen(false, false, false);
            (*mem.offset((q + 2i32) as isize)).b32.s1 = cur_val
        }
    }
    q
}
#[no_mangle]
pub unsafe extern "C" fn scan_general_text() {
    let mut s: u8 = 0;
    let mut w: i32 = 0;
    let mut d: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut unbalance: i32 = 0;
    s = scanner_status;
    w = warning_index;
    d = def_ref;
    scanner_status = 5_u8;
    warning_index = cur_cs;
    def_ref = get_avail();
    (*mem.offset(def_ref as isize)).b32.s0 = -0xfffffffi32;
    p = def_ref;
    scan_left_brace();
    unbalance = 1i32;
    loop {
        get_token();
        if cur_tok < 0x600000i32 {
            if (cur_cmd as i32) < 2i32 {
                unbalance += 1
            } else {
                unbalance -= 1;
                if unbalance == 0i32 {
                    break;
                }
            }
        }
        q = get_avail();
        (*mem.offset(p as isize)).b32.s1 = q;
        (*mem.offset(q as isize)).b32.s0 = cur_tok;
        p = q
    }
    q = (*mem.offset(def_ref as isize)).b32.s1;
    (*mem.offset(def_ref as isize)).b32.s1 = avail;
    avail = def_ref;
    if q == -0xfffffffi32 {
        cur_val = 4999999i32 - 3i32
    } else {
        cur_val = p
    }
    (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 = q;
    scanner_status = s;
    warning_index = w;
    def_ref = d;
}
#[no_mangle]
pub unsafe extern "C" fn pseudo_start() {
    let mut s: str_number = 0;
    let mut l: pool_pointer = 0;
    let mut m: pool_pointer = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut w: b16x4 = b16x4 {
        s0: 0,
        s1: 0,
        s2: 0,
        s3: 0,
    };
    let mut nl: i32 = 0;
    let mut sz: i32 = 0;
    scan_general_text();
    let old_setting_0 = selector;
    selector = Selector::NEW_STRING;
    token_show(4999999i32 - 3i32);
    selector = old_setting_0;
    flush_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1);
    if pool_ptr + 1i32 > pool_size {
        overflow(
            b"pool size\x00" as *const u8 as *const i8,
            pool_size - init_pool_ptr,
        );
    }
    s = make_string();
    *str_pool.offset(pool_ptr as isize) = ' ' as i32 as packed_UTF16_code;
    l = *str_start.offset((s as i64 - 65536) as isize);
    nl = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 49i32) as isize,
    ))
    .b32
    .s1;
    p = get_avail();
    q = p;
    while l < pool_ptr {
        m = l;
        while l < pool_ptr && *str_pool.offset(l as isize) as i32 != nl {
            l += 1
        }
        sz = (l - m + 7i32) / 4i32;
        if sz == 1i32 {
            sz = 2i32
        }
        r = get_node(sz);
        (*mem.offset(q as isize)).b32.s1 = r;
        q = r;
        (*mem.offset(q as isize)).b32.s0 = sz;
        while sz > 2i32 {
            sz -= 1;
            r += 1;
            w.s3 = *str_pool.offset(m as isize);
            w.s2 = *str_pool.offset((m + 1i32) as isize);
            w.s1 = *str_pool.offset((m + 2i32) as isize);
            w.s0 = *str_pool.offset((m + 3i32) as isize);
            (*mem.offset(r as isize)).b16 = w;
            m = m + 4i32
        }
        w.s3 = ' ' as i32 as u16;
        w.s2 = ' ' as i32 as u16;
        w.s1 = ' ' as i32 as u16;
        w.s0 = ' ' as i32 as u16;
        if l > m {
            w.s3 = *str_pool.offset(m as isize);
            if l > m + 1i32 {
                w.s2 = *str_pool.offset((m + 1i32) as isize);
                if l > m + 2i32 {
                    w.s1 = *str_pool.offset((m + 2i32) as isize);
                    if l > m + 3i32 {
                        w.s0 = *str_pool.offset((m + 3i32) as isize)
                    }
                }
            }
        }
        (*mem.offset((r + 1i32) as isize)).b16 = w;
        if *str_pool.offset(l as isize) as i32 == nl {
            l += 1
        }
    }
    (*mem.offset(p as isize)).b32.s0 = (*mem.offset(p as isize)).b32.s1;
    (*mem.offset(p as isize)).b32.s1 = pseudo_files;
    pseudo_files = p;
    str_ptr -= 1;
    pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize);
    begin_file_reading();
    line = 0i32;
    cur_input.limit = cur_input.start;
    cur_input.loc = cur_input.limit + 1i32;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 61i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        if term_offset > max_print_line - 3i32 {
            print_ln();
        } else if term_offset > 0i32 || file_offset > 0i32 {
            print_char(' ' as i32);
        }
        cur_input.name = 19i32;
        print_cstr(b"( \x00" as *const u8 as *const i8);
        open_parens += 1;
        rust_stdout.as_mut().unwrap().flush().unwrap();
    } else {
        cur_input.name = 18i32;
        cur_input.synctex_tag = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn str_toks_cat(mut b: pool_pointer, mut cat: small_number) -> i32 {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut t: i32 = 0;
    let mut k: pool_pointer = 0;
    if pool_ptr + 1i32 > pool_size {
        overflow(
            b"pool size\x00" as *const u8 as *const i8,
            pool_size - init_pool_ptr,
        );
    }
    p = 4999999i32 - 3i32;
    (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
    k = b;
    while k < pool_ptr {
        t = *str_pool.offset(k as isize) as i32;
        if t == ' ' as i32 && cat as i32 == 0i32 {
            t = 0x1400020i32
        } else {
            if t >= 0xd800i32
                && t < 0xdc00i32
                && k + 1i32 < pool_ptr
                && *str_pool.offset((k + 1i32) as isize) as i32 >= 0xdc00i32
                && (*str_pool.offset((k + 1i32) as isize) as i32) < 0xe000i32
            {
                k += 1;
                t = (65536
                    + ((t - 0xd800i32) * 1024i32) as i64
                    + (*str_pool.offset(k as isize) as i32 - 0xdc00i32) as i64)
                    as i32
            }
            if cat as i32 == 0i32 {
                t = 0x1800000i32 + t
            } else {
                t = 0x200000i32 * cat as i32 + t
            }
        }
        q = avail;
        if q == -0xfffffffi32 {
            q = get_avail()
        } else {
            avail = (*mem.offset(q as isize)).b32.s1;
            (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32
        }
        (*mem.offset(p as isize)).b32.s1 = q;
        (*mem.offset(q as isize)).b32.s0 = t;
        p = q;
        k += 1
    }
    pool_ptr = b;
    p
}
#[no_mangle]
pub unsafe extern "C" fn str_toks(mut b: pool_pointer) -> i32 {
    str_toks_cat(b, 0i32 as small_number)
}
#[no_mangle]
pub unsafe extern "C" fn the_toks() -> i32 {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut b: pool_pointer = 0;
    let mut c: small_number = 0;
    if cur_chr & 1i32 != 0 {
        c = cur_chr as small_number;
        scan_general_text();
        if c as i32 == 1i32 {
            return cur_val;
        } else {
            let old_setting_0 = selector;
            selector = Selector::NEW_STRING;
            b = pool_ptr;
            p = get_avail();
            (*mem.offset(p as isize)).b32.s1 = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
            token_show(p);
            flush_list(p);
            selector = old_setting_0;
            return str_toks(b);
        }
    }
    get_x_token();
    scan_something_internal(5i32 as small_number, false);
    if cur_val_level as i32 >= 4i32 {
        /*485: */
        p = 4999999i32 - 3i32;
        (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
        if cur_val_level as i32 == 4i32 {
            q = get_avail();
            (*mem.offset(p as isize)).b32.s1 = q;
            (*mem.offset(q as isize)).b32.s0 = 0x1ffffffi32 + cur_val;
            p = q
        } else if cur_val != -0xfffffffi32 {
            r = (*mem.offset(cur_val as isize)).b32.s1;
            while r != -0xfffffffi32 {
                q = avail;
                if q == -0xfffffffi32 {
                    q = get_avail()
                } else {
                    avail = (*mem.offset(q as isize)).b32.s1;
                    (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32
                }
                (*mem.offset(p as isize)).b32.s1 = q;
                (*mem.offset(q as isize)).b32.s0 = (*mem.offset(r as isize)).b32.s0;
                p = q;
                r = (*mem.offset(r as isize)).b32.s1
            }
        }
        return p;
    } else {
        let old_setting_0 = selector;
        selector = Selector::NEW_STRING;
        b = pool_ptr;
        match cur_val_level as i32 {
            0 => {
                print_int(cur_val);
            }
            1 => {
                print_scaled(cur_val);
                print_cstr(b"pt\x00" as *const u8 as *const i8);
            }
            2 => {
                print_spec(cur_val, b"pt\x00" as *const u8 as *const i8);
                delete_glue_ref(cur_val);
            }
            3 => {
                print_spec(cur_val, b"mu\x00" as *const u8 as *const i8);
                delete_glue_ref(cur_val);
            }
            _ => {}
        }
        selector = old_setting_0;
        return str_toks(b);
    };
}
#[no_mangle]
pub unsafe extern "C" fn ins_the_toks() {
    (*mem.offset((4999999i32 - 12i32) as isize)).b32.s1 = the_toks();
    begin_token_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1, 5_u16);
}
#[no_mangle]
pub unsafe extern "C" fn conv_toks() {
    let mut save_warning_index: i32 = 0;
    let mut save_def_ref: i32 = 0;
    let mut boolvar: bool = false;
    let mut s: str_number = 0;
    let mut u: str_number = 0;
    let mut c: small_number = 0;
    let mut save_scanner_status: small_number = 0;
    let mut b: pool_pointer = 0;
    let mut fnt: i32 = 0i32;
    let mut arg1: i32 = 0i32;
    let mut arg2: i32 = 0i32;
    let mut font_name_str: str_number = 0;
    let mut i: small_number = 0;
    let mut quote_char: UTF16_code = 0;
    let mut cat: small_number = 0;
    let mut saved_chr: UnicodeScalar = 0;
    let mut p: i32 = -0xfffffffi32;
    let mut q: i32 = 0;
    cat = 0i32 as small_number;
    c = cur_chr as small_number;
    match c as i32 {
        0 | 1 => {
            scan_int();
        }
        2 | 3 => {
            save_scanner_status = scanner_status as small_number;
            scanner_status = 0_u8;
            get_token();
            scanner_status = save_scanner_status as u8
        }
        4 => {
            scan_font_ident();
        }
        13 => {
            scan_usv_num();
        }
        14 => {
            scan_usv_num();
            saved_chr = cur_val;
            scan_int();
            if cur_val < 1i32 || cur_val > 12i32 || cur_val == 5i32 || cur_val == 9i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Invalid code (\x00" as *const u8 as *const i8);
                print_int(cur_val);
                print_cstr(
                    b"), should be in the ranges 1..4, 6..8, 10..12\x00" as *const u8 as *const i8,
                );
                help_ptr = 1_u8;
                help_line[0] = b"I\'m going to use 12 instead of that illegal code value.\x00"
                    as *const u8 as *const i8;
                error();
                cat = 12i32 as small_number
            } else {
                cat = cur_val as small_number
            }
            cur_val = saved_chr
        }
        43 => {
            save_scanner_status = scanner_status as small_number;
            save_warning_index = warning_index;
            save_def_ref = def_ref;
            if *str_start.offset((str_ptr - 65536i32) as isize) < pool_ptr {
                u = make_string()
            } else {
                u = 0i32
            }
            compare_strings();
            def_ref = save_def_ref;
            warning_index = save_warning_index;
            scanner_status = save_scanner_status as u8;
            if u != 0i32 {
                str_ptr -= 1
            }
        }
        44 => {
            save_scanner_status = scanner_status as small_number;
            save_warning_index = warning_index;
            save_def_ref = def_ref;
            if *str_start.offset((str_ptr - 65536i32) as isize) < pool_ptr {
                u = make_string()
            } else {
                u = 0i32
            }
            boolvar = scan_keyword(b"file\x00" as *const u8 as *const i8);
            scan_pdf_ext_toks();
            if selector == Selector::NEW_STRING {
                pdf_error(
                    b"tokens\x00" as *const u8 as *const i8,
                    b"tokens_to_string() called while selector = new_string\x00" as *const u8
                        as *const i8,
                );
            }
            let old_setting_0 = selector;
            selector = Selector::NEW_STRING;
            show_token_list(
                (*mem.offset(def_ref as isize)).b32.s1,
                -0xfffffffi32,
                pool_size - pool_ptr,
            );
            selector = old_setting_0;
            s = make_string();
            delete_token_ref(def_ref);
            def_ref = save_def_ref;
            warning_index = save_warning_index;
            scanner_status = save_scanner_status as u8;
            b = pool_ptr;
            getmd5sum(s, boolvar);
            (*mem.offset((4999999i32 - 12i32) as isize)).b32.s1 = str_toks(b);
            if s == str_ptr - 1i32 {
                str_ptr -= 1;
                pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize)
            }
            begin_token_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1, 5_u16);
            if u != 0i32 {
                str_ptr -= 1
            }
            return;
        }
        7 => {
            scan_font_ident();
            fnt = cur_val;
            if font_area[fnt as usize] as u32 == 0xffffu32 {
                scan_int();
                arg1 = cur_val;
                arg2 = 0i32
            } else {
                not_aat_font_error(110i32, c as i32, fnt);
            }
        }
        8 => {
            scan_font_ident();
            fnt = cur_val;
            if font_area[fnt as usize] as u32 == 0xffffu32
                || font_area[fnt as usize] as u32 == 0xfffeu32
                    && usingGraphite(*font_layout_engine.offset(fnt as isize) as XeTeXLayoutEngine)
                        as i32
                        != 0
            {
                scan_int();
                arg1 = cur_val;
                arg2 = 0i32
            } else {
                not_aat_gr_font_error(110i32, c as i32, fnt);
            }
        }
        9 => {
            scan_font_ident();
            fnt = cur_val;
            if font_area[fnt as usize] as u32 == 0xffffu32
                || font_area[fnt as usize] as u32 == 0xfffeu32
                    && usingGraphite(*font_layout_engine.offset(fnt as isize) as XeTeXLayoutEngine)
                        as i32
                        != 0
            {
                scan_int();
                arg1 = cur_val;
                scan_int();
                arg2 = cur_val
            } else {
                not_aat_gr_font_error(110i32, c as i32, fnt);
            }
        }
        10 => {
            scan_font_ident();
            fnt = cur_val;
            if font_area[fnt as usize] as u32 == 0xffffu32
                || font_area[fnt as usize] as u32 == 0xfffeu32
            {
                scan_int();
                arg1 = cur_val
            } else {
                not_native_font_error(110i32, c as i32, fnt);
            }
        }
        11 | 12 => {
            scan_register_num();
            if cur_val < 256i32 {
                p = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr == -0xfffffffi32 {
                    p = -0xfffffffi32
                } else {
                    p = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                }
            }
            if p == -0xfffffffi32 || (*mem.offset(p as isize)).b16.s1 as i32 != 0i32 {
                pdf_error(
                    b"marginkern\x00" as *const u8 as *const i8,
                    b"a non-empty hbox expected\x00" as *const u8 as *const i8,
                );
            }
        }
        15 => {
            if job_name == 0i32 {
                open_log_file();
            }
        }
        5 | 6 | _ => {}
    }
    let old_setting_0 = selector;
    selector = Selector::NEW_STRING;
    b = pool_ptr;
    match c as i32 {
        0 => {
            print_int(cur_val);
        }
        1 => {
            print_roman_int(cur_val);
        }
        2 => {
            if cur_cs != 0i32 {
                sprint_cs(cur_cs);
            } else {
                print_char(cur_chr);
            }
        }
        3 => {
            print_meaning();
        }
        4 => {
            font_name_str = *font_name.offset(cur_val as isize);
            match font_area[cur_val as usize] as u32 {
                0xffffu32 | 0xfffeu32 => {
                    quote_char = '\"' as i32 as UTF16_code;
                    i = 0i32 as small_number;
                    while i as i32 <= length(font_name_str) - 1i32 {
                        if *str_pool.offset(
                            (*str_start.offset((font_name_str as i64 - 65536) as isize) + i as i32)
                                as isize,
                        ) as i32
                            == '\"' as i32
                        {
                            quote_char = '\'' as i32 as UTF16_code
                        }
                        i += 1
                    }
                    print_char(quote_char as i32);
                    print(font_name_str);
                    print_char(quote_char as i32);
                }
                _ => {
                    print(font_name_str);
                }
            }
            if *font_size.offset(cur_val as isize) != *font_dsize.offset(cur_val as isize) {
                print_cstr(b" at \x00" as *const u8 as *const i8);
                print_scaled(*font_size.offset(cur_val as isize));
                print_cstr(b"pt\x00" as *const u8 as *const i8);
            }
        }
        13 | 14 => {
            print_char(cur_val);
        }
        5 => {
            print_cstr(b".6\x00" as *const u8 as *const i8);
        }
        43 => {
            print_int(cur_val);
        }
        6 => {
            print_cstr(b".99998\x00" as *const u8 as *const i8);
        }
        7 => {
            match font_area[fnt as usize] as u32 {
                #[cfg(target_os = "macos")]
                0xffffu32 => {
                    aat::aat_print_font_name(
                        c as i32,
                        (*font_layout_engine.offset(fnt as isize)) as _,
                        arg1,
                        arg2,
                    );
                }
                #[cfg(not(target_os = "macos"))]
                0xffffu32 => {
                    // do nothing
                }
                _ => {
                    // do nothing
                }
            }
        }
        8 | 9 => {
            match font_area[fnt as usize] as u32 {
                #[cfg(target_os = "macos")]
                0xffffu32 => {
                    aat::aat_print_font_name(
                        c as i32,
                        (*font_layout_engine.offset(fnt as isize)) as _,
                        arg1,
                        arg2,
                    );
                }
                #[cfg(not(target_os = "macos"))]
                0xffffu32 => {
                    // do nothing
                }
                0xfffeu32 => {
                    if usingGraphite(*font_layout_engine.offset(fnt as isize) as XeTeXLayoutEngine)
                        as i32
                        != 0
                    {
                        gr_print_font_name(
                            c as i32,
                            *font_layout_engine.offset(fnt as isize),
                            arg1,
                            arg2,
                        );
                    }
                }
                _ => {}
            }
        }
        10 => match font_area[fnt as usize] as u32 {
            0xffffu32 | 0xfffeu32 => {
                print_glyph_name(fnt, arg1);
            }
            _ => {}
        },
        11 => {
            p = (*mem.offset((p + 5i32) as isize)).b32.s1;
            while p != -0xfffffffi32
                && (p < hi_mem_min
                    && ((*mem.offset(p as isize)).b16.s1 as i32 == 3i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 4i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 5i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 12i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 7i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s0 == -0xfffffffi32
                            && (*mem.offset((p + 1i32) as isize)).b32.s1 == -0xfffffffi32
                            && (*mem.offset(p as isize)).b16.s0 as i32 == 0i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 9i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s1 == 0i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 11i32
                            && ((*mem.offset((p + 1i32) as isize)).b32.s1 == 0i32
                                || (*mem.offset(p as isize)).b16.s0 as i32 == 0i32)
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 10i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s0 == 0i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 0i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s1 == 0i32
                            && (*mem.offset((p + 3i32) as isize)).b32.s1 == 0i32
                            && (*mem.offset((p + 2i32) as isize)).b32.s1 == 0i32
                            && (*mem.offset((p + 5i32) as isize)).b32.s1 == -0xfffffffi32)
                    || p < hi_mem_min
                        && (*mem.offset(p as isize)).b16.s1 as i32 == 10i32
                        && (*mem.offset(p as isize)).b16.s0 as i32 == 7i32 + 1i32)
            {
                p = (*mem.offset(p as isize)).b32.s1
            }
            if p != -0xfffffffi32
                && p < hi_mem_min
                && (*mem.offset(p as isize)).b16.s1 as i32 == 40i32
                && (*mem.offset(p as isize)).b16.s0 as i32 == 0i32
            {
                print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
            } else {
                print('0' as i32);
            }
            print_cstr(b"pt\x00" as *const u8 as *const i8);
        }
        12 => {
            q = (*mem.offset((p + 5i32) as isize)).b32.s1;
            p = prev_rightmost(q, -0xfffffffi32);
            while p != -0xfffffffi32
                && (p < hi_mem_min
                    && ((*mem.offset(p as isize)).b16.s1 as i32 == 3i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 4i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 5i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 12i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 7i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s0 == -0xfffffffi32
                            && (*mem.offset((p + 1i32) as isize)).b32.s1 == -0xfffffffi32
                            && (*mem.offset(p as isize)).b16.s0 as i32 == 0i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 9i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s1 == 0i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 11i32
                            && ((*mem.offset((p + 1i32) as isize)).b32.s1 == 0i32
                                || (*mem.offset(p as isize)).b16.s0 as i32 == 0i32)
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 10i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s0 == 0i32
                        || (*mem.offset(p as isize)).b16.s1 as i32 == 0i32
                            && (*mem.offset((p + 1i32) as isize)).b32.s1 == 0i32
                            && (*mem.offset((p + 3i32) as isize)).b32.s1 == 0i32
                            && (*mem.offset((p + 2i32) as isize)).b32.s1 == 0i32
                            && (*mem.offset((p + 5i32) as isize)).b32.s1 == -0xfffffffi32)
                    || p < hi_mem_min
                        && (*mem.offset(p as isize)).b16.s1 as i32 == 10i32
                        && (*mem.offset(p as isize)).b16.s0 as i32 == 8i32 + 1i32)
            {
                p = prev_rightmost(q, p)
            }
            if p != -0xfffffffi32
                && p < hi_mem_min
                && (*mem.offset(p as isize)).b16.s1 as i32 == 40i32
                && (*mem.offset(p as isize)).b16.s0 as i32 == 1i32
            {
                print_scaled((*mem.offset((p + 1i32) as isize)).b32.s1);
            } else {
                print('0' as i32);
            }
            print_cstr(b"pt\x00" as *const u8 as *const i8);
        }
        15 => {
            print_file_name(job_name, 0i32, 0i32);
        }
        _ => {}
    }
    selector = old_setting_0;
    (*mem.offset((4999999i32 - 12i32) as isize)).b32.s1 = str_toks_cat(b, cat);
    begin_token_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1, 5_u16);
}
#[no_mangle]
pub unsafe extern "C" fn scan_toks(mut macro_def: bool, mut xpand: bool) -> i32 {
    let mut current_block: u64;
    let mut t: i32 = 0;
    let mut s: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut unbalance: i32 = 0;
    let mut hash_brace: i32 = 0;
    if macro_def {
        scanner_status = 2_u8
    } else {
        scanner_status = 5_u8
    }
    warning_index = cur_cs;
    def_ref = get_avail();
    (*mem.offset(def_ref as isize)).b32.s0 = -0xfffffffi32;
    p = def_ref;
    hash_brace = 0i32;
    t = 0x1800000i32 + '0' as i32;
    if macro_def {
        loop
        /*493: */
        {
            get_token();
            if cur_tok < 0x600000i32 {
                current_block = 7086859973843054082;
                break;
            }
            if cur_cmd as i32 == 6i32 {
                /*495: */
                s = 0x1a00000i32 + cur_chr;
                get_token();
                if cur_cmd as i32 == 1i32 {
                    hash_brace = cur_tok;
                    q = get_avail();
                    (*mem.offset(p as isize)).b32.s1 = q;
                    (*mem.offset(q as isize)).b32.s0 = cur_tok;
                    p = q;
                    q = get_avail();
                    (*mem.offset(p as isize)).b32.s1 = q;
                    (*mem.offset(q as isize)).b32.s0 = 0x1c00000i32;
                    p = q;
                    current_block = 2723324002591448311;
                    break;
                } else if t == 0x1800000i32 + '0' as i32 + 9i32 {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"You already have nine parameters\x00" as *const u8 as *const i8);
                    help_ptr = 1_u8;
                    help_line[0] = b"I\'m going to ignore the # sign you just used.\x00"
                        as *const u8 as *const i8;
                    error();
                } else {
                    t += 1;
                    if cur_tok != t {
                        if file_line_error_style_p != 0 {
                            print_file_line();
                        } else {
                            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                        }
                        print_cstr(
                            b"Parameters must be numbered consecutively\x00" as *const u8
                                as *const i8,
                        );
                        help_ptr = 2_u8;
                        help_line[1] =
                            b"I\'ve inserted the digit you should have used after the #.\x00"
                                as *const u8 as *const i8;
                        help_line[0] =
                            b"Type `1\' to delete what you did use.\x00" as *const u8 as *const i8;
                        back_error();
                    }
                    cur_tok = s
                }
            }
            q = get_avail();
            (*mem.offset(p as isize)).b32.s1 = q;
            (*mem.offset(q as isize)).b32.s0 = cur_tok;
            p = q
        }
        match current_block {
            2723324002591448311 => {}
            _ => {
                q = get_avail();
                (*mem.offset(p as isize)).b32.s1 = q;
                (*mem.offset(q as isize)).b32.s0 = 0x1c00000i32;
                p = q;
                if cur_cmd as i32 == 2i32 {
                    /*494: */
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Missing { inserted\x00" as *const u8 as *const i8);
                    align_state += 1;
                    help_ptr = 2_u8;
                    help_line[1] =
                        b"Where was the left brace? You said something like `\\def\\a}\',\x00"
                            as *const u8 as *const i8;
                    help_line[0] = b"which I\'m going to interpret as `\\def\\a{}\'.\x00"
                        as *const u8 as *const i8;
                    error();
                    current_block = 17047787784317322882;
                } else {
                    current_block = 2723324002591448311;
                }
            }
        }
    } else {
        scan_left_brace();
        current_block = 2723324002591448311;
    }
    match current_block {
        2723324002591448311 => {
            unbalance = 1i32;
            loop {
                if xpand {
                    loop
                    /*497: */
                    {
                        get_next();
                        if cur_cmd as i32 >= 113i32 {
                            if (*mem.offset((*mem.offset(cur_chr as isize)).b32.s1 as isize))
                                .b32
                                .s0
                                == 0x1c00000i32 + 1i32
                            {
                                cur_cmd = 0i32 as eight_bits;
                                cur_chr = 0x10ffffi32 + 2i32
                            }
                        }
                        if cur_cmd as i32 <= 102i32 {
                            break;
                        }
                        if cur_cmd as i32 != 111i32 {
                            expand();
                        } else {
                            q = the_toks();
                            if (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 != -0xfffffffi32 {
                                (*mem.offset(p as isize)).b32.s1 =
                                    (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
                                p = q
                            }
                        }
                    }
                    x_token();
                } else {
                    get_token();
                }
                if cur_tok < 0x600000i32 {
                    if (cur_cmd as i32) < 2i32 {
                        unbalance += 1
                    } else {
                        unbalance -= 1;
                        if unbalance == 0i32 {
                            break;
                        }
                    }
                } else if cur_cmd as i32 == 6i32 {
                    if macro_def {
                        /*498: */
                        s = cur_tok;
                        if xpand {
                            get_x_token();
                        } else {
                            get_token();
                        }
                        if cur_cmd as i32 != 6i32 {
                            if cur_tok <= 0x1800000i32 + '0' as i32 || cur_tok > t {
                                if file_line_error_style_p != 0 {
                                    print_file_line();
                                } else {
                                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                                }
                                print_cstr(
                                    b"Illegal parameter number in definition of \x00" as *const u8
                                        as *const i8,
                                );
                                sprint_cs(warning_index);
                                help_ptr = 3_u8;
                                help_line[2] = b"You meant to type ## instead of #, right?\x00"
                                    as *const u8
                                    as *const i8;
                                help_line[1] =
                                    b"Or maybe a } was forgotten somewhere earlier, and things\x00"
                                        as *const u8
                                        as *const i8;
                                help_line[0] =
                                    b"are all screwed up? I\'m going to assume that you meant ##.\x00"
                                        as *const u8 as *const i8;
                                back_error();
                                cur_tok = s
                            } else {
                                cur_tok = 0xa00000i32 - 48i32 + cur_chr
                            }
                        }
                    }
                }
                q = get_avail();
                (*mem.offset(p as isize)).b32.s1 = q;
                (*mem.offset(q as isize)).b32.s0 = cur_tok;
                p = q
            }
        }
        _ => {}
    }
    scanner_status = 0_u8;
    if hash_brace != 0i32 {
        q = get_avail();
        (*mem.offset(p as isize)).b32.s1 = q;
        (*mem.offset(q as isize)).b32.s0 = hash_brace;
        p = q
    }
    p
}
#[no_mangle]
pub unsafe extern "C" fn read_toks(mut n: i32, mut r: i32, mut j: i32) {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut s: i32 = 0;
    let mut m: small_number = 0;
    scanner_status = 2_u8;
    warning_index = r;
    def_ref = get_avail();
    (*mem.offset(def_ref as isize)).b32.s0 = -0xfffffffi32;
    p = def_ref;
    q = get_avail();
    (*mem.offset(p as isize)).b32.s1 = q;
    (*mem.offset(q as isize)).b32.s0 = 0x1c00000i32;
    p = q;
    if n < 0i32 || n > 15i32 {
        m = 16i32 as small_number
    } else {
        m = n as small_number
    }
    s = align_state;
    align_state = 1000000i64 as i32;
    loop {
        /*502:*/
        begin_file_reading();
        cur_input.name = m as i32 + 1i32;
        assert!(
            read_open[m as usize] as i32 != 2,
            /*503:*/
            "terminal input forbidden"
        );
        /*505:*/
        if read_open[m as usize] as i32 == 1i32 {
            /*504:*/
            if input_line(read_file[m as usize]) != 0 {
                read_open[m as usize] = 0_u8
            } else {
                u_close(read_file[m as usize]);
                read_open[m as usize] = 2_u8
            }
        } else if input_line(read_file[m as usize]) == 0 {
            u_close(read_file[m as usize]);
            read_open[m as usize] = 2_u8;
            if align_state as i64 != 1000000 {
                runaway();
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"File ended within \x00" as *const u8 as *const i8);
                print_esc_cstr(b"read\x00" as *const u8 as *const i8);
                help_ptr = 1_u8;
                help_line[0] = b"This \\read has unbalanced braces.\x00" as *const u8 as *const i8;
                align_state = 1000000i64 as i32;
                error();
            }
        }
        cur_input.limit = last;
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 48i32) as isize,
        ))
        .b32
        .s1 < 0i32
            || (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 48i32) as isize,
            ))
            .b32
            .s1 > 255i32
        {
            cur_input.limit -= 1
        } else {
            *buffer.offset(cur_input.limit as isize) = (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 48i32) as isize,
            ))
            .b32
            .s1
        }
        first = cur_input.limit + 1i32;
        cur_input.loc = cur_input.start;
        cur_input.state = 33_u16;
        if j == 1i32 {
            while cur_input.loc <= cur_input.limit {
                cur_chr = *buffer.offset(cur_input.loc as isize);
                cur_input.loc += 1;
                if cur_chr == ' ' as i32 {
                    cur_tok = 0x1400020i32
                } else {
                    cur_tok = cur_chr + 0x1800000i32
                }
                q = get_avail();
                (*mem.offset(p as isize)).b32.s1 = q;
                (*mem.offset(q as isize)).b32.s0 = cur_tok;
                p = q
            }
        } else {
            loop {
                get_token();
                if cur_tok == 0i32 {
                    break;
                }
                if (align_state as i64) < 1000000 {
                    loop {
                        get_token();
                        if !(cur_tok != 0i32) {
                            break;
                        }
                    }
                    align_state = 1000000i64 as i32;
                    break;
                } else {
                    q = get_avail();
                    (*mem.offset(p as isize)).b32.s1 = q;
                    (*mem.offset(q as isize)).b32.s0 = cur_tok;
                    p = q
                }
            }
        }
        end_file_reading();
        if !(align_state as i64 != 1000000) {
            break;
        }
    }
    cur_val = def_ref;
    scanner_status = 0_u8;
    align_state = s;
}
#[no_mangle]
pub unsafe extern "C" fn pass_text() {
    let mut l: i32 = 0;
    let mut save_scanner_status: small_number = 0;
    save_scanner_status = scanner_status as small_number;
    scanner_status = 1_u8;
    l = 0i32;
    skip_line = line;
    loop {
        get_next();
        if cur_cmd as i32 == 108i32 {
            if l == 0i32 {
                break;
            }
            if cur_chr == 2i32 {
                l -= 1
            }
        } else if cur_cmd as i32 == 107i32 {
            l += 1
        }
    }
    scanner_status = save_scanner_status as u8;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 60i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        show_cur_cmd_chr();
    };
}
#[no_mangle]
pub unsafe extern "C" fn change_if_limit(mut l: small_number, mut p: i32) {
    let mut q: i32 = 0;
    if p == cond_ptr {
        if_limit = l as u8
    } else {
        q = cond_ptr;
        loop {
            if q == -0xfffffffi32 {
                confusion(b"if\x00" as *const u8 as *const i8);
            }
            if (*mem.offset(q as isize)).b32.s1 == p {
                (*mem.offset(q as isize)).b16.s1 = l as u16;
                return;
            }
            q = (*mem.offset(q as isize)).b32.s1
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn conditional() {
    let mut current_block: u64;
    let mut b: bool = false;
    let mut e: bool = false;
    let mut r: u8 = 0;
    let mut m: i32 = 0;
    let mut n: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut save_scanner_status: small_number = 0;
    let mut save_cond_ptr: i32 = 0;
    let mut this_if: small_number = 0;
    let mut is_unless: bool = false;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 60i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 36i32) as isize,
        ))
        .b32
        .s1 <= 1i32
        {
            show_cur_cmd_chr();
        }
    }
    p = get_node(2i32);
    (*mem.offset(p as isize)).b32.s1 = cond_ptr;
    (*mem.offset(p as isize)).b16.s1 = if_limit as u16;
    (*mem.offset(p as isize)).b16.s0 = cur_if as u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = if_line;
    cond_ptr = p;
    cur_if = cur_chr as small_number;
    if_limit = 1_u8;
    if_line = line;
    save_cond_ptr = cond_ptr;
    is_unless = cur_chr >= 32i32;
    this_if = (cur_chr % 32i32) as small_number;
    match this_if as i32 {
        0 | 1 => {
            get_x_token();
            if cur_cmd as i32 == 0i32 {
                if cur_chr == 0x10ffffi32 + 2i32 {
                    cur_cmd = 13i32 as eight_bits;
                    cur_chr = cur_tok - (0x1ffffffi32 + 1i32)
                }
            }
            if cur_cmd as i32 > 13i32 || cur_chr > 0x10ffffi32 {
                m = 0i32;
                n = 0x10ffffi32 + 1i32
            } else {
                m = cur_cmd as i32;
                n = cur_chr
            }
            get_x_token();
            if cur_cmd as i32 == 0i32 {
                if cur_chr == 0x10ffffi32 + 2i32 {
                    cur_cmd = 13i32 as eight_bits;
                    cur_chr = cur_tok - (0x1ffffffi32 + 1i32)
                }
            }
            if cur_cmd as i32 > 13i32 || cur_chr > 0x10ffffi32 {
                cur_cmd = 0i32 as eight_bits;
                cur_chr = 0x10ffffi32 + 1i32
            }
            if this_if as i32 == 0i32 {
                b = n == cur_chr
            } else {
                b = m == cur_cmd as i32
            }
            current_block = 16915215315900843183;
        }
        2 | 3 => {
            if this_if as i32 == 2i32 {
                scan_int();
            } else {
                scan_dimen(false, false, false);
            }
            n = cur_val;
            loop {
                get_x_token();
                if !(cur_cmd as i32 == 10i32) {
                    break;
                }
            }
            if cur_tok >= 0x1800000i32 + 60i32 && cur_tok <= 0x1800000i32 + 62i32 {
                r = (cur_tok - 0x1800000i32) as u8
            } else {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Missing = inserted for \x00" as *const u8 as *const i8);
                print_cmd_chr(107_u16, this_if as i32);
                help_ptr = 1_u8;
                help_line[0] = b"I was expecting to see `<\', `=\', or `>\'. Didn\'t.\x00"
                    as *const u8 as *const i8;
                back_error();
                r = '=' as i32 as u8
            }
            if this_if as i32 == 2i32 {
                scan_int();
            } else {
                scan_dimen(false, false, false);
            }
            match r as i32 {
                60 => {
                    /*"<"*/
                    b = n < cur_val
                }
                61 => {
                    /*"="*/
                    b = n == cur_val
                }
                62 => {
                    /*">"*/
                    b = n > cur_val
                }
                _ => {}
            } /*527:*/
            current_block = 16915215315900843183; /* !shellenabledp */
        }
        4 => {
            scan_int();
            b = cur_val & 1i32 != 0;
            current_block = 16915215315900843183;
        }
        5 => {
            b = (cur_list.mode as i32).abs() == 1i32;
            current_block = 16915215315900843183;
        }
        6 => {
            b = (cur_list.mode as i32).abs() == 104i32;
            current_block = 16915215315900843183;
        }
        7 => {
            b = (cur_list.mode as i32).abs() == 207i32;
            current_block = 16915215315900843183;
        }
        8 => {
            b = (cur_list.mode as i32) < 0i32;
            current_block = 16915215315900843183;
        }
        9 | 10 | 11 => {
            scan_register_num();
            if cur_val < 256i32 {
                p = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr == -0xfffffffi32 {
                    p = -0xfffffffi32
                } else {
                    p = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                }
            }
            if this_if as i32 == 9i32 {
                b = p == -0xfffffffi32
            } else if p == -0xfffffffi32 {
                b = false
            } else if this_if as i32 == 10i32 {
                b = (*mem.offset(p as isize)).b16.s1 as i32 == 0i32
            } else {
                b = (*mem.offset(p as isize)).b16.s1 as i32 == 1i32
            }
            current_block = 16915215315900843183;
        }
        12 => {
            save_scanner_status = scanner_status as small_number;
            scanner_status = 0_u8;
            get_next();
            n = cur_cs;
            p = cur_cmd as i32;
            q = cur_chr;
            get_next();
            if cur_cmd as i32 != p {
                b = false
            } else if (cur_cmd as i32) < 113i32 {
                b = cur_chr == q
            } else {
                p = (*mem.offset(cur_chr as isize)).b32.s1;
                q = (*mem.offset((*eqtb.offset(n as isize)).b32.s1 as isize))
                    .b32
                    .s1;
                if p == q {
                    b = true
                } else {
                    while p != -0xfffffffi32 && q != -0xfffffffi32 {
                        if (*mem.offset(p as isize)).b32.s0 != (*mem.offset(q as isize)).b32.s0 {
                            p = -0xfffffffi32
                        } else {
                            p = (*mem.offset(p as isize)).b32.s1;
                            q = (*mem.offset(q as isize)).b32.s1
                        }
                    }
                    b = p == -0xfffffffi32 && q == -0xfffffffi32
                }
            }
            scanner_status = save_scanner_status as u8;
            current_block = 16915215315900843183;
        }
        13 => {
            scan_four_bit_int_or_18();
            if cur_val == 18i32 {
                b = true
            } else {
                b = read_open[cur_val as usize] as i32 == 2i32
            }
            current_block = 16915215315900843183;
        }
        14 => {
            b = true;
            current_block = 16915215315900843183;
        }
        15 => {
            b = false;
            current_block = 16915215315900843183;
        }
        17 => {
            save_scanner_status = scanner_status as small_number;
            scanner_status = 0_u8;
            get_next();
            b = cur_cmd as i32 != 103i32;
            scanner_status = save_scanner_status as u8;
            current_block = 16915215315900843183;
        }
        18 => {
            n = get_avail();
            p = n;
            e = is_in_csname;
            is_in_csname = true;
            loop {
                get_x_token();
                if cur_cs == 0i32 {
                    q = get_avail();
                    (*mem.offset(p as isize)).b32.s1 = q;
                    (*mem.offset(q as isize)).b32.s0 = cur_tok;
                    p = q
                }
                if !(cur_cs == 0i32) {
                    break;
                }
            }
            if cur_cmd as i32 != 67i32 {
                /*391:*/
                if file_line_error_style_p != 0 {
                    print_file_line(); /*:1556*/
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Missing \x00" as *const u8 as *const i8);
                print_esc_cstr(b"endcsname\x00" as *const u8 as *const i8);
                print_cstr(b" inserted\x00" as *const u8 as *const i8);
                help_ptr = 2_u8;
                help_line[1] = b"The control sequence marked <to be read again> should\x00"
                    as *const u8 as *const i8;
                help_line[0] =
                    b"not appear between \\csname and \\endcsname.\x00" as *const u8 as *const i8;
                back_error();
            }
            m = first;
            p = (*mem.offset(n as isize)).b32.s1;
            while p != -0xfffffffi32 {
                if m >= max_buf_stack {
                    max_buf_stack = m + 1i32;
                    if max_buf_stack == buf_size {
                        overflow(b"buffer size\x00" as *const u8 as *const i8, buf_size);
                    }
                }
                *buffer.offset(m as isize) = (*mem.offset(p as isize)).b32.s0 % 0x200000i32;
                m += 1;
                p = (*mem.offset(p as isize)).b32.s1
            }
            if m == first {
                cur_cs = 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32)
            } else if m == first + 1i32 {
                cur_cs = 1i32 + (0x10ffffi32 + 1i32) + *buffer.offset(first as isize)
            } else {
                cur_cs = id_lookup(first, m - first)
            }
            flush_list(n);
            b = (*eqtb.offset(cur_cs as isize)).b16.s1 as i32 != 103i32;
            is_in_csname = e;
            current_block = 16915215315900843183;
        }
        20 => {
            b = is_in_csname;
            current_block = 16915215315900843183;
        }
        19 => {
            scan_font_ident();
            n = cur_val;
            scan_usv_num();
            if font_area[n as usize] as u32 == 0xffffu32
                || font_area[n as usize] as u32 == 0xfffeu32
            {
                b = map_char_to_glyph(n, cur_val) > 0i32
            } else if *font_bc.offset(n as isize) as i32 <= cur_val
                && *font_ec.offset(n as isize) as i32 >= cur_val
            {
                b = (*font_info.offset(
                    (*char_base.offset(n as isize) + effective_char(1i32 != 0, n, cur_val as u16))
                        as isize,
                ))
                .b16
                .s3 as i32
                    > 0i32
            } else {
                b = false
            }
            current_block = 16915215315900843183;
        }
        16 => {
            scan_int();
            n = cur_val;
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 36i32) as isize,
            ))
            .b32
            .s1 > 1i32
            {
                begin_diagnostic();
                print_cstr(b"{case \x00" as *const u8 as *const i8);
                print_int(n);
                print_char('}' as i32);
                end_diagnostic(false);
            }
            loop {
                if !(n != 0i32) {
                    current_block = 8672804474533504599;
                    break;
                }
                pass_text();
                if cond_ptr == save_cond_ptr {
                    if !(cur_chr == 4i32) {
                        current_block = 17018179191097466409;
                        break;
                    }
                    n -= 1
                } else if cur_chr == 2i32 {
                    /*515:*/
                    if *if_stack.offset(in_open as isize) == cond_ptr {
                        if_warning();
                    }
                    p = cond_ptr;
                    if_line = (*mem.offset((p + 1i32) as isize)).b32.s1;
                    cur_if = (*mem.offset(p as isize)).b16.s0 as small_number;
                    if_limit = (*mem.offset(p as isize)).b16.s1 as u8;
                    cond_ptr = (*mem.offset(p as isize)).b32.s1;
                    free_node(p, 2i32);
                }
            }
            match current_block {
                17018179191097466409 => {}
                _ => {
                    change_if_limit(4i32 as small_number, save_cond_ptr);
                    return;
                }
            }
        }
        21 => {
            save_scanner_status = scanner_status as small_number;
            scanner_status = 0_u8;
            get_next();
            scanner_status = save_scanner_status as u8;
            if cur_cs < 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 {
                m = prim_lookup(cur_cs - (1i32 + (0x10ffffi32 + 1i32)))
            } else {
                m = prim_lookup((*hash.offset(cur_cs as isize)).s1)
            }
            b = cur_cmd as i32 != 103i32
                && m != 0i32
                && cur_cmd as i32 == prim_eqtb[m as usize].b16.s1 as i32
                && cur_chr == prim_eqtb[m as usize].b32.s1;
            current_block = 16915215315900843183;
        }
        _ => {
            current_block = 16915215315900843183;
        }
    }
    match current_block {
        16915215315900843183 => {
            if is_unless {
                b = !b
            }
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 36i32) as isize,
            ))
            .b32
            .s1 > 1i32
            {
                /*521:*/
                begin_diagnostic();
                if b {
                    print_cstr(b"{true}\x00" as *const u8 as *const i8);
                } else {
                    print_cstr(b"{false}\x00" as *const u8 as *const i8);
                }
                end_diagnostic(false);
            }
            if b {
                change_if_limit(3i32 as small_number, save_cond_ptr);
                return;
            }
            loop {
                pass_text();
                if cond_ptr == save_cond_ptr {
                    if cur_chr != 4i32 {
                        break;
                    }
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Extra \x00" as *const u8 as *const i8);
                    print_esc_cstr(b"or\x00" as *const u8 as *const i8);
                    help_ptr = 1_u8;
                    help_line[0] = b"I\'m ignoring this; it doesn\'t match any \\if.\x00"
                        as *const u8 as *const i8;
                    error();
                } else if cur_chr == 2i32 {
                    /*515:*/
                    if *if_stack.offset(in_open as isize) == cond_ptr {
                        if_warning();
                    }
                    p = cond_ptr;
                    if_line = (*mem.offset((p + 1i32) as isize)).b32.s1;
                    cur_if = (*mem.offset(p as isize)).b16.s0 as small_number;
                    if_limit = (*mem.offset(p as isize)).b16.s1 as u8;
                    cond_ptr = (*mem.offset(p as isize)).b32.s1;
                    free_node(p, 2i32);
                }
            }
        }
        _ => {}
    }
    if cur_chr == 2i32 {
        /*515:*/
        if *if_stack.offset(in_open as isize) == cond_ptr {
            if_warning();
        }
        p = cond_ptr;
        if_line = (*mem.offset((p + 1i32) as isize)).b32.s1;
        cur_if = (*mem.offset(p as isize)).b16.s0 as small_number;
        if_limit = (*mem.offset(p as isize)).b16.s1 as u8;
        cond_ptr = (*mem.offset(p as isize)).b32.s1;
        free_node(p, 2i32);
    } else {
        if_limit = 2_u8
    };
}
#[no_mangle]
pub unsafe extern "C" fn begin_name() {
    area_delimiter = 0i32;
    ext_delimiter = 0i32;
    quoted_filename = false;
    file_name_quote_char = 0i32 as UTF16_code;
}
#[no_mangle]
pub unsafe extern "C" fn more_name(mut c: UTF16_code) -> bool {
    if stop_at_space as i32 != 0 && file_name_quote_char as i32 == 0i32 && c as i32 == ' ' as i32 {
        return false;
    }
    if stop_at_space as i32 != 0
        && file_name_quote_char as i32 != 0i32
        && c as i32 == file_name_quote_char as i32
    {
        file_name_quote_char = 0i32 as UTF16_code;
        return true;
    }
    if stop_at_space as i32 != 0
        && file_name_quote_char as i32 == 0i32
        && (c as i32 == '\"' as i32 || c as i32 == '\'' as i32)
    {
        file_name_quote_char = c;
        quoted_filename = true;
        return true;
    }
    if pool_ptr + 1i32 > pool_size {
        overflow(
            b"pool size\x00" as *const u8 as *const i8,
            pool_size - init_pool_ptr,
        );
    }
    let fresh37 = pool_ptr;
    pool_ptr = pool_ptr + 1;
    *str_pool.offset(fresh37 as isize) = c;
    if c as i32 == '/' as i32 {
        area_delimiter = cur_length();
        ext_delimiter = 0i32
    } else if c as i32 == '.' as i32 {
        ext_delimiter = cur_length()
    }
    true
}
#[no_mangle]
pub unsafe extern "C" fn end_name() {
    let mut temp_str: str_number = 0;
    let mut j: pool_pointer = 0;
    if str_ptr + 3i32 > max_strings {
        overflow(
            b"number of strings\x00" as *const u8 as *const i8,
            max_strings - init_str_ptr,
        );
    }
    /* area_delimiter is the length from the start of the filename to the
     * directory seperator "/", which we use to construct the stringpool
     * string `cur_area`. If there was already a string in the stringpool for
     * the area, reuse it. */
    if area_delimiter == 0i32 {
        cur_area = (65536 + 1i32 as i64) as str_number
    } else {
        cur_area = str_ptr;
        *str_start.offset(((str_ptr + 1i32) as i64 - 65536) as isize) =
            *str_start.offset((str_ptr - 65536i32) as isize) + area_delimiter;
        str_ptr += 1;
        temp_str = search_string(cur_area);
        if temp_str > 0i32 {
            cur_area = temp_str;
            str_ptr -= 1;
            j = *str_start.offset(((str_ptr + 1i32) as i64 - 65536) as isize);
            while j <= pool_ptr - 1i32 {
                *str_pool.offset((j - area_delimiter) as isize) = *str_pool.offset(j as isize);
                j += 1
            }
            pool_ptr = pool_ptr - area_delimiter
        }
    }
    /* ext_delimiter is the length from the start of the filename to the
     * extension '.' delimiter, which we use to construct the stringpool
     * strings `cur_ext` and `cur_name`. */
    if ext_delimiter == 0i32 {
        cur_ext = (65536 + 1i32 as i64) as str_number;
        cur_name = slow_make_string()
    } else {
        cur_name = str_ptr;
        *str_start.offset(((str_ptr + 1i32) as i64 - 65536) as isize) =
            *str_start.offset((str_ptr - 65536i32) as isize) + ext_delimiter
                - area_delimiter
                - 1i32;
        str_ptr += 1;
        cur_ext = make_string();
        str_ptr -= 1;
        temp_str = search_string(cur_name);
        if temp_str > 0i32 {
            cur_name = temp_str;
            str_ptr -= 1;
            j = *str_start.offset(((str_ptr + 1i32) as i64 - 65536) as isize);
            while j <= pool_ptr - 1i32 {
                *str_pool.offset((j - ext_delimiter + area_delimiter + 1i32) as isize) =
                    *str_pool.offset(j as isize);
                j += 1
            }
            pool_ptr = pool_ptr - ext_delimiter + area_delimiter + 1i32
        }
        cur_ext = slow_make_string()
    };
}
#[no_mangle]
pub unsafe extern "C" fn pack_file_name(mut n: str_number, mut a: str_number, mut e: str_number) {
    // Note that we populate the buffer in an order different than how the
    // arguments are passed to this function!
    let mut work_buffer: *mut i8 = xmalloc(
        (((length(a) + length(n) + length(e)) * 3i32 + 1i32 + 1i32) as u64)
            .wrapping_mul(::std::mem::size_of::<UTF8_code>() as u64),
    ) as *mut i8;
    *work_buffer.offset(0) = '\u{0}' as i32 as i8;
    let mut a_utf8: *mut i8 = gettexstring(a);
    strcat(work_buffer, a_utf8);
    free(a_utf8 as *mut libc::c_void);
    let mut n_utf8: *mut i8 = gettexstring(n);
    strcat(work_buffer, n_utf8);
    free(n_utf8 as *mut libc::c_void);
    let mut e_utf8: *mut i8 = gettexstring(e);
    strcat(work_buffer, e_utf8);
    free(e_utf8 as *mut libc::c_void);
    name_length = strlen(work_buffer) as i32;
    free(name_of_file as *mut libc::c_void);
    name_of_file = xmalloc(
        ((name_length + 1i32 + 1i32) as u64).wrapping_mul(::std::mem::size_of::<i8>() as u64),
    ) as *mut i8;
    strcpy(name_of_file, work_buffer);
    free(work_buffer as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn make_name_string() -> str_number {
    let mut k: i32 = 0;
    let mut save_area_delimiter: pool_pointer = 0;
    let mut save_ext_delimiter: pool_pointer = 0;
    let mut save_name_in_progress: bool = false;
    let mut save_stop_at_space: bool = false;
    if pool_ptr + name_length > pool_size || str_ptr == max_strings || cur_length() > 0i32 {
        return '?' as i32;
    }
    make_utf16_name();
    k = 0i32;
    while k < name_length16 {
        let fresh38 = pool_ptr;
        pool_ptr = pool_ptr + 1;
        *str_pool.offset(fresh38 as isize) = *name_of_file16.offset(k as isize);
        k += 1
    }
    let mut Result: str_number = make_string();
    save_area_delimiter = area_delimiter;
    save_ext_delimiter = ext_delimiter;
    save_name_in_progress = name_in_progress;
    save_stop_at_space = stop_at_space;
    name_in_progress = true;
    begin_name();
    stop_at_space = false;
    k = 0i32;
    while k < name_length16 && more_name(*name_of_file16.offset(k as isize)) as i32 != 0 {
        k += 1
    }
    stop_at_space = save_stop_at_space;
    end_name();
    name_in_progress = save_name_in_progress;
    area_delimiter = save_area_delimiter;
    ext_delimiter = save_ext_delimiter;
    Result
}
#[no_mangle]
pub unsafe extern "C" fn scan_file_name() {
    name_in_progress = true;
    begin_name();
    loop {
        get_x_token();
        if !(cur_cmd as i32 == 10i32) {
            break;
        }
    }
    loop {
        if cur_cmd as i32 > 12i32 || cur_chr > 0xffffi32 {
            back_input();
            break;
        } else {
            if !more_name(cur_chr as UTF16_code) {
                break;
            }
            get_x_token();
        }
    }
    end_name();
    name_in_progress = false;
}
#[no_mangle]
pub unsafe extern "C" fn pack_job_name(mut s: *const i8) {
    cur_area = (65536 + 1i32 as i64) as str_number;
    cur_ext = maketexstring(s);
    cur_name = job_name;
    pack_file_name(cur_name, cur_area, cur_ext);
}
#[no_mangle]
pub unsafe extern "C" fn open_log_file() {
    let mut k: i32 = 0;
    let mut l: i32 = 0;
    let old_setting_0 = selector;
    if job_name == 0i32 {
        job_name = maketexstring(b"texput\x00" as *const u8 as *const i8)
    }
    pack_job_name(b".log\x00" as *const u8 as *const i8);
    log_file = ttstub_output_open(name_of_file, 0i32);
    if log_file.is_none() {
        _tt_abort(
            b"cannot open log file output \"%s\"\x00" as *const u8 as *const i8,
            name_of_file,
        );
    }
    texmf_log_name = make_name_string();
    selector = Selector::LOG_ONLY;
    log_opened = true;
    *input_stack.offset(input_ptr as isize) = cur_input;
    /* Here we catch the log file up with anything that has already been
     * printed. The eqtb reference is end_line_char. */
    print_nl_cstr(b"**\x00" as *const u8 as *const i8);
    l = (*input_stack.offset(0)).limit;
    if *buffer.offset(l as isize)
        == (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 48i32) as isize,
        ))
        .b32
        .s1
    {
        l -= 1
    }
    k = 1i32;
    while k <= l {
        print(*buffer.offset(k as isize));
        k += 1
    }
    print_ln();
    selector = (u8::from(old_setting_0) + 2).into();
}
#[no_mangle]
pub unsafe extern "C" fn start_input(mut primary_input_name: *const i8) {
    let mut format = TTInputFormat::TEX;
    let mut temp_str: str_number = 0;
    if !primary_input_name.is_null() {
        /* If this is the case, we're opening the primary input file, and the
         * name that we should use to refer to it has been handed directly to
         * us. We emulate the hacks used below to fill in cur_name, etc., from
         * a UTF-8 C string. It looks like the `cur_{name,area,ext}` strings
         * are hardly used so it'd be nice to get rid of them someday. */
        format = TTInputFormat::TECTONIC_PRIMARY;
        name_in_progress = true;
        begin_name();
        stop_at_space = false;
        let mut cp: *const u8 = primary_input_name as *const u8;
        assert!(
            !((pool_ptr as usize).wrapping_add(strlen(primary_input_name).wrapping_mul(2))
                >= pool_size as usize),
            "string pool overflow [{} bytes]",
            pool_size,
        );
        let mut rval: UInt32 = 0;
        loop {
            let fresh39 = cp;
            cp = cp.offset(1);
            rval = *fresh39 as UInt32;
            if !(rval != 0_u32) {
                break;
            }
            let mut extraBytes: UInt16 = bytesFromUTF8[rval as usize] as UInt16;
            let mut current_block_21: u64;
            match extraBytes as i32 {
                5 => {
                    /* note: code falls through cases! */
                    rval <<= 6i32;
                    if *cp != 0 {
                        let fresh40 = cp;
                        cp = cp.offset(1);
                        rval = (rval as u32).wrapping_add(*fresh40 as u32) as UInt32 as UInt32
                    }
                    current_block_21 = 7676382540965064243;
                }
                4 => {
                    current_block_21 = 7676382540965064243;
                }
                3 => {
                    current_block_21 = 13258898395114305131;
                }
                2 => {
                    current_block_21 = 10625751394499422232;
                }
                1 => {
                    current_block_21 = 4051951890355284227;
                }
                0 | _ => {
                    current_block_21 = 14818589718467733107;
                }
            }
            match current_block_21 {
                7676382540965064243 => {
                    rval <<= 6i32;
                    if *cp != 0 {
                        let fresh41 = cp;
                        cp = cp.offset(1);
                        rval = (rval as u32).wrapping_add(*fresh41 as u32) as UInt32 as UInt32
                    }
                    current_block_21 = 13258898395114305131;
                }
                _ => {}
            }
            match current_block_21 {
                13258898395114305131 => {
                    rval <<= 6i32;
                    if *cp != 0 {
                        let fresh42 = cp;
                        cp = cp.offset(1);
                        rval = (rval as u32).wrapping_add(*fresh42 as u32) as UInt32 as UInt32
                    }
                    current_block_21 = 10625751394499422232;
                }
                _ => {}
            }
            match current_block_21 {
                10625751394499422232 => {
                    rval <<= 6i32;
                    if *cp != 0 {
                        let fresh43 = cp;
                        cp = cp.offset(1);
                        rval = (rval as u32).wrapping_add(*fresh43 as u32) as UInt32 as UInt32
                    }
                    current_block_21 = 4051951890355284227;
                }
                _ => {}
            }
            match current_block_21 {
                4051951890355284227 => {
                    rval <<= 6i32;
                    if *cp != 0 {
                        let fresh44 = cp;
                        cp = cp.offset(1);
                        rval = (rval as u32).wrapping_add(*fresh44 as u32) as UInt32 as UInt32
                    }
                }
                _ => {}
            }
            rval = (rval as u32).wrapping_sub(offsetsFromUTF8[extraBytes as usize]) as UInt32
                as UInt32;
            if rval > 0xffff_u32 {
                rval = (rval as u32).wrapping_sub(0x10000_u32) as UInt32 as UInt32;
                let fresh45 = pool_ptr;
                pool_ptr = pool_ptr + 1;
                *str_pool.offset(fresh45 as isize) =
                    (0xd800_u32).wrapping_add(rval.wrapping_div(0x400_u32)) as packed_UTF16_code;
                let fresh46 = pool_ptr;
                pool_ptr = pool_ptr + 1;
                *str_pool.offset(fresh46 as isize) =
                    (0xdc00_u32).wrapping_add(rval.wrapping_rem(0x400_u32)) as packed_UTF16_code
            } else {
                let fresh47 = pool_ptr;
                pool_ptr = pool_ptr + 1;
                *str_pool.offset(fresh47 as isize) = rval as packed_UTF16_code
            }
            if rval == '/' as i32 as u32 {
                area_delimiter = cur_length();
                ext_delimiter = 0i32
            } else if rval == '.' as i32 as u32 {
                ext_delimiter = cur_length()
            }
        }
        stop_at_space = true;
        end_name();
        name_in_progress = false
    } else {
        /* Scan in the file name from the current token stream. The file name to
         * input is saved as the stringpool strings `cur_{name,area,ext}` and the
         * UTF-8 string `name_of_file`. */
        scan_file_name();
    }
    pack_file_name(cur_name, cur_area, cur_ext);
    /* Open up the new file to be read. The name of the file to be read comes
     * from `name_of_file`. */
    begin_file_reading();
    if u_open_in(
        &mut *input_file.offset(cur_input.index as isize),
        format,
        b"rb\x00" as *const u8 as *const i8,
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 77i32) as isize,
        ))
        .b32
        .s1,
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 78i32) as isize,
        ))
        .b32
        .s1,
    ) == 0
    {
        _tt_abort(
            b"failed to open input file \"%s\"\x00" as *const u8 as *const i8,
            name_of_file,
        );
    }
    /* Now re-encode `name_of_file` into the UTF-16 variable `name_of_file16`,
     * and use that to recompute `cur_{name,area,ext}`. */
    make_utf16_name();
    name_in_progress = true;
    begin_name();
    stop_at_space = false;
    let mut k: i32 = 0i32;
    while k < name_length16 && more_name(*name_of_file16.offset(k as isize)) as i32 != 0 {
        k += 1
    }
    stop_at_space = true;
    end_name();
    name_in_progress = false;
    /* Now generate a stringpool string corresponding to the full path of the
     * input file. This calls make_utf16_name() again and reruns through the
     * {begin,more,end}_name() trifecta to re-re-compute
     * `cur_{name,area,ext}`. */
    cur_input.name = make_name_string();
    *source_filename_stack.offset(in_open as isize) = cur_input.name;
    /* *This* variant is a TeX string made out of `name_of_input_file`. */
    *full_source_filename_stack.offset(in_open as isize) = maketexstring(name_of_input_file);
    if cur_input.name == str_ptr - 1i32 {
        temp_str = search_string(cur_input.name);
        if temp_str > 0i32 {
            cur_input.name = temp_str;
            str_ptr -= 1;
            pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize)
        }
    }
    /* Finally we start really doing stuff with the newly-opened file. */
    if job_name == 0i32 {
        job_name = cur_name; /* this is the "flush_string" macro which discards the most recent string */
        open_log_file(); /* "really a CFDictionaryRef or XeTeXLayoutEngine" */
    } /* = first_math_fontdimen (=10) + lastMathConstant (= radicalDegreeBottomRaisePercent = 55) */
    if term_offset + length(*full_source_filename_stack.offset(in_open as isize))
        > max_print_line - 2i32
    {
        print_ln();
    } else if term_offset > 0i32 || file_offset > 0i32 {
        print_char(' ' as i32);
    }
    print_char('(' as i32);
    open_parens += 1;
    print(*full_source_filename_stack.offset(in_open as isize));
    rust_stdout.as_mut().unwrap().flush().unwrap();
    cur_input.state = 33_u16;
    synctex_start_input();
    line = 1i32;
    input_line(*input_file.offset(cur_input.index as isize));
    cur_input.limit = last;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 48i32) as isize,
    ))
    .b32
    .s1 < 0i32
        || (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 48i32) as isize,
        ))
        .b32
        .s1 > 255i32
    {
        cur_input.limit -= 1
    } else {
        *buffer.offset(cur_input.limit as isize) = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 48i32) as isize,
        ))
        .b32
        .s1
    }
    first = cur_input.limit + 1i32;
    cur_input.loc = cur_input.start;
}
#[no_mangle]
pub unsafe extern "C" fn effective_char_info(mut f: internal_font_number, mut c: u16) -> b16x4 {
    if !xtx_ligature_present && !(*font_mapping.offset(f as isize)).is_null() {
        c = apply_tfm_font_mapping(*font_mapping.offset(f as isize), c as i32) as u16
    }
    xtx_ligature_present = false;
    (*font_info.offset((*char_base.offset(f as isize) + c as i32) as isize)).b16
}
#[no_mangle]
pub unsafe extern "C" fn char_warning(mut f: internal_font_number, mut c: i32) {
    let mut old_setting_0: i32 = 0;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 35i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        old_setting_0 = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 29i32) as isize,
        ))
        .b32
        .s1;
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 35i32) as isize,
        ))
        .b32
        .s1 > 1i32
        {
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 29i32) as isize,
            ))
            .b32
            .s1 = 1i32
        }
        begin_diagnostic();
        print_nl_cstr(b"Missing character: There is no \x00" as *const u8 as *const i8);
        if (c as i64) < 65536 {
            print(c);
        } else {
            print_char(c);
        }
        print_cstr(b" in font \x00" as *const u8 as *const i8);
        print(*font_name.offset(f as isize));
        print_char('!' as i32);
        end_diagnostic(false);
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 29i32) as isize,
        ))
        .b32
        .s1 = old_setting_0
    }
    let mut fn_0: *mut i8 = gettexstring(*font_name.offset(f as isize));
    let mut chr: *mut i8 = 0 as *mut i8;
    let prev_selector = selector;
    let mut s: i32 = 0;
    selector = Selector::NEW_STRING;
    if c < 0x10000i32 {
        print(c);
    } else {
        print_char(c);
    }
    selector = prev_selector;
    s = make_string();
    chr = gettexstring(s);
    str_ptr -= 1;
    pool_ptr = *str_start.offset((str_ptr - 0x10000i32) as isize);
    ttstub_issue_warning(
        b"could not represent character \"%s\" in font \"%s\"\x00" as *const u8 as *const i8,
        chr,
        fn_0,
    );
    free(fn_0 as *mut libc::c_void);
    free(chr as *mut libc::c_void);
    if !gave_char_warning_help {
        ttstub_issue_warning(
            b"  you may need to load the `fontspec` package and use (e.g.) \\setmainfont to\x00"
                as *const u8 as *const i8,
        );
        ttstub_issue_warning(
            b"  choose a different font that covers the unrepresentable character(s)\x00"
                as *const u8 as *const i8,
        );
        gave_char_warning_help = true
    };
}
#[no_mangle]
pub unsafe extern "C" fn new_native_word_node(mut f: internal_font_number, mut n: i32) -> i32 {
    let mut l: i32 = 0;
    let mut q: i32 = 0;
    l = (6i32 as u64).wrapping_add(
        (n as u64)
            .wrapping_mul(::std::mem::size_of::<UTF16_code>() as u64)
            .wrapping_add(::std::mem::size_of::<memory_word>() as u64)
            .wrapping_sub(1i32 as u64)
            .wrapping_div(::std::mem::size_of::<memory_word>() as u64),
    ) as i32;
    q = get_node(l);
    (*mem.offset(q as isize)).b16.s1 = 8_u16;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 81i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        (*mem.offset(q as isize)).b16.s0 = 41_u16
    } else {
        (*mem.offset(q as isize)).b16.s0 = 40_u16
    }
    (*mem.offset((q + 4i32) as isize)).b16.s3 = l as u16;
    (*mem.offset((q + 4i32) as isize)).b16.s2 = f as u16;
    (*mem.offset((q + 4i32) as isize)).b16.s1 = n as u16;
    (*mem.offset((q + 4i32) as isize)).b16.s0 = 0_u16;
    let ref mut fresh48 = (*mem.offset((q + 5i32) as isize)).ptr;
    *fresh48 = 0 as *mut libc::c_void;
    q
}
#[no_mangle]
pub unsafe extern "C" fn new_native_character(
    mut f: internal_font_number,
    mut c: UnicodeScalar,
) -> i32 {
    let mut p: i32 = 0;
    let mut i: i32 = 0;
    let mut len: i32 = 0;
    if !(*font_mapping.offset(f as isize)).is_null() {
        if c as i64 > 65535 {
            if pool_ptr + 2i32 > pool_size {
                overflow(
                    b"pool size\x00" as *const u8 as *const i8,
                    pool_size - init_pool_ptr,
                );
            }
            *str_pool.offset(pool_ptr as isize) =
                ((c as i64 - 65536) / 1024i32 as i64 + 0xd800i32 as i64) as packed_UTF16_code;
            pool_ptr += 1;
            *str_pool.offset(pool_ptr as isize) =
                ((c as i64 - 65536) % 1024i32 as i64 + 0xdc00i32 as i64) as packed_UTF16_code;
            pool_ptr += 1
        } else {
            if pool_ptr + 1i32 > pool_size {
                overflow(
                    b"pool size\x00" as *const u8 as *const i8,
                    pool_size - init_pool_ptr,
                );
            }
            *str_pool.offset(pool_ptr as isize) = c as packed_UTF16_code;
            pool_ptr += 1
        }
        len = apply_mapping(
            *font_mapping.offset(f as isize),
            &mut *str_pool.offset(*str_start.offset((str_ptr - 65536i32) as isize) as isize),
            cur_length(),
        );
        pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize);
        i = 0i32;
        while i < len {
            if *mapped_text.offset(i as isize) as i32 >= 0xd800i32
                && (*mapped_text.offset(i as isize) as i32) < 0xdc00i32
            {
                c = (*mapped_text.offset(i as isize) as i32 - 0xd800i32) * 1024i32
                    + *mapped_text.offset((i + 1i32) as isize) as i32
                    + 9216i32;
                if map_char_to_glyph(f, c) == 0i32 {
                    char_warning(f, c);
                }
                i += 2i32
            } else {
                if map_char_to_glyph(f, *mapped_text.offset(i as isize) as i32) == 0i32 {
                    char_warning(f, *mapped_text.offset(i as isize) as i32);
                }
                i += 1i32
            }
        }
        p = new_native_word_node(f, len);
        i = 0i32;
        while i <= len - 1i32 {
            *(&mut *mem.offset((p + 6i32) as isize) as *mut memory_word as *mut u16)
                .offset(i as isize) = *mapped_text.offset(i as isize);
            i += 1
        }
    } else {
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 35i32) as isize,
        ))
        .b32
        .s1 > 0i32
        {
            if map_char_to_glyph(f, c) == 0i32 {
                char_warning(f, c);
            }
        }
        p = get_node(6i32 + 1i32);
        (*mem.offset(p as isize)).b16.s1 = 8_u16;
        (*mem.offset(p as isize)).b16.s0 = 40_u16;
        (*mem.offset((p + 4i32) as isize)).b16.s3 = (6i32 + 1i32) as u16;
        (*mem.offset((p + 4i32) as isize)).b16.s0 = 0_u16;
        let ref mut fresh49 = (*mem.offset((p + 5i32) as isize)).ptr;
        *fresh49 = 0 as *mut libc::c_void;
        (*mem.offset((p + 4i32) as isize)).b16.s2 = f as u16;
        if c as i64 > 65535 {
            (*mem.offset((p + 4i32) as isize)).b16.s1 = 2_u16;
            *(&mut *mem.offset((p + 6i32) as isize) as *mut memory_word as *mut u16).offset(0) =
                ((c as i64 - 65536) / 1024i32 as i64 + 0xd800i32 as i64) as u16;
            *(&mut *mem.offset((p + 6i32) as isize) as *mut memory_word as *mut u16).offset(1) =
                ((c as i64 - 65536) % 1024i32 as i64 + 0xdc00i32 as i64) as u16
        } else {
            (*mem.offset((p + 4i32) as isize)).b16.s1 = 1_u16;
            *(&mut *mem.offset((p + 6i32) as isize) as *mut memory_word as *mut u16).offset(0) =
                c as u16
        }
    }
    measure_native_node(
        &mut *mem.offset(p as isize) as *mut memory_word as *mut libc::c_void,
        ((*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 74i32) as isize,
        ))
        .b32
        .s1 > 0i32) as i32,
    );
    p
}
#[no_mangle]
pub unsafe extern "C" fn font_feature_warning(
    mut featureNameP: *const libc::c_void,
    mut featLen: i32,
    mut settingNameP: *const libc::c_void,
    mut setLen: i32,
) {
    begin_diagnostic();
    print_nl_cstr(b"Unknown \x00" as *const u8 as *const i8);
    if setLen > 0i32 {
        print_cstr(b"selector `\x00" as *const u8 as *const i8);
        print_utf8_str(settingNameP as *const u8, setLen);
        print_cstr(b"\' for \x00" as *const u8 as *const i8);
    }
    print_cstr(b"feature `\x00" as *const u8 as *const i8);
    print_utf8_str(featureNameP as *const u8, featLen);
    print_cstr(b"\' in font `\x00" as *const u8 as *const i8);
    let mut i: i32 = 0i32;
    while *name_of_file.offset(i as isize) as i32 != 0i32 {
        print_raw_char(*name_of_file.offset(i as isize) as UTF16_code, true);
        i += 1
    }
    print_cstr(b"\'.\x00" as *const u8 as *const i8);
    end_diagnostic(false);
}
#[no_mangle]
pub unsafe extern "C" fn font_mapping_warning(
    mut mappingNameP: *const libc::c_void,
    mut mappingNameLen: i32,
    mut warningType: i32,
) {
    begin_diagnostic();
    if warningType == 0i32 {
        print_nl_cstr(b"Loaded mapping `\x00" as *const u8 as *const i8);
    } else {
        print_nl_cstr(b"Font mapping `\x00" as *const u8 as *const i8);
    }
    print_utf8_str(mappingNameP as *const u8, mappingNameLen);
    print_cstr(b"\' for font `\x00" as *const u8 as *const i8);
    let mut i: i32 = 0i32;
    while *name_of_file.offset(i as isize) as i32 != 0i32 {
        print_raw_char(*name_of_file.offset(i as isize) as UTF16_code, true);
        i += 1
    }
    match warningType {
        1 => {
            print_cstr(b"\' not found.\x00" as *const u8 as *const i8);
        }
        2 => {
            print_cstr(b"\' not usable;\x00" as *const u8 as *const i8);
            print_nl_cstr(
                b"bad mapping file or incorrect mapping type.\x00" as *const u8 as *const i8,
            );
        }
        _ => {
            print_cstr(b"\'.\x00" as *const u8 as *const i8);
        }
    }
    end_diagnostic(false);
}
#[no_mangle]
pub unsafe extern "C" fn graphite_warning() {
    begin_diagnostic();
    print_nl_cstr(b"Font `\x00" as *const u8 as *const i8);
    let mut i: i32 = 0i32;
    while *name_of_file.offset(i as isize) as i32 != 0i32 {
        print_raw_char(*name_of_file.offset(i as isize) as UTF16_code, true);
        i += 1
    }
    print_cstr(
        b"\' does not support Graphite. Trying OpenType layout instead.\x00" as *const u8
            as *const i8,
    );
    end_diagnostic(false);
}
#[no_mangle]
pub unsafe extern "C" fn load_native_font(
    mut u: i32,
    mut nom: str_number,
    mut aire: str_number,
    mut s: scaled_t,
) -> internal_font_number {
    let mut k: i32 = 0;
    let mut num_font_dimens: i32 = 0;
    let mut font_engine: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut actual_size: scaled_t = 0;
    let mut p: i32 = 0;
    let mut ascent: scaled_t = 0;
    let mut descent: scaled_t = 0;
    let mut font_slant: scaled_t = 0;
    let mut x_ht: scaled_t = 0;
    let mut cap_ht: scaled_t = 0;
    let mut f: internal_font_number = 0;
    let mut full_name: str_number = 0;
    font_engine = find_native_font(name_of_file, s);
    if font_engine.is_null() {
        return 0i32;
    }
    if s >= 0i32 {
        actual_size = s
    } else if s != -1000i32 {
        actual_size = xn_over_d(loaded_font_design_size, -s, 1000i32)
    } else {
        actual_size = loaded_font_design_size
    }
    if pool_ptr + name_length > pool_size {
        overflow(
            b"pool size\x00" as *const u8 as *const i8,
            pool_size - init_pool_ptr,
        );
    }
    k = 0i32;
    while k < name_length {
        let fresh50 = pool_ptr;
        pool_ptr = pool_ptr + 1;
        *str_pool.offset(fresh50 as isize) = *name_of_file.offset(k as isize) as packed_UTF16_code;
        k += 1
    }
    full_name = make_string();
    f = 0i32 + 1i32;
    while f <= font_ptr {
        if font_area[f as usize] == native_font_type_flag
            && str_eq_str(*font_name.offset(f as isize), full_name) as i32 != 0
            && *font_size.offset(f as isize) == actual_size
        {
            release_font_engine(font_engine, native_font_type_flag);
            str_ptr -= 1;
            pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize);
            return f;
        }
        f += 1
    }
    if native_font_type_flag as u32 == 0xfffeu32
        && isOpenTypeMathFont(font_engine as XeTeXLayoutEngine) as i32 != 0
    {
        num_font_dimens = 65i32
    } else {
        num_font_dimens = 8i32
    }
    if font_ptr == font_max || fmem_ptr + num_font_dimens > font_mem_size {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Font \x00" as *const u8 as *const i8);
        sprint_cs(u);
        print_char('=' as i32);
        if file_name_quote_char as i32 != 0i32 {
            print_char(file_name_quote_char as i32);
        }
        print_file_name(nom, aire, cur_ext);
        if file_name_quote_char as i32 != 0i32 {
            print_char(file_name_quote_char as i32);
        }
        if s >= 0i32 {
            print_cstr(b" at \x00" as *const u8 as *const i8);
            print_scaled(s);
            print_cstr(b"pt\x00" as *const u8 as *const i8);
        } else if s != -1000i32 {
            print_cstr(b" scaled \x00" as *const u8 as *const i8);
            print_int(-s);
        }
        print_cstr(b" not loaded: Not enough room left\x00" as *const u8 as *const i8);
        help_ptr = 4_u8;
        help_line[3] =
            b"I\'m afraid I won\'t be able to make use of this font,\x00" as *const u8 as *const i8;
        help_line[2] = b"because my memory for character-size data is too small.\x00" as *const u8
            as *const i8;
        help_line[1] =
            b"If you\'re really stuck, ask a wizard to enlarge me.\x00" as *const u8 as *const i8;
        help_line[0] = b"Or maybe try `I\\font<same font id>=<name of loaded font>\'.\x00"
            as *const u8 as *const i8;
        error();
        return 0i32;
    }
    font_ptr += 1;
    font_area[font_ptr as usize] = native_font_type_flag;
    *font_name.offset(font_ptr as isize) = full_name;
    (*font_check.offset(font_ptr as isize)).s3 = 0_u16;
    (*font_check.offset(font_ptr as isize)).s2 = 0_u16;
    (*font_check.offset(font_ptr as isize)).s1 = 0_u16;
    (*font_check.offset(font_ptr as isize)).s0 = 0_u16;
    *font_glue.offset(font_ptr as isize) = -0xfffffffi32;
    *font_dsize.offset(font_ptr as isize) = loaded_font_design_size;
    *font_size.offset(font_ptr as isize) = actual_size;
    match native_font_type_flag as u32 {
        #[cfg(target_os = "macos")]
        0xffffu32 => {
            aat::aat_get_font_metrics(
                font_engine as _,
                &mut ascent,
                &mut descent,
                &mut x_ht,
                &mut cap_ht,
                &mut font_slant,
            );
        }
        #[cfg(not(target_os = "macos"))]
        0xffffu32 => {
            // do nothing
        }
        _ => {
            ot_get_font_metrics(
                font_engine,
                &mut ascent,
                &mut descent,
                &mut x_ht,
                &mut cap_ht,
                &mut font_slant,
            );
        }
    }
    *height_base.offset(font_ptr as isize) = ascent;
    *depth_base.offset(font_ptr as isize) = -descent;
    *font_params.offset(font_ptr as isize) = num_font_dimens;
    *font_bc.offset(font_ptr as isize) = 0i32 as UTF16_code;
    *font_ec.offset(font_ptr as isize) = 65535 as UTF16_code;
    *font_used.offset(font_ptr as isize) = false;
    *hyphen_char.offset(font_ptr as isize) = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 46i32) as isize,
    ))
    .b32
    .s1;
    *skew_char.offset(font_ptr as isize) = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 47i32) as isize,
    ))
    .b32
    .s1;
    *param_base.offset(font_ptr as isize) = fmem_ptr - 1i32;
    let ref mut fresh51 = *font_layout_engine.offset(font_ptr as isize);
    *fresh51 = font_engine;
    let ref mut fresh52 = *font_mapping.offset(font_ptr as isize);
    *fresh52 = 0 as *mut libc::c_void;
    *font_letter_space.offset(font_ptr as isize) = loaded_font_letter_space;
    /* "measure the width of the space character and set up font parameters" */
    p = new_native_character(font_ptr, ' ' as i32); /* space_stretch */
    s = (*mem.offset((p + 1i32) as isize)).b32.s1 + loaded_font_letter_space; /* space_shrink */
    free_node(p, (*mem.offset((p + 4i32) as isize)).b16.s3 as i32); /* quad */
    let fresh53 = fmem_ptr; /* extra_space */
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh53 as isize)).b32.s1 = font_slant;
    let fresh54 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh54 as isize)).b32.s1 = s;
    let fresh55 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh55 as isize)).b32.s1 = s / 2i32;
    let fresh56 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh56 as isize)).b32.s1 = s / 3i32;
    let fresh57 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh57 as isize)).b32.s1 = x_ht;
    let fresh58 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh58 as isize)).b32.s1 = *font_size.offset(font_ptr as isize);
    let fresh59 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh59 as isize)).b32.s1 = s / 3i32;
    let fresh60 = fmem_ptr;
    fmem_ptr = fmem_ptr + 1;
    (*font_info.offset(fresh60 as isize)).b32.s1 = cap_ht;
    if num_font_dimens == 65i32 {
        let fresh61 = fmem_ptr;
        fmem_ptr = fmem_ptr + 1;
        (*font_info.offset(fresh61 as isize)).b32.s1 = num_font_dimens;
        k = 0i32;
        while k <= 55i32 {
            /* 55 = lastMathConstant */
            let fresh62 = fmem_ptr; /*:582*/
            fmem_ptr = fmem_ptr + 1;
            (*font_info.offset(fresh62 as isize)).b32.s1 = get_ot_math_constant(font_ptr, k);
            k += 1
        }
    }
    let ref mut fresh63 = *font_mapping.offset(font_ptr as isize);
    *fresh63 = loaded_font_mapping;
    *font_flags.offset(font_ptr as isize) = loaded_font_flags;
    font_ptr
}
#[no_mangle]
pub unsafe extern "C" fn do_locale_linebreaks(mut s: i32, mut len: i32) {
    let mut offs: i32 = 0;
    let mut prevOffs: i32 = 0;
    let mut i: i32 = 0;
    let mut use_penalty: bool = false;
    let mut use_skip: bool = false;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 68i32) as isize,
    ))
    .b32
    .s1 == 0i32
        || len == 1i32
    {
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_native_word_node(main_f, len);
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        let mut for_end: i32 = 0;
        i = 0i32;
        for_end = len - 1i32;
        if i <= for_end {
            loop {
                *(&mut *mem.offset((cur_list.tail + 6i32) as isize) as *mut memory_word
                    as *mut u16)
                    .offset(i as isize) = *native_text.offset((s + i) as isize);
                let fresh64 = i;
                i = i + 1;
                if !(fresh64 < for_end) {
                    break;
                }
            }
        }
        measure_native_node(
            &mut *mem.offset(cur_list.tail as isize) as *mut memory_word as *mut libc::c_void,
            ((*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 74i32) as isize,
            ))
            .b32
            .s1 > 0i32) as i32,
        );
    } else {
        use_skip = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 15i32) as isize,
        ))
        .b32
        .s1 != 0i32;
        use_penalty = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 69i32) as isize,
        ))
        .b32
        .s1 != 0i32
            || !use_skip;
        linebreak_start(
            main_f,
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 68i32) as isize,
            ))
            .b32
            .s1,
            native_text.offset(s as isize),
            len,
        );
        offs = 0i32;
        loop {
            prevOffs = offs;
            offs = linebreak_next();
            if offs > 0i32 {
                if prevOffs != 0i32 {
                    if use_penalty {
                        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_penalty(
                            (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 69i32) as isize,
                            ))
                            .b32
                            .s1,
                        );
                        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
                    }
                    if use_skip {
                        (*mem.offset(cur_list.tail as isize)).b32.s1 =
                            new_param_glue(15i32 as small_number);
                        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
                    }
                }
                (*mem.offset(cur_list.tail as isize)).b32.s1 =
                    new_native_word_node(main_f, offs - prevOffs);
                cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                let mut for_end_0: i32 = 0;
                i = prevOffs;
                for_end_0 = offs - 1i32;
                if i <= for_end_0 {
                    loop {
                        *(&mut *mem.offset((cur_list.tail + 6i32) as isize) as *mut memory_word
                            as *mut u16)
                            .offset((i - prevOffs) as isize) =
                            *native_text.offset((s + i) as isize);
                        let fresh65 = i;
                        i = i + 1;
                        if !(fresh65 < for_end_0) {
                            break;
                        }
                    }
                }
                measure_native_node(
                    &mut *mem.offset(cur_list.tail as isize) as *mut memory_word
                        as *mut libc::c_void,
                    ((*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 74i32) as isize,
                    ))
                    .b32
                    .s1 > 0i32) as i32,
                );
            }
            if offs < 0i32 {
                break;
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn bad_utf8_warning() {
    begin_diagnostic();
    print_nl_cstr(b"Invalid UTF-8 byte or sequence\x00" as *const u8 as *const i8);
    if cur_input.name == 0i32 {
        print_cstr(b" in terminal input\x00" as *const u8 as *const i8);
    } else {
        print_cstr(b" at line \x00" as *const u8 as *const i8);
        print_int(line);
    }
    print_cstr(b" replaced by U+FFFD.\x00" as *const u8 as *const i8);
    end_diagnostic(false);
}
#[no_mangle]
pub unsafe extern "C" fn get_input_normalization_state() -> i32 {
    if eqtb.is_null() {
        0
    } else {
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 76i32) as isize,
        ))
        .b32
        .s1
    }
}
#[no_mangle]
pub unsafe extern "C" fn get_tracing_fonts_state() -> i32 {
    (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 79i32) as isize,
    ))
    .b32
    .s1
}
#[no_mangle]
pub unsafe extern "C" fn read_font_info(
    mut u: i32,
    mut nom: str_number,
    mut aire: str_number,
    mut s: scaled_t,
) -> internal_font_number {
    let mut current_block: u64;
    let mut k: font_index = 0;
    let mut name_too_long: bool = false;
    let mut file_opened: bool = false;
    let mut lf: i32 = 0;
    let mut lh: i32 = 0;
    let mut bc: i32 = 0;
    let mut ec: i32 = 0;
    let mut nw: i32 = 0;
    let mut nh: i32 = 0;
    let mut nd: i32 = 0;
    let mut ni: i32 = 0;
    let mut nl: i32 = 0;
    let mut nk: i32 = 0;
    let mut ne: i32 = 0;
    let mut np: i32 = 0;
    let mut f: internal_font_number = 0;
    let mut g: internal_font_number = 0;
    let mut a: i32 = 0;
    let mut b: i32 = 0;
    let mut c: i32 = 0;
    let mut d: i32 = 0;
    let mut qw: b16x4 = b16x4 {
        s0: 0,
        s1: 0,
        s2: 0,
        s3: 0,
    };
    let mut sw: scaled_t = 0;
    let mut bch_label: i32 = 0;
    let mut bchar_0: i16 = 0;
    let mut z: scaled_t = 0;
    let mut alpha: i32 = 0;
    let mut beta: u8 = 0;
    let mut tfm_file: rust_input_handle_t = 0 as *mut libc::c_void;
    g = 0i32;
    file_opened = false;
    pack_file_name(nom, aire, cur_ext);
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 79i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        begin_diagnostic();
        print_nl_cstr(b"Requested font \"\x00" as *const u8 as *const i8);
        print_c_string(name_of_file);
        print('\"' as i32);
        if s < 0i32 {
            print_cstr(b" scaled \x00" as *const u8 as *const i8);
            print_int(-s);
        } else {
            print_cstr(b" at \x00" as *const u8 as *const i8);
            print_scaled(s);
            print_cstr(b"pt\x00" as *const u8 as *const i8);
        }
        end_diagnostic(false);
    }
    if quoted_filename {
        g = load_native_font(u, nom, aire, s);
        if g != 0i32 {
            current_block = 15405907992539268277;
        } else {
            current_block = 13550086250199790493;
        }
    } else {
        current_block = 13550086250199790493;
    }
    match current_block {
        13550086250199790493 => {
            name_too_long = length(nom) > 255i32 || length(aire) > 255i32;
            if name_too_long {
                current_block = 9519785463931849731;
            } else {
                pack_file_name(nom, aire, (65536 + 1i32 as i64) as str_number);
                check_for_tfm_font_mapping();
                tfm_file = tt_xetex_open_input(TTInputFormat::TFM);
                if tfm_file.is_null() {
                    if !quoted_filename {
                        g = load_native_font(u, nom, aire, s);
                        if g != 0i32 {
                            current_block = 15405907992539268277;
                        } else {
                            current_block = 9519785463931849731;
                        }
                    } else {
                        current_block = 9519785463931849731;
                    }
                } else {
                    file_opened = true;
                    /* We are a bit cavalier about EOF-checking since we can't very
                     * conveniently implement feof() in the Rust layer, and it only ever is
                     * used in this one place. */
                    lf = ttstub_input_getc(tfm_file);
                    if lf > 127i32 || lf == -1i32 {
                        current_block = 9519785463931849731;
                    } else {
                        lf *= 256i32;
                        lf += ttstub_input_getc(tfm_file);
                        lh = ttstub_input_getc(tfm_file);
                        if lh > 127i32 || lh == -1i32 {
                            current_block = 9519785463931849731;
                        } else {
                            lh *= 256i32;
                            lh += ttstub_input_getc(tfm_file);
                            bc = ttstub_input_getc(tfm_file);
                            if bc > 127i32 || bc == -1i32 {
                                current_block = 9519785463931849731;
                            } else {
                                bc *= 256i32;
                                bc += ttstub_input_getc(tfm_file);
                                ec = ttstub_input_getc(tfm_file);
                                if ec > 127i32 || ec == -1i32 {
                                    current_block = 9519785463931849731;
                                } else {
                                    ec *= 256i32;
                                    ec += ttstub_input_getc(tfm_file);
                                    if bc > ec + 1i32 || ec > 255i32 {
                                        current_block = 9519785463931849731;
                                    } else {
                                        if bc > 255i32 {
                                            bc = 1i32;
                                            ec = 0i32
                                        }
                                        nw = ttstub_input_getc(tfm_file);
                                        if nw > 127i32 || nw == -1i32 {
                                            current_block = 9519785463931849731;
                                        } else {
                                            nw *= 256i32;
                                            nw += ttstub_input_getc(tfm_file);
                                            nh = ttstub_input_getc(tfm_file);
                                            if nh > 127i32 || nh == -1i32 {
                                                current_block = 9519785463931849731;
                                            } else {
                                                nh *= 256i32;
                                                nh += ttstub_input_getc(tfm_file);
                                                nd = ttstub_input_getc(tfm_file);
                                                if nd > 127i32 || nd == -1i32 {
                                                    current_block = 9519785463931849731;
                                                } else {
                                                    nd *= 256i32;
                                                    nd += ttstub_input_getc(tfm_file);
                                                    ni = ttstub_input_getc(tfm_file);
                                                    if ni > 127i32 || ni == -1i32 {
                                                        current_block = 9519785463931849731;
                                                    } else {
                                                        ni *= 256i32;
                                                        ni += ttstub_input_getc(tfm_file);
                                                        nl = ttstub_input_getc(tfm_file);
                                                        if nl > 127i32 || nl == -1i32 {
                                                            current_block = 9519785463931849731;
                                                        } else {
                                                            nl *= 256i32;
                                                            nl += ttstub_input_getc(tfm_file);
                                                            nk = ttstub_input_getc(tfm_file);
                                                            if nk > 127i32 || nk == -1i32 {
                                                                current_block = 9519785463931849731;
                                                            } else {
                                                                nk *= 256i32;
                                                                nk += ttstub_input_getc(tfm_file);
                                                                ne = ttstub_input_getc(tfm_file);
                                                                if ne > 127i32 || ne == -1i32 {
                                                                    current_block =
                                                                        9519785463931849731;
                                                                } else {
                                                                    ne *= 256i32;
                                                                    ne +=
                                                                        ttstub_input_getc(tfm_file);
                                                                    np =
                                                                        ttstub_input_getc(tfm_file);
                                                                    if np > 127i32 || np == -1i32 {
                                                                        current_block =
                                                                            9519785463931849731;
                                                                    } else {
                                                                        np *= 256i32;
                                                                        np += ttstub_input_getc(
                                                                            tfm_file,
                                                                        );
                                                                        if lf
                                                                            != 6i32
                                                                                + lh
                                                                                + (ec - bc + 1i32)
                                                                                + nw
                                                                                + nh
                                                                                + nd
                                                                                + ni
                                                                                + nl
                                                                                + nk
                                                                                + ne
                                                                                + np
                                                                        {
                                                                            current_block =
                                                                                9519785463931849731;
                                                                        } else if nw == 0i32
                                                                            || nh == 0i32
                                                                            || nd == 0i32
                                                                            || ni == 0i32
                                                                        {
                                                                            current_block =
                                                                                9519785463931849731;
                                                                        } else {
                                                                            lf = lf - 6i32 - lh;
                                                                            if np < 7i32 {
                                                                                lf = lf + 7i32 - np
                                                                            }
                                                                            assert!(!(font_ptr == font_max
                                                                                || fmem_ptr + lf
                                                                                    > font_mem_size), "not enough memory to load another font");
                                                                            f = font_ptr + 1i32;
                                                                            *char_base.offset(
                                                                                f as isize,
                                                                            ) = fmem_ptr - bc;
                                                                            *width_base.offset(
                                                                                f as isize,
                                                                            ) = *char_base
                                                                                .offset(f as isize)
                                                                                + ec
                                                                                + 1i32;
                                                                            *height_base.offset(
                                                                                f as isize,
                                                                            ) = *width_base
                                                                                .offset(f as isize)
                                                                                + nw;
                                                                            *depth_base.offset(
                                                                                f as isize,
                                                                            ) = *height_base
                                                                                .offset(f as isize)
                                                                                + nh;
                                                                            *italic_base.offset(
                                                                                f as isize,
                                                                            ) = *depth_base
                                                                                .offset(f as isize)
                                                                                + nd;
                                                                            *lig_kern_base
                                                                                .offset(
                                                                                    f as isize,
                                                                                ) = *italic_base
                                                                                .offset(f as isize)
                                                                                + ni;
                                                                            *kern_base.offset(
                                                                                f as isize,
                                                                            ) = *lig_kern_base
                                                                                .offset(f as isize)
                                                                                + nl
                                                                                - 256i32 * 128i32;
                                                                            *exten_base.offset(
                                                                                f as isize,
                                                                            ) = *kern_base
                                                                                .offset(f as isize)
                                                                                + 256i32 * 128i32
                                                                                + nk;
                                                                            *param_base.offset(
                                                                                f as isize,
                                                                            ) = *exten_base
                                                                                .offset(f as isize)
                                                                                + ne;
                                                                            if lh < 2i32 {
                                                                                current_block
                                                                                    =
                                                                                    9519785463931849731;
                                                                            } else {
                                                                                a
                                                                                    =
                                                                                    ttstub_input_getc(tfm_file);
                                                                                qw.s3 = a as u16;
                                                                                b
                                                                                    =
                                                                                    ttstub_input_getc(tfm_file);
                                                                                qw.s2 = b as u16;
                                                                                c
                                                                                    =
                                                                                    ttstub_input_getc(tfm_file);
                                                                                qw.s1 = c as u16;
                                                                                d
                                                                                    =
                                                                                    ttstub_input_getc(tfm_file);
                                                                                qw.s0 = d as u16;
                                                                                if a == -1i32
                                                                                    || b == -1i32
                                                                                    || c == -1i32
                                                                                    || d == -1i32
                                                                                {
                                                                                    current_block
                                                                                        =
                                                                                        9519785463931849731;
                                                                                } else {
                                                                                    *font_check
                                                                                        .offset(
                                                                                        f as isize,
                                                                                    ) = qw;
                                                                                    z
                                                                                        =
                                                                                        ttstub_input_getc(tfm_file);
                                                                                    if z > 127i32
                                                                                        || z
                                                                                            == -1i32
                                                                                    {
                                                                                        current_block
                                                                                            =
                                                                                            9519785463931849731;
                                                                                    } else {
                                                                                        z *= 256i32;
                                                                                        z
                                                                                            +=
                                                                                            ttstub_input_getc(tfm_file);
                                                                                        z
                                                                                            =
                                                                                            z
                                                                                                *
                                                                                                256i32
                                                                                                +
                                                                                                ttstub_input_getc(tfm_file);
                                                                                        z
                                                                                            =
                                                                                            z
                                                                                                *
                                                                                                16i32
                                                                                                +
                                                                                                ttstub_input_getc(tfm_file)
                                                                                                    /
                                                                                                    16i32;
                                                                                        if (z
                                                                                            as i64)
                                                                                            < 65536
                                                                                        {
                                                                                            current_block
                                                                                                =
                                                                                                9519785463931849731;
                                                                                        } else {
                                                                                            while lh
                                                                                                      >
                                                                                                      2i32
                                                                                                  {
                                                                                                ttstub_input_getc(tfm_file);
                                                                                                ttstub_input_getc(tfm_file);
                                                                                                ttstub_input_getc(tfm_file);
                                                                                                ttstub_input_getc(tfm_file);
                                                                                                lh
                                                                                                    -=
                                                                                                    1
                                                                                            }
                                                                                            *font_dsize.offset(f
                                                                                                                   as
                                                                                                                   isize)
                                                                                                =
                                                                                                z;
                                                                                            if s
                                                                                                   !=
                                                                                                   -1000i32
                                                                                               {
                                                                                                if s
                                                                                                       >=
                                                                                                       0i32
                                                                                                   {
                                                                                                    z
                                                                                                        =
                                                                                                        s
                                                                                                } else {
                                                                                                    z
                                                                                                        =
                                                                                                        xn_over_d(z,
                                                                                                                  -s,
                                                                                                                  1000i32)
                                                                                                }
                                                                                            }
                                                                                            *font_size.offset(f
                                                                                                                  as
                                                                                                                  isize)
                                                                                                =
                                                                                                z;
                                                                                            k
                                                                                                =
                                                                                                fmem_ptr;
                                                                                            loop {
                                                                                                if !(k
                                                                                                         <=
                                                                                                         *width_base.offset(f
                                                                                                                                as
                                                                                                                                isize)
                                                                                                             -
                                                                                                             1i32)
                                                                                                   {
                                                                                                    current_block
                                                                                                        =
                                                                                                        10517665100358322178;
                                                                                                    break
                                                                                                        ;
                                                                                                }
                                                                                                a
                                                                                                    =
                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                qw.s3
                                                                                                    =
                                                                                                    a
                                                                                                        as
                                                                                                        u16;
                                                                                                b
                                                                                                    =
                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                qw.s2
                                                                                                    =
                                                                                                    b
                                                                                                        as
                                                                                                        u16;
                                                                                                c
                                                                                                    =
                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                qw.s1
                                                                                                    =
                                                                                                    c
                                                                                                        as
                                                                                                        u16;
                                                                                                d
                                                                                                    =
                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                qw.s0
                                                                                                    =
                                                                                                    d
                                                                                                        as
                                                                                                        u16;
                                                                                                if a
                                                                                                       ==
                                                                                                       -1i32
                                                                                                       ||
                                                                                                       b
                                                                                                           ==
                                                                                                           -1i32
                                                                                                       ||
                                                                                                       c
                                                                                                           ==
                                                                                                           -1i32
                                                                                                       ||
                                                                                                       d
                                                                                                           ==
                                                                                                           -1i32
                                                                                                   {
                                                                                                    current_block
                                                                                                        =
                                                                                                        9519785463931849731;
                                                                                                    break
                                                                                                        ;
                                                                                                }
                                                                                                (*font_info.offset(k
                                                                                                                       as
                                                                                                                       isize)).b16
                                                                                                    =
                                                                                                    qw;
                                                                                                if a
                                                                                                       >=
                                                                                                       nw
                                                                                                       ||
                                                                                                       b
                                                                                                           /
                                                                                                           16i32
                                                                                                           >=
                                                                                                           nh
                                                                                                       ||
                                                                                                       b
                                                                                                           %
                                                                                                           16i32
                                                                                                           >=
                                                                                                           nd
                                                                                                       ||
                                                                                                       c
                                                                                                           /
                                                                                                           4i32
                                                                                                           >=
                                                                                                           ni
                                                                                                   {
                                                                                                    current_block
                                                                                                        =
                                                                                                        9519785463931849731;
                                                                                                    break
                                                                                                        ;
                                                                                                }
                                                                                                match c
                                                                                                          %
                                                                                                          4i32
                                                                                                    {
                                                                                                    1
                                                                                                    =>
                                                                                                    {
                                                                                                        if d
                                                                                                               >=
                                                                                                               nl
                                                                                                           {
                                                                                                            current_block
                                                                                                                =
                                                                                                                9519785463931849731;
                                                                                                            break
                                                                                                                ;
                                                                                                        }
                                                                                                    }
                                                                                                    3
                                                                                                    =>
                                                                                                    {
                                                                                                        if d
                                                                                                               >=
                                                                                                               ne
                                                                                                           {
                                                                                                            current_block
                                                                                                                =
                                                                                                                9519785463931849731;
                                                                                                            break
                                                                                                                ;
                                                                                                        }
                                                                                                    }
                                                                                                    2
                                                                                                    =>
                                                                                                    {
                                                                                                        if d
                                                                                                               <
                                                                                                               bc
                                                                                                               ||
                                                                                                               d
                                                                                                                   >
                                                                                                                   ec
                                                                                                           {
                                                                                                            current_block
                                                                                                                =
                                                                                                                9519785463931849731;
                                                                                                            break
                                                                                                                ;
                                                                                                        }
                                                                                                        loop
                                                                                                             {
                                                                                                            if !(d
                                                                                                                     <
                                                                                                                     k
                                                                                                                         +
                                                                                                                         bc
                                                                                                                         -
                                                                                                                         fmem_ptr)
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    6644752249785531703;
                                                                                                                break
                                                                                                                    ;
                                                                                                            }
                                                                                                            qw
                                                                                                                =
                                                                                                                (*font_info.offset((*char_base.offset(f
                                                                                                                                                          as
                                                                                                                                                          isize)
                                                                                                                                        +
                                                                                                                                        d)
                                                                                                                                       as
                                                                                                                                       isize)).b16;
                                                                                                            if qw.s1
                                                                                                                   as
                                                                                                                   i32
                                                                                                                   %
                                                                                                                   4i32
                                                                                                                   !=
                                                                                                                   2i32
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    5832582820025303349;
                                                                                                                break
                                                                                                                    ;
                                                                                                            }
                                                                                                            d
                                                                                                                =
                                                                                                                qw.s0
                                                                                                                    as
                                                                                                                    i32
                                                                                                        }
                                                                                                        match current_block
                                                                                                            {
                                                                                                            5832582820025303349
                                                                                                            =>
                                                                                                            {
                                                                                                            }
                                                                                                            _
                                                                                                            =>
                                                                                                            {
                                                                                                                if d
                                                                                                                       ==
                                                                                                                       k
                                                                                                                           +
                                                                                                                           bc
                                                                                                                           -
                                                                                                                           fmem_ptr
                                                                                                                   {
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        9519785463931849731;
                                                                                                                    break
                                                                                                                        ;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _
                                                                                                    =>
                                                                                                    {
                                                                                                    }
                                                                                                }
                                                                                                k
                                                                                                    +=
                                                                                                    1
                                                                                            }
                                                                                            match current_block
                                                                                                {
                                                                                                9519785463931849731
                                                                                                =>
                                                                                                {
                                                                                                }
                                                                                                _
                                                                                                =>
                                                                                                {
                                                                                                    alpha
                                                                                                        =
                                                                                                        16i32;
                                                                                                    while z
                                                                                                              >=
                                                                                                              0x800000i32
                                                                                                          {
                                                                                                        z
                                                                                                            =
                                                                                                            z
                                                                                                                /
                                                                                                                2i32;
                                                                                                        alpha
                                                                                                            =
                                                                                                            alpha
                                                                                                                +
                                                                                                                alpha
                                                                                                    }
                                                                                                    beta
                                                                                                        =
                                                                                                        (256i32
                                                                                                             /
                                                                                                             alpha)
                                                                                                            as
                                                                                                            u8;
                                                                                                    alpha
                                                                                                        =
                                                                                                        alpha
                                                                                                            *
                                                                                                            z;
                                                                                                    k
                                                                                                        =
                                                                                                        *width_base.offset(f
                                                                                                                               as
                                                                                                                               isize);
                                                                                                    loop
                                                                                                         {
                                                                                                        if !(k
                                                                                                                 <=
                                                                                                                 *lig_kern_base.offset(f
                                                                                                                                           as
                                                                                                                                           isize)
                                                                                                                     -
                                                                                                                     1i32)
                                                                                                           {
                                                                                                            current_block
                                                                                                                =
                                                                                                                5127850565928544452;
                                                                                                            break
                                                                                                                ;
                                                                                                        }
                                                                                                        a
                                                                                                            =
                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                        b
                                                                                                            =
                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                        c
                                                                                                            =
                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                        d
                                                                                                            =
                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                        if a
                                                                                                               ==
                                                                                                               -1i32
                                                                                                               ||
                                                                                                               b
                                                                                                                   ==
                                                                                                                   -1i32
                                                                                                               ||
                                                                                                               c
                                                                                                                   ==
                                                                                                                   -1i32
                                                                                                               ||
                                                                                                               d
                                                                                                                   ==
                                                                                                                   -1i32
                                                                                                           {
                                                                                                            current_block
                                                                                                                =
                                                                                                                9519785463931849731;
                                                                                                            break
                                                                                                                ;
                                                                                                        }
                                                                                                        sw
                                                                                                            =
                                                                                                            ((d
                                                                                                                  *
                                                                                                                  z
                                                                                                                  /
                                                                                                                  256i32
                                                                                                                  +
                                                                                                                  c
                                                                                                                      *
                                                                                                                      z)
                                                                                                                 /
                                                                                                                 256i32
                                                                                                                 +
                                                                                                                 b
                                                                                                                     *
                                                                                                                     z)
                                                                                                                /
                                                                                                                beta
                                                                                                                    as
                                                                                                                    i32;
                                                                                                        if a
                                                                                                               ==
                                                                                                               0i32
                                                                                                           {
                                                                                                            (*font_info.offset(k
                                                                                                                                   as
                                                                                                                                   isize)).b32.s1
                                                                                                                =
                                                                                                                sw
                                                                                                        } else {
                                                                                                            if !(a
                                                                                                                     ==
                                                                                                                     255i32)
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    9519785463931849731;
                                                                                                                break
                                                                                                                    ;
                                                                                                            }
                                                                                                            (*font_info.offset(k
                                                                                                                                   as
                                                                                                                                   isize)).b32.s1
                                                                                                                =
                                                                                                                sw
                                                                                                                    -
                                                                                                                    alpha
                                                                                                        }
                                                                                                        k
                                                                                                            +=
                                                                                                            1
                                                                                                    }
                                                                                                    match current_block
                                                                                                        {
                                                                                                        9519785463931849731
                                                                                                        =>
                                                                                                        {
                                                                                                        }
                                                                                                        _
                                                                                                        =>
                                                                                                        {
                                                                                                            if (*font_info.offset(*width_base.offset(f
                                                                                                                                                         as
                                                                                                                                                         isize)
                                                                                                                                      as
                                                                                                                                      isize)).b32.s1
                                                                                                                   !=
                                                                                                                   0i32
                                                                                                               {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    9519785463931849731;
                                                                                                            } else if (*font_info.offset(*height_base.offset(f
                                                                                                                                                                 as
                                                                                                                                                                 isize)
                                                                                                                                             as
                                                                                                                                             isize)).b32.s1
                                                                                                                          !=
                                                                                                                          0i32
                                                                                                             {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    9519785463931849731;
                                                                                                            } else if (*font_info.offset(*depth_base.offset(f
                                                                                                                                                                as
                                                                                                                                                                isize)
                                                                                                                                             as
                                                                                                                                             isize)).b32.s1
                                                                                                                          !=
                                                                                                                          0i32
                                                                                                             {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    9519785463931849731;
                                                                                                            } else if (*font_info.offset(*italic_base.offset(f
                                                                                                                                                                 as
                                                                                                                                                                 isize)
                                                                                                                                             as
                                                                                                                                             isize)).b32.s1
                                                                                                                          !=
                                                                                                                          0i32
                                                                                                             {
                                                                                                                current_block
                                                                                                                    =
                                                                                                                    9519785463931849731;
                                                                                                            } else {
                                                                                                                bch_label
                                                                                                                    =
                                                                                                                    32767i32;
                                                                                                                bchar_0
                                                                                                                    =
                                                                                                                    256i32
                                                                                                                        as
                                                                                                                        i16;
                                                                                                                if nl
                                                                                                                       >
                                                                                                                       0i32
                                                                                                                   {
                                                                                                                    k
                                                                                                                        =
                                                                                                                        *lig_kern_base.offset(f
                                                                                                                                                  as
                                                                                                                                                  isize);
                                                                                                                    loop
                                                                                                                         {
                                                                                                                        if !(k
                                                                                                                                 <=
                                                                                                                                 *kern_base.offset(f
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                                     +
                                                                                                                                     256i32
                                                                                                                                         *
                                                                                                                                         128i32
                                                                                                                                     -
                                                                                                                                     1i32)
                                                                                                                           {
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                8038949400865391589;
                                                                                                                            break
                                                                                                                                ;
                                                                                                                        }
                                                                                                                        a
                                                                                                                            =
                                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                                        qw.s3
                                                                                                                            =
                                                                                                                            a
                                                                                                                                as
                                                                                                                                u16;
                                                                                                                        b
                                                                                                                            =
                                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                                        qw.s2
                                                                                                                            =
                                                                                                                            b
                                                                                                                                as
                                                                                                                                u16;
                                                                                                                        c
                                                                                                                            =
                                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                                        qw.s1
                                                                                                                            =
                                                                                                                            c
                                                                                                                                as
                                                                                                                                u16;
                                                                                                                        d
                                                                                                                            =
                                                                                                                            ttstub_input_getc(tfm_file);
                                                                                                                        qw.s0
                                                                                                                            =
                                                                                                                            d
                                                                                                                                as
                                                                                                                                u16;
                                                                                                                        if a
                                                                                                                               ==
                                                                                                                               -1i32
                                                                                                                               ||
                                                                                                                               b
                                                                                                                                   ==
                                                                                                                                   -1i32
                                                                                                                               ||
                                                                                                                               c
                                                                                                                                   ==
                                                                                                                                   -1i32
                                                                                                                               ||
                                                                                                                               d
                                                                                                                                   ==
                                                                                                                                   -1i32
                                                                                                                           {
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                9519785463931849731;
                                                                                                                            break
                                                                                                                                ;
                                                                                                                        }
                                                                                                                        (*font_info.offset(k
                                                                                                                                               as
                                                                                                                                               isize)).b16
                                                                                                                            =
                                                                                                                            qw;
                                                                                                                        if a
                                                                                                                               >
                                                                                                                               128i32
                                                                                                                           {
                                                                                                                            if 256i32
                                                                                                                                   *
                                                                                                                                   c
                                                                                                                                   +
                                                                                                                                   d
                                                                                                                                   >=
                                                                                                                                   nl
                                                                                                                               {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    9519785463931849731;
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                            if a
                                                                                                                                   ==
                                                                                                                                   255i32
                                                                                                                                   &&
                                                                                                                                   k
                                                                                                                                       ==
                                                                                                                                       *lig_kern_base.offset(f
                                                                                                                                                                 as
                                                                                                                                                                 isize)
                                                                                                                               {
                                                                                                                                bchar_0
                                                                                                                                    =
                                                                                                                                    b
                                                                                                                                        as
                                                                                                                                        i16
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            if b
                                                                                                                                   !=
                                                                                                                                   bchar_0
                                                                                                                                       as
                                                                                                                                       i32
                                                                                                                               {
                                                                                                                                if b
                                                                                                                                       <
                                                                                                                                       bc
                                                                                                                                       ||
                                                                                                                                       b
                                                                                                                                           >
                                                                                                                                           ec
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        9519785463931849731;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                                qw
                                                                                                                                    =
                                                                                                                                    (*font_info.offset((*char_base.offset(f
                                                                                                                                                                              as
                                                                                                                                                                              isize)
                                                                                                                                                            +
                                                                                                                                                            b)
                                                                                                                                                           as
                                                                                                                                                           isize)).b16;
                                                                                                                                if !(qw.s3
                                                                                                                                         as
                                                                                                                                         i32
                                                                                                                                         >
                                                                                                                                         0i32)
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        9519785463931849731;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            if c
                                                                                                                                   <
                                                                                                                                   128i32
                                                                                                                               {
                                                                                                                                if d
                                                                                                                                       <
                                                                                                                                       bc
                                                                                                                                       ||
                                                                                                                                       d
                                                                                                                                           >
                                                                                                                                           ec
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        9519785463931849731;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                                qw
                                                                                                                                    =
                                                                                                                                    (*font_info.offset((*char_base.offset(f
                                                                                                                                                                              as
                                                                                                                                                                              isize)
                                                                                                                                                            +
                                                                                                                                                            d)
                                                                                                                                                           as
                                                                                                                                                           isize)).b16;
                                                                                                                                if !(qw.s3
                                                                                                                                         as
                                                                                                                                         i32
                                                                                                                                         >
                                                                                                                                         0i32)
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        9519785463931849731;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                            } else if 256i32
                                                                                                                                          *
                                                                                                                                          (c
                                                                                                                                               -
                                                                                                                                               128i32)
                                                                                                                                          +
                                                                                                                                          d
                                                                                                                                          >=
                                                                                                                                          nk
                                                                                                                             {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    9519785463931849731;
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                            if a
                                                                                                                                   <
                                                                                                                                   128i32
                                                                                                                                   &&
                                                                                                                                   k
                                                                                                                                       -
                                                                                                                                       *lig_kern_base.offset(f
                                                                                                                                                                 as
                                                                                                                                                                 isize)
                                                                                                                                       +
                                                                                                                                       a
                                                                                                                                       +
                                                                                                                                       1i32
                                                                                                                                       >=
                                                                                                                                       nl
                                                                                                                               {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    9519785463931849731;
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        k
                                                                                                                            +=
                                                                                                                            1
                                                                                                                    }
                                                                                                                    match current_block
                                                                                                                        {
                                                                                                                        9519785463931849731
                                                                                                                        =>
                                                                                                                        {
                                                                                                                        }
                                                                                                                        _
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            if a
                                                                                                                                   ==
                                                                                                                                   255i32
                                                                                                                               {
                                                                                                                                bch_label
                                                                                                                                    =
                                                                                                                                    256i32
                                                                                                                                        *
                                                                                                                                        c
                                                                                                                                        +
                                                                                                                                        d
                                                                                                                            }
                                                                                                                            current_block
                                                                                                                                =
                                                                                                                                2311897482351547615;
                                                                                                                        }
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    current_block
                                                                                                                        =
                                                                                                                        2311897482351547615;
                                                                                                                }
                                                                                                                match current_block
                                                                                                                    {
                                                                                                                    9519785463931849731
                                                                                                                    =>
                                                                                                                    {
                                                                                                                    }
                                                                                                                    _
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        k
                                                                                                                            =
                                                                                                                            *kern_base.offset(f
                                                                                                                                                  as
                                                                                                                                                  isize)
                                                                                                                                +
                                                                                                                                256i32
                                                                                                                                    *
                                                                                                                                    128i32;
                                                                                                                        loop
                                                                                                                             {
                                                                                                                            if !(k
                                                                                                                                     <=
                                                                                                                                     *exten_base.offset(f
                                                                                                                                                            as
                                                                                                                                                            isize)
                                                                                                                                         -
                                                                                                                                         1i32)
                                                                                                                               {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    17034918949615525785;
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                            a
                                                                                                                                =
                                                                                                                                ttstub_input_getc(tfm_file);
                                                                                                                            b
                                                                                                                                =
                                                                                                                                ttstub_input_getc(tfm_file);
                                                                                                                            c
                                                                                                                                =
                                                                                                                                ttstub_input_getc(tfm_file);
                                                                                                                            d
                                                                                                                                =
                                                                                                                                ttstub_input_getc(tfm_file);
                                                                                                                            if a
                                                                                                                                   ==
                                                                                                                                   -1i32
                                                                                                                                   ||
                                                                                                                                   b
                                                                                                                                       ==
                                                                                                                                       -1i32
                                                                                                                                   ||
                                                                                                                                   c
                                                                                                                                       ==
                                                                                                                                       -1i32
                                                                                                                                   ||
                                                                                                                                   d
                                                                                                                                       ==
                                                                                                                                       -1i32
                                                                                                                               {
                                                                                                                                current_block
                                                                                                                                    =
                                                                                                                                    9519785463931849731;
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                            sw
                                                                                                                                =
                                                                                                                                ((d
                                                                                                                                      *
                                                                                                                                      z
                                                                                                                                      /
                                                                                                                                      256i32
                                                                                                                                      +
                                                                                                                                      c
                                                                                                                                          *
                                                                                                                                          z)
                                                                                                                                     /
                                                                                                                                     256i32
                                                                                                                                     +
                                                                                                                                     b
                                                                                                                                         *
                                                                                                                                         z)
                                                                                                                                    /
                                                                                                                                    beta
                                                                                                                                        as
                                                                                                                                        i32;
                                                                                                                            if a
                                                                                                                                   ==
                                                                                                                                   0i32
                                                                                                                               {
                                                                                                                                (*font_info.offset(k
                                                                                                                                                       as
                                                                                                                                                       isize)).b32.s1
                                                                                                                                    =
                                                                                                                                    sw
                                                                                                                            } else {
                                                                                                                                if !(a
                                                                                                                                         ==
                                                                                                                                         255i32)
                                                                                                                                   {
                                                                                                                                    current_block
                                                                                                                                        =
                                                                                                                                        9519785463931849731;
                                                                                                                                    break
                                                                                                                                        ;
                                                                                                                                }
                                                                                                                                (*font_info.offset(k
                                                                                                                                                       as
                                                                                                                                                       isize)).b32.s1
                                                                                                                                    =
                                                                                                                                    sw
                                                                                                                                        -
                                                                                                                                        alpha
                                                                                                                            }
                                                                                                                            k
                                                                                                                                +=
                                                                                                                                1
                                                                                                                        }
                                                                                                                        match current_block
                                                                                                                            {
                                                                                                                            9519785463931849731
                                                                                                                            =>
                                                                                                                            {
                                                                                                                            }
                                                                                                                            _
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                k
                                                                                                                                    =
                                                                                                                                    *exten_base.offset(f
                                                                                                                                                           as
                                                                                                                                                           isize);
                                                                                                                                loop
                                                                                                                                     {
                                                                                                                                    if !(k
                                                                                                                                             <=
                                                                                                                                             *param_base.offset(f
                                                                                                                                                                    as
                                                                                                                                                                    isize)
                                                                                                                                                 -
                                                                                                                                                 1i32)
                                                                                                                                       {
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            7906414799753328446;
                                                                                                                                        break
                                                                                                                                            ;
                                                                                                                                    }
                                                                                                                                    a
                                                                                                                                        =
                                                                                                                                        ttstub_input_getc(tfm_file);
                                                                                                                                    qw.s3
                                                                                                                                        =
                                                                                                                                        a
                                                                                                                                            as
                                                                                                                                            u16;
                                                                                                                                    b
                                                                                                                                        =
                                                                                                                                        ttstub_input_getc(tfm_file);
                                                                                                                                    qw.s2
                                                                                                                                        =
                                                                                                                                        b
                                                                                                                                            as
                                                                                                                                            u16;
                                                                                                                                    c
                                                                                                                                        =
                                                                                                                                        ttstub_input_getc(tfm_file);
                                                                                                                                    qw.s1
                                                                                                                                        =
                                                                                                                                        c
                                                                                                                                            as
                                                                                                                                            u16;
                                                                                                                                    d
                                                                                                                                        =
                                                                                                                                        ttstub_input_getc(tfm_file);
                                                                                                                                    qw.s0
                                                                                                                                        =
                                                                                                                                        d
                                                                                                                                            as
                                                                                                                                            u16;
                                                                                                                                    if a
                                                                                                                                           ==
                                                                                                                                           -1i32
                                                                                                                                           ||
                                                                                                                                           b
                                                                                                                                               ==
                                                                                                                                               -1i32
                                                                                                                                           ||
                                                                                                                                           c
                                                                                                                                               ==
                                                                                                                                               -1i32
                                                                                                                                           ||
                                                                                                                                           d
                                                                                                                                               ==
                                                                                                                                               -1i32
                                                                                                                                       {
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            9519785463931849731;
                                                                                                                                        break
                                                                                                                                            ;
                                                                                                                                    }
                                                                                                                                    (*font_info.offset(k
                                                                                                                                                           as
                                                                                                                                                           isize)).b16
                                                                                                                                        =
                                                                                                                                        qw;
                                                                                                                                    if a
                                                                                                                                           !=
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        if a
                                                                                                                                               <
                                                                                                                                               bc
                                                                                                                                               ||
                                                                                                                                               a
                                                                                                                                                   >
                                                                                                                                                   ec
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                9519785463931849731;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                        qw
                                                                                                                                            =
                                                                                                                                            (*font_info.offset((*char_base.offset(f
                                                                                                                                                                                      as
                                                                                                                                                                                      isize)
                                                                                                                                                                    +
                                                                                                                                                                    a)
                                                                                                                                                                   as
                                                                                                                                                                   isize)).b16;
                                                                                                                                        if !(qw.s3
                                                                                                                                                 as
                                                                                                                                                 i32
                                                                                                                                                 >
                                                                                                                                                 0i32)
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                9519785463931849731;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    if b
                                                                                                                                           !=
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        if b
                                                                                                                                               <
                                                                                                                                               bc
                                                                                                                                               ||
                                                                                                                                               b
                                                                                                                                                   >
                                                                                                                                                   ec
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                9519785463931849731;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                        qw
                                                                                                                                            =
                                                                                                                                            (*font_info.offset((*char_base.offset(f
                                                                                                                                                                                      as
                                                                                                                                                                                      isize)
                                                                                                                                                                    +
                                                                                                                                                                    b)
                                                                                                                                                                   as
                                                                                                                                                                   isize)).b16;
                                                                                                                                        if !(qw.s3
                                                                                                                                                 as
                                                                                                                                                 i32
                                                                                                                                                 >
                                                                                                                                                 0i32)
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                9519785463931849731;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    if c
                                                                                                                                           !=
                                                                                                                                           0i32
                                                                                                                                       {
                                                                                                                                        if c
                                                                                                                                               <
                                                                                                                                               bc
                                                                                                                                               ||
                                                                                                                                               c
                                                                                                                                                   >
                                                                                                                                                   ec
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                9519785463931849731;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                        qw
                                                                                                                                            =
                                                                                                                                            (*font_info.offset((*char_base.offset(f
                                                                                                                                                                                      as
                                                                                                                                                                                      isize)
                                                                                                                                                                    +
                                                                                                                                                                    c)
                                                                                                                                                                   as
                                                                                                                                                                   isize)).b16;
                                                                                                                                        if !(qw.s3
                                                                                                                                                 as
                                                                                                                                                 i32
                                                                                                                                                 >
                                                                                                                                                 0i32)
                                                                                                                                           {
                                                                                                                                            current_block
                                                                                                                                                =
                                                                                                                                                9519785463931849731;
                                                                                                                                            break
                                                                                                                                                ;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    if d
                                                                                                                                           <
                                                                                                                                           bc
                                                                                                                                           ||
                                                                                                                                           d
                                                                                                                                               >
                                                                                                                                               ec
                                                                                                                                       {
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            9519785463931849731;
                                                                                                                                        break
                                                                                                                                            ;
                                                                                                                                    }
                                                                                                                                    qw
                                                                                                                                        =
                                                                                                                                        (*font_info.offset((*char_base.offset(f
                                                                                                                                                                                  as
                                                                                                                                                                                  isize)
                                                                                                                                                                +
                                                                                                                                                                d)
                                                                                                                                                               as
                                                                                                                                                               isize)).b16;
                                                                                                                                    if !(qw.s3
                                                                                                                                             as
                                                                                                                                             i32
                                                                                                                                             >
                                                                                                                                             0i32)
                                                                                                                                       {
                                                                                                                                        current_block
                                                                                                                                            =
                                                                                                                                            9519785463931849731;
                                                                                                                                        break
                                                                                                                                            ;
                                                                                                                                    }
                                                                                                                                    k
                                                                                                                                        +=
                                                                                                                                        1
                                                                                                                                }
                                                                                                                                match current_block
                                                                                                                                    {
                                                                                                                                    9519785463931849731
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                    }
                                                                                                                                    _
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        k
                                                                                                                                            =
                                                                                                                                            1i32;
                                                                                                                                        loop
                                                                                                                                             {
                                                                                                                                            if !(k
                                                                                                                                                     <=
                                                                                                                                                     np)
                                                                                                                                               {
                                                                                                                                                current_block
                                                                                                                                                    =
                                                                                                                                                    12244237646329523438;
                                                                                                                                                break
                                                                                                                                                    ;
                                                                                                                                            }
                                                                                                                                            if k
                                                                                                                                                   ==
                                                                                                                                                   1i32
                                                                                                                                               {
                                                                                                                                                sw
                                                                                                                                                    =
                                                                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                                                                if sw
                                                                                                                                                       ==
                                                                                                                                                       -1i32
                                                                                                                                                   {
                                                                                                                                                    current_block
                                                                                                                                                        =
                                                                                                                                                        9519785463931849731;
                                                                                                                                                    break
                                                                                                                                                        ;
                                                                                                                                                }
                                                                                                                                                if sw
                                                                                                                                                       >
                                                                                                                                                       127i32
                                                                                                                                                   {
                                                                                                                                                    sw
                                                                                                                                                        =
                                                                                                                                                        sw
                                                                                                                                                            -
                                                                                                                                                            256i32
                                                                                                                                                }
                                                                                                                                                sw
                                                                                                                                                    =
                                                                                                                                                    sw
                                                                                                                                                        *
                                                                                                                                                        256i32
                                                                                                                                                        +
                                                                                                                                                        ttstub_input_getc(tfm_file);
                                                                                                                                                sw
                                                                                                                                                    =
                                                                                                                                                    sw
                                                                                                                                                        *
                                                                                                                                                        256i32
                                                                                                                                                        +
                                                                                                                                                        ttstub_input_getc(tfm_file);
                                                                                                                                                (*font_info.offset(*param_base.offset(f
                                                                                                                                                                                          as
                                                                                                                                                                                          isize)
                                                                                                                                                                       as
                                                                                                                                                                       isize)).b32.s1
                                                                                                                                                    =
                                                                                                                                                    sw
                                                                                                                                                        *
                                                                                                                                                        16i32
                                                                                                                                                        +
                                                                                                                                                        ttstub_input_getc(tfm_file)
                                                                                                                                                            /
                                                                                                                                                            16i32
                                                                                                                                            } else {
                                                                                                                                                a
                                                                                                                                                    =
                                                                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                                                                b
                                                                                                                                                    =
                                                                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                                                                c
                                                                                                                                                    =
                                                                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                                                                d
                                                                                                                                                    =
                                                                                                                                                    ttstub_input_getc(tfm_file);
                                                                                                                                                if a
                                                                                                                                                       ==
                                                                                                                                                       -1i32
                                                                                                                                                       ||
                                                                                                                                                       b
                                                                                                                                                           ==
                                                                                                                                                           -1i32
                                                                                                                                                       ||
                                                                                                                                                       c
                                                                                                                                                           ==
                                                                                                                                                           -1i32
                                                                                                                                                       ||
                                                                                                                                                       d
                                                                                                                                                           ==
                                                                                                                                                           -1i32
                                                                                                                                                   {
                                                                                                                                                    current_block
                                                                                                                                                        =
                                                                                                                                                        9519785463931849731;
                                                                                                                                                    break
                                                                                                                                                        ;
                                                                                                                                                }
                                                                                                                                                sw
                                                                                                                                                    =
                                                                                                                                                    ((d
                                                                                                                                                          *
                                                                                                                                                          z
                                                                                                                                                          /
                                                                                                                                                          256i32
                                                                                                                                                          +
                                                                                                                                                          c
                                                                                                                                                              *
                                                                                                                                                              z)
                                                                                                                                                         /
                                                                                                                                                         256i32
                                                                                                                                                         +
                                                                                                                                                         b
                                                                                                                                                             *
                                                                                                                                                             z)
                                                                                                                                                        /
                                                                                                                                                        beta
                                                                                                                                                            as
                                                                                                                                                            i32;
                                                                                                                                                if a
                                                                                                                                                       ==
                                                                                                                                                       0i32
                                                                                                                                                   {
                                                                                                                                                    (*font_info.offset((*param_base.offset(f
                                                                                                                                                                                               as
                                                                                                                                                                                               isize)
                                                                                                                                                                            +
                                                                                                                                                                            k
                                                                                                                                                                            -
                                                                                                                                                                            1i32)
                                                                                                                                                                           as
                                                                                                                                                                           isize)).b32.s1
                                                                                                                                                        =
                                                                                                                                                        sw
                                                                                                                                                } else {
                                                                                                                                                    if !(a
                                                                                                                                                             ==
                                                                                                                                                             255i32)
                                                                                                                                                       {
                                                                                                                                                        current_block
                                                                                                                                                            =
                                                                                                                                                            9519785463931849731;
                                                                                                                                                        break
                                                                                                                                                            ;
                                                                                                                                                    }
                                                                                                                                                    (*font_info.offset((*param_base.offset(f
                                                                                                                                                                                               as
                                                                                                                                                                                               isize)
                                                                                                                                                                            +
                                                                                                                                                                            k
                                                                                                                                                                            -
                                                                                                                                                                            1i32)
                                                                                                                                                                           as
                                                                                                                                                                           isize)).b32.s1
                                                                                                                                                        =
                                                                                                                                                        sw
                                                                                                                                                            -
                                                                                                                                                            alpha
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            k
                                                                                                                                                +=
                                                                                                                                                1
                                                                                                                                        }
                                                                                                                                        match current_block
                                                                                                                                            {
                                                                                                                                            9519785463931849731
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                            }
                                                                                                                                            _
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                k
                                                                                                                                                    =
                                                                                                                                                    np
                                                                                                                                                        +
                                                                                                                                                        1i32;
                                                                                                                                                while k
                                                                                                                                                          <=
                                                                                                                                                          7i32
                                                                                                                                                      {
                                                                                                                                                    (*font_info.offset((*param_base.offset(f
                                                                                                                                                                                               as
                                                                                                                                                                                               isize)
                                                                                                                                                                            +
                                                                                                                                                                            k
                                                                                                                                                                            -
                                                                                                                                                                            1i32)
                                                                                                                                                                           as
                                                                                                                                                                           isize)).b32.s1
                                                                                                                                                        =
                                                                                                                                                        0i32;
                                                                                                                                                    k
                                                                                                                                                        +=
                                                                                                                                                        1
                                                                                                                                                }
                                                                                                                                                if np
                                                                                                                                                       >=
                                                                                                                                                       7i32
                                                                                                                                                   {
                                                                                                                                                    *font_params.offset(f
                                                                                                                                                                            as
                                                                                                                                                                            isize)
                                                                                                                                                        =
                                                                                                                                                        np
                                                                                                                                                } else {
                                                                                                                                                    *font_params.offset(f
                                                                                                                                                                            as
                                                                                                                                                                            isize)
                                                                                                                                                        =
                                                                                                                                                        7i32
                                                                                                                                                }
                                                                                                                                                *hyphen_char.offset(f
                                                                                                                                                                        as
                                                                                                                                                                        isize)
                                                                                                                                                    =
                                                                                                                                                    (*eqtb.offset((1i32
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       15000i32
                                                                                                                                                                       +
                                                                                                                                                                       12i32
                                                                                                                                                                       +
                                                                                                                                                                       9000i32
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       19i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       13i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       4i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       3i32
                                                                                                                                                                           *
                                                                                                                                                                           256i32
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       46i32)
                                                                                                                                                                      as
                                                                                                                                                                      isize)).b32.s1;
                                                                                                                                                *skew_char.offset(f
                                                                                                                                                                      as
                                                                                                                                                                      isize)
                                                                                                                                                    =
                                                                                                                                                    (*eqtb.offset((1i32
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       15000i32
                                                                                                                                                                       +
                                                                                                                                                                       12i32
                                                                                                                                                                       +
                                                                                                                                                                       9000i32
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       19i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       13i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       4i32
                                                                                                                                                                       +
                                                                                                                                                                       256i32
                                                                                                                                                                       +
                                                                                                                                                                       1i32
                                                                                                                                                                       +
                                                                                                                                                                       3i32
                                                                                                                                                                           *
                                                                                                                                                                           256i32
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       (0x10ffffi32
                                                                                                                                                                            +
                                                                                                                                                                            1i32)
                                                                                                                                                                       +
                                                                                                                                                                       47i32)
                                                                                                                                                                      as
                                                                                                                                                                      isize)).b32.s1;
                                                                                                                                                if bch_label
                                                                                                                                                       <
                                                                                                                                                       nl
                                                                                                                                                   {
                                                                                                                                                    *bchar_label.offset(f
                                                                                                                                                                            as
                                                                                                                                                                            isize)
                                                                                                                                                        =
                                                                                                                                                        bch_label
                                                                                                                                                            +
                                                                                                                                                            *lig_kern_base.offset(f
                                                                                                                                                                                      as
                                                                                                                                                                                      isize)
                                                                                                                                                } else {
                                                                                                                                                    *bchar_label.offset(f
                                                                                                                                                                            as
                                                                                                                                                                            isize)
                                                                                                                                                        =
                                                                                                                                                        0i32
                                                                                                                                                }
                                                                                                                                                *font_bchar.offset(f
                                                                                                                                                                       as
                                                                                                                                                                       isize)
                                                                                                                                                    =
                                                                                                                                                    bchar_0
                                                                                                                                                        as
                                                                                                                                                        nine_bits;
                                                                                                                                                *font_false_bchar.offset(f
                                                                                                                                                                             as
                                                                                                                                                                             isize)
                                                                                                                                                    =
                                                                                                                                                    bchar_0
                                                                                                                                                        as
                                                                                                                                                        nine_bits;
                                                                                                                                                if bchar_0
                                                                                                                                                       as
                                                                                                                                                       i32
                                                                                                                                                       <=
                                                                                                                                                       ec
                                                                                                                                                   {
                                                                                                                                                    if bchar_0
                                                                                                                                                           as
                                                                                                                                                           i32
                                                                                                                                                           >=
                                                                                                                                                           bc
                                                                                                                                                       {
                                                                                                                                                        qw
                                                                                                                                                            =
                                                                                                                                                            (*font_info.offset((*char_base.offset(f
                                                                                                                                                                                                      as
                                                                                                                                                                                                      isize)
                                                                                                                                                                                    +
                                                                                                                                                                                    bchar_0
                                                                                                                                                                                        as
                                                                                                                                                                                        i32)
                                                                                                                                                                                   as
                                                                                                                                                                                   isize)).b16;
                                                                                                                                                        if qw.s3
                                                                                                                                                               as
                                                                                                                                                               i32
                                                                                                                                                               >
                                                                                                                                                               0i32
                                                                                                                                                           {
                                                                                                                                                            *font_false_bchar.offset(f
                                                                                                                                                                                         as
                                                                                                                                                                                         isize)
                                                                                                                                                                =
                                                                                                                                                                65536i32
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                *font_name.offset(f
                                                                                                                                                                      as
                                                                                                                                                                      isize)
                                                                                                                                                    =
                                                                                                                                                    nom;
                                                                                                                                                font_area[f as usize] = aire as i32;
                                                                                                                                                *font_bc.offset(f
                                                                                                                                                                    as
                                                                                                                                                                    isize)
                                                                                                                                                    =
                                                                                                                                                    bc
                                                                                                                                                        as
                                                                                                                                                        UTF16_code;
                                                                                                                                                *font_ec.offset(f
                                                                                                                                                                    as
                                                                                                                                                                    isize)
                                                                                                                                                    =
                                                                                                                                                    ec
                                                                                                                                                        as
                                                                                                                                                        UTF16_code;
                                                                                                                                                *font_glue.offset(f
                                                                                                                                                                      as
                                                                                                                                                                      isize)
                                                                                                                                                    =
                                                                                                                                                    -0xfffffffi32;
                                                                                                                                                let ref mut fresh66 =
                                                                                                                                                    *param_base.offset(f
                                                                                                                                                                           as
                                                                                                                                                                           isize);
                                                                                                                                                *fresh66
                                                                                                                                                    -=
                                                                                                                                                    1;
                                                                                                                                                fmem_ptr
                                                                                                                                                    =
                                                                                                                                                    fmem_ptr
                                                                                                                                                        +
                                                                                                                                                        lf;
                                                                                                                                                font_ptr
                                                                                                                                                    =
                                                                                                                                                    f;
                                                                                                                                                g
                                                                                                                                                    =
                                                                                                                                                    f;
                                                                                                                                                let ref mut fresh67 =
                                                                                                                                                    *font_mapping.offset(f
                                                                                                                                                                             as
                                                                                                                                                                             isize);
                                                                                                                                                *fresh67
                                                                                                                                                    =
                                                                                                                                                    load_tfm_font_mapping();
                                                                                                                                                current_block
                                                                                                                                                    =
                                                                                                                                                    15405907992539268277;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                15405907992539268277 => {}
                _ => {
                    if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 67i32) as isize,
                    ))
                    .b32
                    .s1 == 0i32
                    {
                        /* NOTE: must preserve this path to keep passing the TRIP tests */
                        if file_line_error_style_p != 0 {
                            print_file_line(); /*:673 */
                        } else {
                            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                        }
                        print_cstr(b"Font \x00" as *const u8 as *const i8);
                        sprint_cs(u);
                        print_char('=' as i32);
                        if file_name_quote_char as i32 != 0i32 {
                            print_char(file_name_quote_char as i32);
                        }
                        print_file_name(nom, aire, cur_ext);
                        if file_name_quote_char as i32 != 0i32 {
                            print_char(file_name_quote_char as i32);
                        }
                        if s >= 0i32 {
                            print_cstr(b" at \x00" as *const u8 as *const i8);
                            print_scaled(s);
                            print_cstr(b"pt\x00" as *const u8 as *const i8);
                        } else if s != -1000i32 {
                            print_cstr(b" scaled \x00" as *const u8 as *const i8);
                            print_int(-s);
                        }
                        if file_opened {
                            print_cstr(
                                b" not loadable: Bad metric (TFM) file\x00" as *const u8
                                    as *const i8,
                            );
                        } else if name_too_long {
                            print_cstr(
                                b" not loadable: Metric (TFM) file name too long\x00" as *const u8
                                    as *const i8,
                            );
                        } else {
                            print_cstr(
                                b" not loadable: Metric (TFM) file or installed font not found\x00"
                                    as *const u8 as *const i8,
                            );
                        }
                        help_ptr = 5_u8;
                        help_line[4] = b"I wasn\'t able to read the size data for this font,\x00"
                            as *const u8 as *const i8;
                        help_line[3] = b"so I will ignore the font specification.\x00" as *const u8
                            as *const i8;
                        help_line[2] = b"[Wizards can fix TFM files using TFtoPL/PLtoTF.]\x00"
                            as *const u8 as *const i8;
                        help_line[1] = b"You might try inserting a different font spec;\x00"
                            as *const u8 as *const i8;
                        help_line[0] =
                            b"e.g., type `I\\font<same font id>=<substitute font name>\'.\x00"
                                as *const u8 as *const i8;
                        error();
                    }
                }
            }
        }
        _ => {}
    }
    if file_opened {
        ttstub_input_close(tfm_file);
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 79i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        if g == 0i32 {
            begin_diagnostic();
            print_nl_cstr(b" -> font not found, using \"nullfont\"\x00" as *const u8 as *const i8);
            end_diagnostic(false);
        } else if file_opened {
            begin_diagnostic();
            print_nl_cstr(b" -> \x00" as *const u8 as *const i8);
            print_c_string(name_of_file);
            end_diagnostic(false);
        }
    }
    g
}
#[no_mangle]
pub unsafe extern "C" fn new_character(mut f: internal_font_number, mut c: UTF16_code) -> i32 {
    let mut p: i32 = 0;
    let mut ec: u16 = 0;
    if font_area[f as usize] as u32 == 0xffffu32
        || font_area[f as usize] as u32 == 0xfffeu32
    {
        return new_native_character(f, c as UnicodeScalar);
    }
    ec = effective_char(false, f, c) as u16;
    if *font_bc.offset(f as isize) as i32 <= ec as i32 {
        if *font_ec.offset(f as isize) as i32 >= ec as i32 {
            if (*font_info.offset((*char_base.offset(f as isize) + ec as i32) as isize))
                .b16
                .s3 as i32
                > 0i32
            {
                p = get_avail();
                (*mem.offset(p as isize)).b16.s1 = f as u16;
                (*mem.offset(p as isize)).b16.s0 = c;
                return p;
            }
        }
    }
    char_warning(f, c as i32);
    -0xfffffffi32
}
#[no_mangle]
pub unsafe extern "C" fn scan_spec(mut c: group_code, mut three_codes: bool) {
    let mut current_block: u64;
    let mut s: i32 = 0;
    let mut spec_code: u8 = 0;
    if three_codes {
        s = (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1
    }
    if scan_keyword(b"to\x00" as *const u8 as *const i8) {
        spec_code = 0_u8;
        current_block = 8515828400728868193;
    } else if scan_keyword(b"spread\x00" as *const u8 as *const i8) {
        spec_code = 1_u8;
        current_block = 8515828400728868193;
    } else {
        spec_code = 1_u8;
        cur_val = 0i32;
        current_block = 4427475217998452135;
    }
    match current_block {
        8515828400728868193 => {
            scan_dimen(false, false, false);
        }
        _ => {}
    }
    if three_codes {
        (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 = s;
        save_ptr += 1
    }
    (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 = spec_code as i32;
    (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1 = cur_val;
    save_ptr = save_ptr + 2i32;
    new_save_level(c);
    scan_left_brace();
}
#[no_mangle]
pub unsafe extern "C" fn char_pw(mut p: i32, mut side: small_number) -> scaled_t {
    let mut f: internal_font_number = 0;
    let mut c: i32 = 0;
    if side as i32 == 0i32 {
        last_leftmost_char = -0xfffffffi32
    } else {
        last_rightmost_char = -0xfffffffi32
    }
    if p == -0xfffffffi32 {
        return 0i32;
    }
    if p != -0xfffffffi32
        && !is_char_node(p)
        && (*mem.offset(p as isize)).b16.s1 as i32 == 8i32
        && ((*mem.offset(p as isize)).b16.s0 as i32 == 40i32
            || (*mem.offset(p as isize)).b16.s0 as i32 == 41i32)
    {
        if !(*mem.offset((p + 5i32) as isize)).ptr.is_null() {
            f = (*mem.offset((p + 4i32) as isize)).b16.s2 as internal_font_number;
            return round_xn_over_d(
                (*font_info.offset((6i32 + *param_base.offset(f as isize)) as isize))
                    .b32
                    .s1,
                real_get_native_word_cp(
                    &mut *mem.offset(p as isize) as *mut memory_word as *mut libc::c_void,
                    side as i32,
                ),
                1000i32,
            );
        } else {
            return 0i32;
        }
    }
    if p != -0xfffffffi32
        && !is_char_node(p)
        && (*mem.offset(p as isize)).b16.s1 as i32 == 8i32
        && (*mem.offset(p as isize)).b16.s0 as i32 == 42i32
    {
        f = (*mem.offset((p + 4i32) as isize)).b16.s2 as internal_font_number;
        return round_xn_over_d(
            (*font_info.offset((6i32 + *param_base.offset(f as isize)) as isize))
                .b32
                .s1,
            get_cp_code(
                f,
                (*mem.offset((p + 4i32) as isize)).b16.s1 as u32,
                side as i32,
            ),
            1000i32,
        );
    }
    if !is_char_node(p) {
        if (*mem.offset(p as isize)).b16.s1 as i32 == 6i32 {
            p = p + 1i32
        } else {
            return 0i32;
        }
    }
    f = (*mem.offset(p as isize)).b16.s1 as internal_font_number;
    c = get_cp_code(f, (*mem.offset(p as isize)).b16.s0 as u32, side as i32);
    match side as i32 {
        0 => last_leftmost_char = p,
        1 => last_rightmost_char = p,
        _ => {}
    }
    if c == 0i32 {
        return 0i32;
    }
    round_xn_over_d(
        (*font_info.offset((6i32 + *param_base.offset(f as isize)) as isize))
            .b32
            .s1,
        c,
        1000i32,
    )
}
#[no_mangle]
pub unsafe extern "C" fn new_margin_kern(
    mut w: scaled_t,
    mut p: i32,
    mut side: small_number,
) -> i32 {
    let mut k: i32 = 0;
    k = get_node(3i32);
    (*mem.offset(k as isize)).b16.s1 = 40_u16;
    (*mem.offset(k as isize)).b16.s0 = side as u16;
    (*mem.offset((k + 1i32) as isize)).b32.s1 = w;
    k
}
#[no_mangle]
pub unsafe extern "C" fn hpack(mut p: i32, mut w: scaled_t, mut m: small_number) -> i32 {
    let mut current_block: u64;
    let mut r: i32 = 0;
    let mut q: i32 = 0;
    let mut h: scaled_t = 0;
    let mut d: scaled_t = 0;
    let mut x: scaled_t = 0;
    let mut s: scaled_t = 0;
    let mut g: i32 = 0;
    let mut o: glue_ord = 0;
    let mut f: internal_font_number = 0;
    let mut i: b16x4 = b16x4 {
        s0: 0,
        s1: 0,
        s2: 0,
        s3: 0,
    };
    let mut pp: i32 = 0;
    let mut ppp: i32 = -0xfffffffi32;
    let mut total_chars: i32 = 0;
    let mut k: i32 = 0;
    last_badness = 0i32;
    r = get_node(8i32);
    (*mem.offset(r as isize)).b16.s1 = 0_u16;
    (*mem.offset(r as isize)).b16.s0 = 0_u16;
    (*mem.offset((r + 4i32) as isize)).b32.s1 = 0i32;
    q = r + 5i32;
    (*mem.offset(q as isize)).b32.s1 = p;
    h = 0i32;
    d = 0i32;
    x = 0i32;
    total_stretch[0] = 0i32;
    total_shrink[0] = 0i32;
    total_stretch[1] = 0i32;
    total_shrink[1] = 0i32;
    total_stretch[2] = 0i32;
    total_shrink[2] = 0i32;
    total_stretch[3] = 0i32;
    total_shrink[3] = 0i32;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 71i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        /*1497: */
        temp_ptr = get_avail();
        (*mem.offset(temp_ptr as isize)).b32.s0 = 0i32;
        (*mem.offset(temp_ptr as isize)).b32.s1 = LR_ptr;
        LR_ptr = temp_ptr
    }
    's_130: while p != -0xfffffffi32 {
        loop
        /*674: */
        {
            while is_char_node(p) {
                /*677: */
                f = (*mem.offset(p as isize)).b16.s1 as internal_font_number;
                i = (*font_info.offset(
                    (*char_base.offset(f as isize)
                        + effective_char(1i32 != 0, f, (*mem.offset(p as isize)).b16.s0))
                        as isize,
                ))
                .b16;
                x = x
                    + (*font_info.offset((*width_base.offset(f as isize) + i.s3 as i32) as isize))
                        .b32
                        .s1;
                s = (*font_info
                    .offset((*height_base.offset(f as isize) + i.s2 as i32 / 16i32) as isize))
                .b32
                .s1;
                if s > h {
                    h = s
                }
                s = (*font_info
                    .offset((*depth_base.offset(f as isize) + i.s2 as i32 % 16i32) as isize))
                .b32
                .s1;
                if s > d {
                    d = s
                }
                p = (*mem.offset(p as isize)).b32.s1
            }
            if !(p != -0xfffffffi32) {
                continue 's_130;
            }
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 2 | 13 => {
                    x = x + (*mem.offset((p + 1i32) as isize)).b32.s1;
                    if (*mem.offset(p as isize)).b16.s1 as i32 >= 2i32 {
                        s = 0i32
                    } else {
                        s = (*mem.offset((p + 4i32) as isize)).b32.s1
                    }
                    if (*mem.offset((p + 3i32) as isize)).b32.s1 - s > h {
                        h = (*mem.offset((p + 3i32) as isize)).b32.s1 - s
                    }
                    if (*mem.offset((p + 2i32) as isize)).b32.s1 + s > d {
                        d = (*mem.offset((p + 2i32) as isize)).b32.s1 + s
                    }
                    current_block = 1176253869785344635;
                    break;
                }
                3 | 4 | 5 => {
                    if adjust_tail != -0xfffffffi32 || pre_adjust_tail != -0xfffffffi32 {
                        /*680: */
                        while (*mem.offset(q as isize)).b32.s1 != p {
                            q = (*mem.offset(q as isize)).b32.s1
                        }
                        if (*mem.offset(p as isize)).b16.s1 as i32 == 5i32 {
                            if (*mem.offset(p as isize)).b16.s0 as i32 != 0i32 {
                                if pre_adjust_tail == -0xfffffffi32 {
                                    confusion(b"pre vadjust\x00" as *const u8 as *const i8);
                                }
                                (*mem.offset(pre_adjust_tail as isize)).b32.s1 =
                                    (*mem.offset((p + 1i32) as isize)).b32.s1;
                                while (*mem.offset(pre_adjust_tail as isize)).b32.s1
                                    != -0xfffffffi32
                                {
                                    pre_adjust_tail = (*mem.offset(pre_adjust_tail as isize)).b32.s1
                                }
                            } else {
                                if adjust_tail == -0xfffffffi32 {
                                    confusion(b"pre vadjust\x00" as *const u8 as *const i8);
                                }
                                (*mem.offset(adjust_tail as isize)).b32.s1 =
                                    (*mem.offset((p + 1i32) as isize)).b32.s1;
                                while (*mem.offset(adjust_tail as isize)).b32.s1 != -0xfffffffi32 {
                                    adjust_tail = (*mem.offset(adjust_tail as isize)).b32.s1
                                }
                            }
                            p = (*mem.offset(p as isize)).b32.s1;
                            free_node((*mem.offset(q as isize)).b32.s1, 2i32);
                        } else {
                            (*mem.offset(adjust_tail as isize)).b32.s1 = p;
                            adjust_tail = p;
                            p = (*mem.offset(p as isize)).b32.s1
                        }
                        (*mem.offset(q as isize)).b32.s1 = p;
                        p = q
                    }
                    current_block = 1176253869785344635;
                    break;
                }
                8 => match (*mem.offset(p as isize)).b16.s0 as i32 {
                    40 | 41 => {
                        current_block = 10435735846551762309;
                        break;
                    }
                    42 | 43 | 44 => {
                        current_block = 9371553318591620115;
                        break;
                    }
                    _ => {
                        current_block = 1176253869785344635;
                        break;
                    }
                },
                10 => {
                    g = (*mem.offset((p + 1i32) as isize)).b32.s0;
                    x = x + (*mem.offset((g + 1i32) as isize)).b32.s1;
                    o = (*mem.offset(g as isize)).b16.s1 as glue_ord;
                    total_stretch[o as usize] =
                        total_stretch[o as usize] + (*mem.offset((g + 2i32) as isize)).b32.s1;
                    o = (*mem.offset(g as isize)).b16.s0 as glue_ord;
                    total_shrink[o as usize] =
                        total_shrink[o as usize] + (*mem.offset((g + 3i32) as isize)).b32.s1;
                    if (*mem.offset(p as isize)).b16.s0 as i32 >= 100i32 {
                        g = (*mem.offset((p + 1i32) as isize)).b32.s1;
                        if (*mem.offset((g + 3i32) as isize)).b32.s1 > h {
                            h = (*mem.offset((g + 3i32) as isize)).b32.s1
                        }
                        if (*mem.offset((g + 2i32) as isize)).b32.s1 > d {
                            d = (*mem.offset((g + 2i32) as isize)).b32.s1
                        }
                    }
                    current_block = 1176253869785344635;
                    break;
                }
                11 => {
                    x = x + (*mem.offset((p + 1i32) as isize)).b32.s1;
                    current_block = 1176253869785344635;
                    break;
                }
                40 => {
                    x = x + (*mem.offset((p + 1i32) as isize)).b32.s1;
                    current_block = 1176253869785344635;
                    break;
                }
                9 => {
                    x = x + (*mem.offset((p + 1i32) as isize)).b32.s1;
                    if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 71i32) as isize,
                    ))
                    .b32
                    .s1 > 0i32
                    {
                        /*1498: */
                        if (*mem.offset(p as isize)).b16.s0 as i32 & 1i32 != 0 {
                            if (*mem.offset(LR_ptr as isize)).b32.s0
                                == 4i32 * ((*mem.offset(p as isize)).b16.s0 as i32 / 4i32) + 3i32
                            {
                                temp_ptr = LR_ptr; /*689: */
                                LR_ptr = (*mem.offset(temp_ptr as isize)).b32.s1;
                                (*mem.offset(temp_ptr as isize)).b32.s1 = avail;
                                avail = temp_ptr
                            } else {
                                LR_problems += 1;
                                (*mem.offset(p as isize)).b16.s1 = 11_u16;
                                (*mem.offset(p as isize)).b16.s0 = 1_u16
                            }
                        } else {
                            temp_ptr = get_avail();
                            (*mem.offset(temp_ptr as isize)).b32.s0 =
                                4i32 * ((*mem.offset(p as isize)).b16.s0 as i32 / 4i32) + 3i32;
                            (*mem.offset(temp_ptr as isize)).b32.s1 = LR_ptr;
                            LR_ptr = temp_ptr
                        }
                    }
                    current_block = 1176253869785344635;
                    break;
                }
                6 => {
                    *mem.offset((4999999i32 - 12i32) as isize) = *mem.offset((p + 1i32) as isize);
                    (*mem.offset((4999999i32 - 12i32) as isize)).b32.s1 =
                        (*mem.offset(p as isize)).b32.s1;
                    p = 4999999i32 - 12i32;
                    xtx_ligature_present = true
                }
                _ => {
                    current_block = 1176253869785344635;
                    break;
                }
            }
        }
        match current_block {
            10435735846551762309 => {
                if q != r + 5i32 && (*mem.offset(q as isize)).b16.s1 as i32 == 7i32 {
                    k = (*mem.offset(q as isize)).b16.s0 as i32
                } else {
                    k = 0i32
                }
                while (*mem.offset(q as isize)).b32.s1 != p {
                    k -= 1;
                    q = (*mem.offset(q as isize)).b32.s1;
                    if (*mem.offset(q as isize)).b16.s1 as i32 == 7i32 {
                        k = (*mem.offset(q as isize)).b16.s0 as i32
                    }
                }
                pp = (*mem.offset(p as isize)).b32.s1;
                while k <= 0i32 && pp != -0xfffffffi32 && !is_char_node(pp) {
                    if (*mem.offset(pp as isize)).b16.s1 as i32 == 8i32
                        && ((*mem.offset(pp as isize)).b16.s0 as i32 == 40i32
                            || (*mem.offset(pp as isize)).b16.s0 as i32 == 41i32)
                        && (*mem.offset((pp + 4i32) as isize)).b16.s2 as i32
                            == (*mem.offset((p + 4i32) as isize)).b16.s2 as i32
                    {
                        pp = (*mem.offset(pp as isize)).b32.s1
                    } else {
                        if !((*mem.offset(pp as isize)).b16.s1 as i32 == 7i32) {
                            break;
                        }
                        ppp = (*mem.offset(pp as isize)).b32.s1;
                        if !(ppp != -0xfffffffi32
                            && !is_char_node(ppp)
                            && (*mem.offset(ppp as isize)).b16.s1 as i32 == 8i32
                            && ((*mem.offset(ppp as isize)).b16.s0 as i32 == 40i32
                                || (*mem.offset(ppp as isize)).b16.s0 as i32 == 41i32)
                            && (*mem.offset((ppp + 4i32) as isize)).b16.s2 as i32
                                == (*mem.offset((p + 4i32) as isize)).b16.s2 as i32)
                        {
                            break;
                        }
                        pp = (*mem.offset(ppp as isize)).b32.s1
                    }
                }
                if pp != (*mem.offset(p as isize)).b32.s1 {
                    total_chars = 0i32;
                    p = (*mem.offset(q as isize)).b32.s1;
                    while p != pp {
                        if (*mem.offset(p as isize)).b16.s1 as i32 == 8i32 {
                            total_chars =
                                total_chars + (*mem.offset((p + 4i32) as isize)).b16.s1 as i32
                        }
                        ppp = p;
                        p = (*mem.offset(p as isize)).b32.s1
                    }
                    p = (*mem.offset(q as isize)).b32.s1;
                    pp = new_native_word_node(
                        (*mem.offset((p + 4i32) as isize)).b16.s2 as internal_font_number,
                        total_chars,
                    );
                    (*mem.offset(pp as isize)).b16.s0 = (*mem.offset(p as isize)).b16.s0;
                    (*mem.offset(q as isize)).b32.s1 = pp;
                    (*mem.offset(pp as isize)).b32.s1 = (*mem.offset(ppp as isize)).b32.s1;
                    (*mem.offset(ppp as isize)).b32.s1 = -0xfffffffi32;
                    total_chars = 0i32;
                    ppp = p;
                    loop {
                        if (*mem.offset(ppp as isize)).b16.s1 as i32 == 8i32 {
                            let mut for_end: i32 = 0;
                            k = 0i32;
                            for_end = (*mem.offset((ppp + 4i32) as isize)).b16.s1 as i32 - 1i32;
                            if k <= for_end {
                                loop {
                                    *(&mut *mem.offset((pp + 6i32) as isize) as *mut memory_word
                                        as *mut u16)
                                        .offset(total_chars as isize) = *(&mut *mem
                                        .offset((ppp + 6i32) as isize)
                                        as *mut memory_word
                                        as *mut u16)
                                        .offset(k as isize);
                                    total_chars += 1;
                                    let fresh68 = k;
                                    k = k + 1;
                                    if !(fresh68 < for_end) {
                                        break;
                                    }
                                }
                            }
                        }
                        ppp = (*mem.offset(ppp as isize)).b32.s1;
                        if ppp == -0xfffffffi32 {
                            break;
                        }
                    }
                    flush_node_list(p);
                    p = (*mem.offset(q as isize)).b32.s1;
                    measure_native_node(
                        &mut *mem.offset(p as isize) as *mut memory_word as *mut libc::c_void,
                        ((*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 74i32) as isize,
                        ))
                        .b32
                        .s1 > 0i32) as i32,
                    );
                }
                if (*mem.offset((p + 3i32) as isize)).b32.s1 > h {
                    h = (*mem.offset((p + 3i32) as isize)).b32.s1
                }
                if (*mem.offset((p + 2i32) as isize)).b32.s1 > d {
                    d = (*mem.offset((p + 2i32) as isize)).b32.s1
                }
                x = x + (*mem.offset((p + 1i32) as isize)).b32.s1
            }
            9371553318591620115 => {
                if (*mem.offset((p + 3i32) as isize)).b32.s1 > h {
                    h = (*mem.offset((p + 3i32) as isize)).b32.s1
                }
                if (*mem.offset((p + 2i32) as isize)).b32.s1 > d {
                    d = (*mem.offset((p + 2i32) as isize)).b32.s1
                }
                x = x + (*mem.offset((p + 1i32) as isize)).b32.s1
            }
            _ => {}
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
    if adjust_tail != -0xfffffffi32 {
        (*mem.offset(adjust_tail as isize)).b32.s1 = -0xfffffffi32
    }
    if pre_adjust_tail != -0xfffffffi32 {
        (*mem.offset(pre_adjust_tail as isize)).b32.s1 = -0xfffffffi32
    }
    (*mem.offset((r + 3i32) as isize)).b32.s1 = h;
    (*mem.offset((r + 2i32) as isize)).b32.s1 = d;
    if m as i32 == 1i32 {
        w = x + w
    }
    (*mem.offset((r + 1i32) as isize)).b32.s1 = w;
    x = w - x;
    if x == 0i32 {
        (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
        (*mem.offset((r + 5i32) as isize)).b16.s0 = 0_u16;
        (*mem.offset((r + 6i32) as isize)).gr = 0.0f64;
        current_block = 2380354494544673732;
    } else if x > 0i32 {
        /*683: */
        if total_stretch[3] != 0i32 {
            o = 3i32 as glue_ord
        } else if total_stretch[2] != 0i32 {
            o = 2i32 as glue_ord
        } else if total_stretch[1] != 0i32 {
            o = 1i32 as glue_ord
        } else {
            o = 0i32 as glue_ord
        } /*normal *//*:684 */
        (*mem.offset((r + 5i32) as isize)).b16.s0 = o as u16;
        (*mem.offset((r + 5i32) as isize)).b16.s1 = 1_u16;
        if total_stretch[o as usize] != 0i32 {
            (*mem.offset((r + 6i32) as isize)).gr = x as f64 / total_stretch[o as usize] as f64
        } else {
            (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
            (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
        }
        if o as i32 == 0i32 {
            if (*mem.offset((r + 5i32) as isize)).b32.s1 != -0xfffffffi32 {
                /*685: */
                last_badness = badness(x, total_stretch[0]); /*normal *//*:690 */
                if last_badness
                    > (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 26i32) as isize,
                    ))
                    .b32
                    .s1
                {
                    print_ln();
                    if last_badness > 100i32 {
                        print_nl_cstr(b"Underfull\x00" as *const u8 as *const i8);
                    } else {
                        print_nl_cstr(b"Loose\x00" as *const u8 as *const i8);
                    }
                    print_cstr(b" \\hbox (badness \x00" as *const u8 as *const i8);
                    print_int(last_badness);
                    current_block = 13814253595362444008;
                } else {
                    current_block = 2380354494544673732;
                }
            } else {
                current_block = 2380354494544673732;
            }
        } else {
            current_block = 2380354494544673732;
        }
    } else {
        if total_shrink[3] != 0i32 {
            o = 3i32 as glue_ord
        } else if total_shrink[2] != 0i32 {
            o = 2i32 as glue_ord
        } else if total_shrink[1] != 0i32 {
            o = 1i32 as glue_ord
        } else {
            o = 0i32 as glue_ord
        }
        (*mem.offset((r + 5i32) as isize)).b16.s0 = o as u16;
        (*mem.offset((r + 5i32) as isize)).b16.s1 = 2_u16;
        if total_shrink[o as usize] != 0i32 {
            (*mem.offset((r + 6i32) as isize)).gr = -x as f64 / total_shrink[o as usize] as f64
        } else {
            (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
            (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
        }
        if total_shrink[o as usize] < -x
            && o as i32 == 0i32
            && (*mem.offset((r + 5i32) as isize)).b32.s1 != -0xfffffffi32
        {
            last_badness = 1000000i64 as i32;
            (*mem.offset((r + 6i32) as isize)).gr = 1.0f64;
            if -x - total_shrink[0]
                > (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 85i32
                        + 256i32
                        + (0x10ffffi32 + 1i32)
                        + 8i32) as isize,
                ))
                .b32
                .s1
                || (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 26i32) as isize,
                ))
                .b32
                .s1 < 100i32
            {
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 85i32
                        + 256i32
                        + (0x10ffffi32 + 1i32)
                        + 16i32) as isize,
                ))
                .b32
                .s1 > 0i32
                    && -x - total_shrink[0]
                        > (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 85i32
                                + 256i32
                                + (0x10ffffi32 + 1i32)
                                + 8i32) as isize,
                        ))
                        .b32
                        .s1
                {
                    while (*mem.offset(q as isize)).b32.s1 != -0xfffffffi32 {
                        q = (*mem.offset(q as isize)).b32.s1
                    }
                    (*mem.offset(q as isize)).b32.s1 = new_rule();
                    (*mem.offset(((*mem.offset(q as isize)).b32.s1 + 1i32) as isize))
                        .b32
                        .s1 = (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 85i32
                            + 256i32
                            + (0x10ffffi32 + 1i32)
                            + 16i32) as isize,
                    ))
                    .b32
                    .s1
                }
                print_ln();
                print_nl_cstr(b"Overfull \\hbox (\x00" as *const u8 as *const i8);
                print_scaled(-x - total_shrink[0]);
                print_cstr(b"pt too wide\x00" as *const u8 as *const i8);
                current_block = 13814253595362444008;
            } else {
                current_block = 2380354494544673732;
            }
        } else if o as i32 == 0i32 {
            if (*mem.offset((r + 5i32) as isize)).b32.s1 != -0xfffffffi32 {
                /*692: */
                last_badness = badness(-x, total_shrink[0]);
                if last_badness
                    > (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 26i32) as isize,
                    ))
                    .b32
                    .s1
                {
                    print_ln();
                    print_nl_cstr(b"Tight \\hbox (badness \x00" as *const u8 as *const i8);
                    print_int(last_badness);
                    current_block = 13814253595362444008;
                } else {
                    current_block = 2380354494544673732;
                }
            } else {
                current_block = 2380354494544673732;
            }
        } else {
            current_block = 2380354494544673732;
        }
    }
    loop {
        match current_block {
            13814253595362444008 => {
                if output_active {
                    print_cstr(
                        b") has occurred while \\output is active\x00" as *const u8 as *const i8,
                    );
                } else {
                    if pack_begin_line != 0i32 {
                        if pack_begin_line > 0i32 {
                            print_cstr(b") in paragraph at lines \x00" as *const u8 as *const i8);
                        } else {
                            print_cstr(b") in alignment at lines \x00" as *const u8 as *const i8);
                        }
                        print_int(pack_begin_line.abs());
                        print_cstr(b"--\x00" as *const u8 as *const i8);
                    } else {
                        print_cstr(b") detected at line \x00" as *const u8 as *const i8);
                    }
                    print_int(line);
                }
                print_ln();
                font_in_short_display = 0i32;
                short_display((*mem.offset((r + 5i32) as isize)).b32.s1);
                print_ln();
                begin_diagnostic();
                show_box(r);
                end_diagnostic(1i32 != 0);
                current_block = 2380354494544673732;
            }
            _ => {
                if !((*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 71i32) as isize,
                ))
                .b32
                .s1 > 0i32)
                {
                    break;
                }
                /*1499: */
                if (*mem.offset(LR_ptr as isize)).b32.s0 != 0i32 {
                    while (*mem.offset(q as isize)).b32.s1 != -0xfffffffi32 {
                        q = (*mem.offset(q as isize)).b32.s1
                    } /*:673 */
                    loop {
                        temp_ptr = q;
                        q = new_math(0i32, (*mem.offset(LR_ptr as isize)).b32.s0 as small_number);
                        (*mem.offset(temp_ptr as isize)).b32.s1 = q;
                        LR_problems = LR_problems + 10000i32;
                        temp_ptr = LR_ptr;
                        LR_ptr = (*mem.offset(temp_ptr as isize)).b32.s1;
                        (*mem.offset(temp_ptr as isize)).b32.s1 = avail;
                        avail = temp_ptr;
                        if (*mem.offset(LR_ptr as isize)).b32.s0 == 0i32 {
                            break;
                        }
                    }
                }
                if LR_problems > 0i32 {
                    print_ln();
                    print_nl_cstr(b"\\endL or \\endR problem (\x00" as *const u8 as *const i8);
                    print_int(LR_problems / 10000i32);
                    print_cstr(b" missing, \x00" as *const u8 as *const i8);
                    print_int(LR_problems % 10000i32);
                    print_cstr(b" extra\x00" as *const u8 as *const i8);
                    LR_problems = 0i32;
                    current_block = 13814253595362444008;
                } else {
                    temp_ptr = LR_ptr;
                    LR_ptr = (*mem.offset(temp_ptr as isize)).b32.s1;
                    (*mem.offset(temp_ptr as isize)).b32.s1 = avail;
                    avail = temp_ptr;
                    if LR_ptr != -0xfffffffi32 {
                        confusion(b"LR1\x00" as *const u8 as *const i8);
                    }
                    break;
                }
            }
        }
    }
    r
}
#[no_mangle]
pub unsafe extern "C" fn vpackage(
    mut p: i32,
    mut h: scaled_t,
    mut m: small_number,
    mut l: scaled_t,
) -> i32 {
    let mut current_block: u64;
    let mut r: i32 = 0;
    let mut w: scaled_t = 0;
    let mut d: scaled_t = 0;
    let mut x: scaled_t = 0;
    let mut s: scaled_t = 0;
    let mut g: i32 = 0;
    let mut o: glue_ord = 0;
    last_badness = 0i32;
    r = get_node(8i32);
    (*mem.offset(r as isize)).b16.s1 = 1_u16;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 73i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        (*mem.offset(r as isize)).b16.s0 = 1_u16
    } else {
        (*mem.offset(r as isize)).b16.s0 = 0_u16
    }
    (*mem.offset((r + 4i32) as isize)).b32.s1 = 0i32;
    (*mem.offset((r + 5i32) as isize)).b32.s1 = p;
    w = 0i32;
    d = 0i32;
    x = 0i32;
    total_stretch[0] = 0i32;
    total_shrink[0] = 0i32;
    total_stretch[1] = 0i32;
    total_shrink[1] = 0i32;
    total_stretch[2] = 0i32;
    total_shrink[2] = 0i32;
    total_stretch[3] = 0i32;
    total_shrink[3] = 0i32;
    while p != -0xfffffffi32 {
        /*694: */
        if is_char_node(p) {
            confusion(b"vpack\x00" as *const u8 as *const i8); /*701: */
        } else {
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 2 | 13 => {
                    x = x + d + (*mem.offset((p + 3i32) as isize)).b32.s1;
                    d = (*mem.offset((p + 2i32) as isize)).b32.s1;
                    if (*mem.offset(p as isize)).b16.s1 as i32 >= 2i32 {
                        s = 0i32
                    } else {
                        s = (*mem.offset((p + 4i32) as isize)).b32.s1
                    }
                    if (*mem.offset((p + 1i32) as isize)).b32.s1 + s > w {
                        w = (*mem.offset((p + 1i32) as isize)).b32.s1 + s
                    }
                }
                8 => {
                    if (*mem.offset(p as isize)).b16.s0 as i32 == 43i32
                        || (*mem.offset(p as isize)).b16.s0 as i32 == 44i32
                    {
                        x = x + d + (*mem.offset((p + 3i32) as isize)).b32.s1;
                        d = (*mem.offset((p + 2i32) as isize)).b32.s1;
                        if (*mem.offset((p + 1i32) as isize)).b32.s1 > w {
                            w = (*mem.offset((p + 1i32) as isize)).b32.s1
                        }
                    }
                }
                10 => {
                    x = x + d;
                    d = 0i32;
                    g = (*mem.offset((p + 1i32) as isize)).b32.s0;
                    x = x + (*mem.offset((g + 1i32) as isize)).b32.s1;
                    o = (*mem.offset(g as isize)).b16.s1 as glue_ord;
                    total_stretch[o as usize] =
                        total_stretch[o as usize] + (*mem.offset((g + 2i32) as isize)).b32.s1;
                    o = (*mem.offset(g as isize)).b16.s0 as glue_ord;
                    total_shrink[o as usize] =
                        total_shrink[o as usize] + (*mem.offset((g + 3i32) as isize)).b32.s1;
                    if (*mem.offset(p as isize)).b16.s0 as i32 >= 100i32 {
                        g = (*mem.offset((p + 1i32) as isize)).b32.s1;
                        if (*mem.offset((g + 1i32) as isize)).b32.s1 > w {
                            w = (*mem.offset((g + 1i32) as isize)).b32.s1
                        }
                    }
                }
                11 => {
                    x = x + d + (*mem.offset((p + 1i32) as isize)).b32.s1;
                    d = 0i32
                }
                _ => {}
            }
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
    (*mem.offset((r + 1i32) as isize)).b32.s1 = w;
    if d > l {
        x = x + d - l;
        (*mem.offset((r + 2i32) as isize)).b32.s1 = l
    } else {
        (*mem.offset((r + 2i32) as isize)).b32.s1 = d
    }
    if m as i32 == 1i32 {
        h = x + h
    }
    (*mem.offset((r + 3i32) as isize)).b32.s1 = h;
    x = h - x;
    if x == 0i32 {
        (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
        (*mem.offset((r + 5i32) as isize)).b16.s0 = 0_u16;
        (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
    } else {
        if x > 0i32 {
            /*698: */
            if total_stretch[3] != 0i32 {
                o = 3i32 as glue_ord
            } else if total_stretch[2] != 0i32 {
                o = 2i32 as glue_ord
            } else if total_stretch[1] != 0i32 {
                o = 1i32 as glue_ord
            } else {
                o = 0i32 as glue_ord
            } /*normal *//*:684 */
            (*mem.offset((r + 5i32) as isize)).b16.s0 = o as u16;
            (*mem.offset((r + 5i32) as isize)).b16.s1 = 1_u16;
            if total_stretch[o as usize] != 0i32 {
                (*mem.offset((r + 6i32) as isize)).gr = x as f64 / total_stretch[o as usize] as f64
            } else {
                (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
                (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
            }
            if o as i32 == 0i32 {
                if (*mem.offset((r + 5i32) as isize)).b32.s1 != -0xfffffffi32 {
                    /*699: */
                    last_badness = badness(x, total_stretch[0]); /*normal *//*:690 */
                    if last_badness
                        > (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 27i32) as isize,
                        ))
                        .b32
                        .s1
                    {
                        print_ln();
                        if last_badness > 100i32 {
                            print_nl_cstr(b"Underfull\x00" as *const u8 as *const i8);
                        } else {
                            print_nl_cstr(b"Loose\x00" as *const u8 as *const i8);
                        }
                        print_cstr(b" \\vbox (badness \x00" as *const u8 as *const i8);
                        print_int(last_badness);
                        current_block = 13130523023485106979;
                    } else {
                        current_block = 13281346226780081721;
                    }
                } else {
                    current_block = 13281346226780081721;
                }
            } else {
                current_block = 13281346226780081721;
            }
        } else {
            if total_shrink[3] != 0i32 {
                o = 3i32 as glue_ord
            } else if total_shrink[2] != 0i32 {
                o = 2i32 as glue_ord
            } else if total_shrink[1] != 0i32 {
                o = 1i32 as glue_ord
            } else {
                o = 0i32 as glue_ord
            }
            (*mem.offset((r + 5i32) as isize)).b16.s0 = o as u16;
            (*mem.offset((r + 5i32) as isize)).b16.s1 = 2_u16;
            if total_shrink[o as usize] != 0i32 {
                (*mem.offset((r + 6i32) as isize)).gr = -x as f64 / total_shrink[o as usize] as f64
            } else {
                (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
                (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
            }
            if total_shrink[o as usize] < -x
                && o as i32 == 0i32
                && (*mem.offset((r + 5i32) as isize)).b32.s1 != -0xfffffffi32
            {
                last_badness = 1000000i64 as i32;
                (*mem.offset((r + 6i32) as isize)).gr = 1.0f64;
                if -x - total_shrink[0]
                    > (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 85i32
                            + 256i32
                            + (0x10ffffi32 + 1i32)
                            + 9i32) as isize,
                    ))
                    .b32
                    .s1
                    || (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 27i32) as isize,
                    ))
                    .b32
                    .s1 < 100i32
                {
                    print_ln();
                    print_nl_cstr(b"Overfull \\vbox (\x00" as *const u8 as *const i8);
                    print_scaled(-x - total_shrink[0]);
                    print_cstr(b"pt too high\x00" as *const u8 as *const i8);
                    current_block = 13130523023485106979;
                } else {
                    current_block = 13281346226780081721;
                }
            } else if o as i32 == 0i32 {
                if (*mem.offset((r + 5i32) as isize)).b32.s1 != -0xfffffffi32 {
                    /*703: */
                    last_badness = badness(-x, total_shrink[0]);
                    if last_badness
                        > (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 27i32) as isize,
                        ))
                        .b32
                        .s1
                    {
                        print_ln();
                        print_nl_cstr(b"Tight \\vbox (badness \x00" as *const u8 as *const i8);
                        print_int(last_badness);
                        current_block = 13130523023485106979;
                    } else {
                        current_block = 13281346226780081721;
                    }
                } else {
                    current_block = 13281346226780081721;
                }
            } else {
                current_block = 13281346226780081721;
            }
        }
        match current_block {
            13281346226780081721 => {}
            _ => {
                if output_active {
                    print_cstr(
                        b") has occurred while \\output is active\x00" as *const u8 as *const i8,
                    );
                } else {
                    if pack_begin_line != 0i32 {
                        print_cstr(b") in alignment at lines \x00" as *const u8 as *const i8);
                        print_int(pack_begin_line.abs());
                        print_cstr(b"--\x00" as *const u8 as *const i8);
                    } else {
                        print_cstr(b") detected at line \x00" as *const u8 as *const i8);
                    }
                    print_int(line);
                    print_ln();
                }
                begin_diagnostic();
                show_box(r);
                end_diagnostic(1i32 != 0);
            }
        }
    }
    r
}
#[no_mangle]
pub unsafe extern "C" fn append_to_vlist(mut b: i32) {
    let mut d: scaled_t = 0;
    let mut p: i32 = 0;
    let mut upwards: bool = false;
    upwards = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 73i32) as isize,
    ))
    .b32
    .s1 > 0i32;
    if cur_list.aux.b32.s1 > -65536000i32 {
        if upwards {
            d = (*mem.offset(
                ((*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 1i32) as isize,
                ))
                .b32
                .s1 + 1i32) as isize,
            ))
            .b32
            .s1 - cur_list.aux.b32.s1
                - (*mem.offset((b + 2i32) as isize)).b32.s1
        } else {
            d = (*mem.offset(
                ((*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 1i32) as isize,
                ))
                .b32
                .s1 + 1i32) as isize,
            ))
            .b32
            .s1 - cur_list.aux.b32.s1
                - (*mem.offset((b + 3i32) as isize)).b32.s1
        }
        if d < (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 2i32) as isize,
        ))
        .b32
        .s1
        {
            p = new_param_glue(0i32 as small_number)
        } else {
            p = new_skip_param(1i32 as small_number);
            (*mem.offset((temp_ptr + 1i32) as isize)).b32.s1 = d
        }
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        cur_list.tail = p
    }
    (*mem.offset(cur_list.tail as isize)).b32.s1 = b;
    cur_list.tail = b;
    if upwards {
        cur_list.aux.b32.s1 = (*mem.offset((b + 3i32) as isize)).b32.s1
    } else {
        cur_list.aux.b32.s1 = (*mem.offset((b + 2i32) as isize)).b32.s1
    };
}
#[no_mangle]
pub unsafe extern "C" fn new_noad() -> i32 {
    let mut p: i32 = 0;
    p = get_node(4i32);
    (*mem.offset(p as isize)).b16.s1 = 16_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32 = empty;
    (*mem.offset((p + 3i32) as isize)).b32 = empty;
    (*mem.offset((p + 2i32) as isize)).b32 = empty;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_style(mut s: small_number) -> i32 {
    let mut p: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 14_u16;
    (*mem.offset(p as isize)).b16.s0 = s as u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = 0i32;
    (*mem.offset((p + 2i32) as isize)).b32.s1 = 0i32;
    p
}
#[no_mangle]
pub unsafe extern "C" fn new_choice() -> i32 {
    let mut p: i32 = 0;
    p = get_node(3i32);
    (*mem.offset(p as isize)).b16.s1 = 15_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s0 = -0xfffffffi32;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = -0xfffffffi32;
    (*mem.offset((p + 2i32) as isize)).b32.s0 = -0xfffffffi32;
    (*mem.offset((p + 2i32) as isize)).b32.s1 = -0xfffffffi32;
    p
}
#[no_mangle]
pub unsafe extern "C" fn show_info() {
    show_node_list((*mem.offset(temp_ptr as isize)).b32.s0);
}
#[no_mangle]
pub unsafe extern "C" fn push_alignment() {
    let mut p: i32 = 0;
    p = get_node(6i32);
    (*mem.offset(p as isize)).b32.s1 = align_ptr;
    (*mem.offset(p as isize)).b32.s0 = cur_align;
    (*mem.offset((p + 1i32) as isize)).b32.s0 = (*mem.offset((4999999i32 - 8i32) as isize)).b32.s1;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = cur_span;
    (*mem.offset((p + 2i32) as isize)).b32.s1 = cur_loop;
    (*mem.offset((p + 3i32) as isize)).b32.s1 = align_state;
    (*mem.offset((p + 4i32) as isize)).b32.s0 = cur_head;
    (*mem.offset((p + 4i32) as isize)).b32.s1 = cur_tail;
    (*mem.offset((p + 5i32) as isize)).b32.s0 = cur_pre_head;
    (*mem.offset((p + 5i32) as isize)).b32.s1 = cur_pre_tail;
    align_ptr = p;
    cur_head = get_avail();
    cur_pre_head = get_avail();
}
#[no_mangle]
pub unsafe extern "C" fn pop_alignment() {
    let mut p: i32 = 0;
    (*mem.offset(cur_head as isize)).b32.s1 = avail;
    avail = cur_head;
    (*mem.offset(cur_pre_head as isize)).b32.s1 = avail;
    avail = cur_pre_head;
    p = align_ptr;
    cur_tail = (*mem.offset((p + 4i32) as isize)).b32.s1;
    cur_head = (*mem.offset((p + 4i32) as isize)).b32.s0;
    cur_pre_tail = (*mem.offset((p + 5i32) as isize)).b32.s1;
    cur_pre_head = (*mem.offset((p + 5i32) as isize)).b32.s0;
    align_state = (*mem.offset((p + 3i32) as isize)).b32.s1;
    cur_loop = (*mem.offset((p + 2i32) as isize)).b32.s1;
    cur_span = (*mem.offset((p + 1i32) as isize)).b32.s1;
    (*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 = (*mem.offset((p + 1i32) as isize)).b32.s0;
    cur_align = (*mem.offset(p as isize)).b32.s0;
    align_ptr = (*mem.offset(p as isize)).b32.s1;
    free_node(p, 6i32);
}
#[no_mangle]
pub unsafe extern "C" fn get_preamble_token() {
    loop {
        get_token();
        while cur_chr == 0x10ffffi32 + 2i32 && cur_cmd as i32 == 4i32 {
            get_token();
            if cur_cmd as i32 > 102i32 {
                expand();
                get_token();
            }
        }
        if cur_cmd as i32 == 9i32 {
            fatal_error(
                b"(interwoven alignment preambles are not allowed)\x00" as *const u8 as *const i8,
            );
        }
        if !(cur_cmd as i32 == 76i32
            && cur_chr
                == 1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 11i32)
        {
            break;
        }
        scan_optional_equals();
        scan_glue(2i32 as small_number);
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 43i32) as isize,
        ))
        .b32
        .s1 > 0i32
        {
            geq_define(
                1i32 + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 11i32,
                119_u16,
                cur_val,
            );
        } else {
            eq_define(
                1i32 + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 11i32,
                119_u16,
                cur_val,
            );
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn init_align() {
    let mut save_cs_ptr: i32 = 0;
    let mut p: i32 = 0;
    save_cs_ptr = cur_cs;
    push_alignment();
    align_state = -1000000i64 as i32;
    if cur_list.mode as i32 == 207i32
        && (cur_list.tail != cur_list.head || cur_list.aux.b32.s1 != -0xfffffffi32)
    {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Improper \x00" as *const u8 as *const i8);
        print_esc_cstr(b"halign\x00" as *const u8 as *const i8);
        print_cstr(b" inside $$\'s\x00" as *const u8 as *const i8);
        help_ptr = 3_u8;
        help_line[2] =
            b"Displays can use special alignments (like \\eqalignno)\x00" as *const u8 as *const i8;
        help_line[1] = b"only if nothing but the alignment itself is between $$\'s.\x00"
            as *const u8 as *const i8;
        help_line[0] = b"So I\'ve deleted the formulas that preceded this alignment.\x00"
            as *const u8 as *const i8;
        error();
        flush_math();
    }
    push_nest();
    if cur_list.mode as i32 == 207i32 {
        cur_list.mode = -1_i16;
        cur_list.aux.b32.s1 = (*nest.offset((nest_ptr - 2i32) as isize)).aux.b32.s1
    } else if cur_list.mode as i32 > 0i32 {
        cur_list.mode = -(cur_list.mode as i32) as i16
        /*:804*/
    }
    scan_spec(6i32 as group_code, false);
    (*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 = -0xfffffffi32;
    cur_align = 4999999i32 - 8i32;
    cur_loop = -0xfffffffi32;
    scanner_status = 4_u8;
    warning_index = save_cs_ptr;
    align_state = -1000000i64 as i32;
    loop {
        (*mem.offset(cur_align as isize)).b32.s1 = new_param_glue(11i32 as small_number);
        /*:808 */
        cur_align = (*mem.offset(cur_align as isize)).b32.s1; /*:807*/
        if cur_cmd as i32 == 5i32 {
            break; /*:813*/
        } /*:806 */
        p = 4999999i32 - 4i32;
        (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
        loop {
            get_preamble_token();
            if cur_cmd as i32 == 6i32 {
                break;
            }
            if cur_cmd as i32 <= 5i32 && cur_cmd as i32 >= 4i32 && align_state as i64 == -1000000 {
                if p == 4999999i32 - 4i32 && cur_loop == -0xfffffffi32 && cur_cmd as i32 == 4i32 {
                    cur_loop = cur_align
                } else {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(
                        b"Missing # inserted in alignment preamble\x00" as *const u8 as *const i8,
                    );
                    help_ptr = 3_u8;
                    help_line[2] = b"There should be exactly one # between &\'s, when an\x00"
                        as *const u8 as *const i8;
                    help_line[1] = b"\\halign or \\valign is being set up. In this case you had\x00"
                        as *const u8 as *const i8;
                    help_line[0] = b"none, so I\'ve put one in; maybe that will work.\x00"
                        as *const u8 as *const i8;
                    back_error();
                    break;
                }
            } else if cur_cmd as i32 != 10i32 || p != 4999999i32 - 4i32 {
                (*mem.offset(p as isize)).b32.s1 = get_avail();
                p = (*mem.offset(p as isize)).b32.s1;
                (*mem.offset(p as isize)).b32.s0 = cur_tok
            }
        }
        (*mem.offset(cur_align as isize)).b32.s1 = new_null_box();
        cur_align = (*mem.offset(cur_align as isize)).b32.s1;
        (*mem.offset(cur_align as isize)).b32.s0 = 4999999i32 - 9i32;
        (*mem.offset((cur_align + 1i32) as isize)).b32.s1 = -0x40000000i32;
        (*mem.offset((cur_align + 3i32) as isize)).b32.s1 =
            (*mem.offset((4999999i32 - 4i32) as isize)).b32.s1;
        p = 4999999i32 - 4i32;
        (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
        loop {
            get_preamble_token();
            if cur_cmd as i32 <= 5i32 && cur_cmd as i32 >= 4i32 && align_state as i64 == -1000000 {
                break;
            }
            if cur_cmd as i32 == 6i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Only one # is allowed per tab\x00" as *const u8 as *const i8);
                help_ptr = 3_u8;
                help_line[2] = b"There should be exactly one # between &\'s, when an\x00"
                    as *const u8 as *const i8;
                help_line[1] = b"\\halign or \\valign is being set up. In this case you had\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"more than one, so I\'m ignoring all but the first.\x00"
                    as *const u8 as *const i8;
                error();
            } else {
                (*mem.offset(p as isize)).b32.s1 = get_avail();
                p = (*mem.offset(p as isize)).b32.s1;
                (*mem.offset(p as isize)).b32.s0 = cur_tok
            }
        }
        (*mem.offset(p as isize)).b32.s1 = get_avail();
        p = (*mem.offset(p as isize)).b32.s1;
        (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
            + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 5i32);
        (*mem.offset((cur_align + 2i32) as isize)).b32.s1 =
            (*mem.offset((4999999i32 - 4i32) as isize)).b32.s1
    }
    scanner_status = 0_u8;
    new_save_level(6i32 as group_code);
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 8i32) as isize,
    ))
    .b32
    .s1 != -0xfffffffi32
    {
        begin_token_list(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 8i32) as isize,
            ))
            .b32
            .s1,
            14_u16,
        );
    }
    align_peek();
}
#[no_mangle]
pub unsafe extern "C" fn init_span(mut p: i32) {
    push_nest();
    if cur_list.mode as i32 == -104i32 {
        cur_list.aux.b32.s0 = 1000i32
    } else {
        cur_list.aux.b32.s1 = -65536000i32;
        normal_paragraph();
    }
    cur_span = p;
}
#[no_mangle]
pub unsafe extern "C" fn init_row() {
    push_nest();
    cur_list.mode = (-105i32 - cur_list.mode as i32) as i16;
    if cur_list.mode as i32 == -104i32 {
        cur_list.aux.b32.s0 = 0i32
    } else {
        cur_list.aux.b32.s1 = 0i32
    }
    (*mem.offset(cur_list.tail as isize)).b32.s1 = new_glue(
        (*mem.offset(((*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 + 1i32) as isize))
            .b32
            .s0,
    );
    cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
    (*mem.offset(cur_list.tail as isize)).b16.s0 = (11i32 + 1i32) as u16;
    cur_align = (*mem.offset((*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 as isize))
        .b32
        .s1;
    cur_tail = cur_head;
    cur_pre_tail = cur_pre_head;
    init_span(cur_align);
}
#[no_mangle]
pub unsafe extern "C" fn init_col() {
    (*mem.offset((cur_align + 5i32) as isize)).b32.s0 = cur_cmd as i32;
    if cur_cmd as i32 == 63i32 {
        align_state = 0i32
    } else {
        back_input();
        begin_token_list((*mem.offset((cur_align + 3i32) as isize)).b32.s1, 1_u16);
    };
}
#[no_mangle]
pub unsafe extern "C" fn fin_col() -> bool {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut s: i32 = 0;
    let mut u: i32 = 0;
    let mut w: scaled_t = 0;
    let mut o: glue_ord = 0;
    let mut n: i32 = 0;
    if cur_align == -0xfffffffi32 {
        confusion(b"endv\x00" as *const u8 as *const i8);
    }
    q = (*mem.offset(cur_align as isize)).b32.s1;
    if q == -0xfffffffi32 {
        confusion(b"endv\x00" as *const u8 as *const i8);
    }
    if (align_state as i64) < 500000 {
        fatal_error(
            b"(interwoven alignment preambles are not allowed)\x00" as *const u8 as *const i8,
        );
    }
    p = (*mem.offset(q as isize)).b32.s1;
    if p == -0xfffffffi32 && (*mem.offset((cur_align + 5i32) as isize)).b32.s0 < 0x10ffffi32 + 3i32
    {
        if cur_loop != -0xfffffffi32 {
            /*822: */
            (*mem.offset(q as isize)).b32.s1 = new_null_box(); /*:823 */
            p = (*mem.offset(q as isize)).b32.s1;
            (*mem.offset(p as isize)).b32.s0 = 4999999i32 - 9i32;
            (*mem.offset((p + 1i32) as isize)).b32.s1 = -0x40000000i32;
            cur_loop = (*mem.offset(cur_loop as isize)).b32.s1;
            q = 4999999i32 - 4i32;
            r = (*mem.offset((cur_loop + 3i32) as isize)).b32.s1;
            while r != -0xfffffffi32 {
                (*mem.offset(q as isize)).b32.s1 = get_avail();
                q = (*mem.offset(q as isize)).b32.s1;
                (*mem.offset(q as isize)).b32.s0 = (*mem.offset(r as isize)).b32.s0;
                r = (*mem.offset(r as isize)).b32.s1
            }
            (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
            (*mem.offset((p + 3i32) as isize)).b32.s1 =
                (*mem.offset((4999999i32 - 4i32) as isize)).b32.s1;
            q = 4999999i32 - 4i32;
            r = (*mem.offset((cur_loop + 2i32) as isize)).b32.s1;
            while r != -0xfffffffi32 {
                (*mem.offset(q as isize)).b32.s1 = get_avail();
                q = (*mem.offset(q as isize)).b32.s1;
                (*mem.offset(q as isize)).b32.s0 = (*mem.offset(r as isize)).b32.s0;
                r = (*mem.offset(r as isize)).b32.s1
            }
            (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
            (*mem.offset((p + 2i32) as isize)).b32.s1 =
                (*mem.offset((4999999i32 - 4i32) as isize)).b32.s1;
            cur_loop = (*mem.offset(cur_loop as isize)).b32.s1;
            (*mem.offset(p as isize)).b32.s1 =
                new_glue((*mem.offset((cur_loop + 1i32) as isize)).b32.s0)
        } else {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Extra alignment tab has been changed to \x00" as *const u8 as *const i8);
            print_esc_cstr(b"cr\x00" as *const u8 as *const i8);
            help_ptr = 3_u8;
            help_line[2] = b"You have given more \\span or & marks than there were\x00" as *const u8
                as *const i8;
            help_line[1] = b"in the preamble to the \\halign or \\valign now in progress.\x00"
                as *const u8 as *const i8;
            help_line[0] = b"So I\'ll assume that you meant to type \\cr instead.\x00" as *const u8
                as *const i8;
            (*mem.offset((cur_align + 5i32) as isize)).b32.s0 = 0x10ffffi32 + 3i32;
            error();
        }
    }
    if (*mem.offset((cur_align + 5i32) as isize)).b32.s0 != 0x10ffffi32 + 2i32 {
        unsave();
        new_save_level(6i32 as group_code);
        if cur_list.mode as i32 == -104i32 {
            adjust_tail = cur_tail;
            pre_adjust_tail = cur_pre_tail;
            u = hpack(
                (*mem.offset(cur_list.head as isize)).b32.s1,
                0i32,
                1i32 as small_number,
            );
            w = (*mem.offset((u + 1i32) as isize)).b32.s1;
            cur_tail = adjust_tail;
            adjust_tail = -0xfffffffi32;
            cur_pre_tail = pre_adjust_tail;
            pre_adjust_tail = -0xfffffffi32
        } else {
            u = vpackage(
                (*mem.offset(cur_list.head as isize)).b32.s1,
                0i32,
                1i32 as small_number,
                0i32,
            );
            w = (*mem.offset((u + 3i32) as isize)).b32.s1
        }
        n = 0i32;
        if cur_span != cur_align {
            /*827: */
            q = cur_span; /*normal *//*:684 */
            loop {
                n += 1; /*normal *//*:690 */
                q = (*mem.offset((*mem.offset(q as isize)).b32.s1 as isize))
                    .b32
                    .s1; /*tab_skip_code 1 *//*:824 */
                if q == cur_align {
                    break;
                }
            }
            if n > 65535i32 {
                confusion(b"too many spans\x00" as *const u8 as *const i8);
            }
            q = cur_span;
            while (*mem.offset((*mem.offset(q as isize)).b32.s0 as isize))
                .b32
                .s1
                < n
            {
                q = (*mem.offset(q as isize)).b32.s0
            }
            if (*mem.offset((*mem.offset(q as isize)).b32.s0 as isize))
                .b32
                .s1
                > n
            {
                s = get_node(2i32);
                (*mem.offset(s as isize)).b32.s0 = (*mem.offset(q as isize)).b32.s0;
                (*mem.offset(s as isize)).b32.s1 = n;
                (*mem.offset(q as isize)).b32.s0 = s;
                (*mem.offset((s + 1i32) as isize)).b32.s1 = w
            } else if (*mem.offset(((*mem.offset(q as isize)).b32.s0 + 1i32) as isize))
                .b32
                .s1
                < w
            {
                (*mem.offset(((*mem.offset(q as isize)).b32.s0 + 1i32) as isize))
                    .b32
                    .s1 = w
            }
        } else if w > (*mem.offset((cur_align + 1i32) as isize)).b32.s1 {
            (*mem.offset((cur_align + 1i32) as isize)).b32.s1 = w
        }
        (*mem.offset(u as isize)).b16.s1 = 13_u16;
        (*mem.offset(u as isize)).b16.s0 = n as u16;
        if total_stretch[3] != 0i32 {
            o = 3i32 as glue_ord
        } else if total_stretch[2] != 0i32 {
            o = 2i32 as glue_ord
        } else if total_stretch[1] != 0i32 {
            o = 1i32 as glue_ord
        } else {
            o = 0i32 as glue_ord
        }
        (*mem.offset((u + 5i32) as isize)).b16.s0 = o as u16;
        (*mem.offset((u + 6i32) as isize)).b32.s1 = total_stretch[o as usize];
        if total_shrink[3] != 0i32 {
            o = 3i32 as glue_ord
        } else if total_shrink[2] != 0i32 {
            o = 2i32 as glue_ord
        } else if total_shrink[1] != 0i32 {
            o = 1i32 as glue_ord
        } else {
            o = 0i32 as glue_ord
        }
        (*mem.offset((u + 5i32) as isize)).b16.s1 = o as u16;
        (*mem.offset((u + 4i32) as isize)).b32.s1 = total_shrink[o as usize];
        pop_nest();
        (*mem.offset(cur_list.tail as isize)).b32.s1 = u;
        cur_list.tail = u;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_glue(
            (*mem.offset(((*mem.offset(cur_align as isize)).b32.s1 + 1i32) as isize))
                .b32
                .s0,
        );
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset(cur_list.tail as isize)).b16.s0 = 12_u16;
        if (*mem.offset((cur_align + 5i32) as isize)).b32.s0 >= 0x10ffffi32 + 3i32 {
            return true;
        }
        init_span(p);
    }
    align_state = 1000000i64 as i32;
    loop {
        get_x_or_protected();
        if cur_cmd as i32 != 10i32 {
            break;
        }
    }
    cur_align = p;
    init_col();
    false
}
#[no_mangle]
pub unsafe extern "C" fn fin_row() {
    let mut p: i32 = 0;
    if cur_list.mode as i32 == -104i32 {
        p = hpack(
            (*mem.offset(cur_list.head as isize)).b32.s1,
            0i32,
            1i32 as small_number,
        );
        pop_nest();
        if cur_pre_head != cur_pre_tail {
            (*mem.offset(cur_list.tail as isize)).b32.s1 =
                (*mem.offset(cur_pre_head as isize)).b32.s1;
            cur_list.tail = cur_pre_tail
        }
        append_to_vlist(p);
        if cur_head != cur_tail {
            (*mem.offset(cur_list.tail as isize)).b32.s1 = (*mem.offset(cur_head as isize)).b32.s1;
            cur_list.tail = cur_tail
        }
    } else {
        p = vpackage(
            (*mem.offset(cur_list.head as isize)).b32.s1,
            0i32,
            1i32 as small_number,
            0x3fffffffi32,
        );
        pop_nest();
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        cur_list.tail = p;
        cur_list.aux.b32.s0 = 1000i32
    }
    (*mem.offset(p as isize)).b16.s1 = 13_u16;
    (*mem.offset((p + 6i32) as isize)).b32.s1 = 0i32;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 8i32) as isize,
    ))
    .b32
    .s1 != -0xfffffffi32
    {
        begin_token_list(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 8i32) as isize,
            ))
            .b32
            .s1,
            14_u16,
        );
    }
    align_peek();
}
#[no_mangle]
pub unsafe extern "C" fn fin_align() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut s: i32 = 0;
    let mut u: i32 = 0;
    let mut v: i32 = 0;
    let mut t: scaled_t = 0;
    let mut w: scaled_t = 0;
    let mut o: scaled_t = 0;
    let mut n: i32 = 0;
    let mut rule_save: scaled_t = 0;
    let mut aux_save: memory_word = memory_word {
        b32: b32x2 { s0: 0, s1: 0 },
    };
    if cur_group as i32 != 6i32 {
        confusion(b"align1\x00" as *const u8 as *const i8);
    }
    unsave();
    if cur_group as i32 != 6i32 {
        confusion(b"align0\x00" as *const u8 as *const i8);
    }
    unsave();
    if (*nest.offset((nest_ptr - 1i32) as isize)).mode as i32 == 207i32 {
        o = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 15i32) as isize,
        ))
        .b32
        .s1
    } else {
        o = 0i32
    }
    q = (*mem.offset((*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 as isize))
        .b32
        .s1;
    loop {
        flush_list((*mem.offset((q + 3i32) as isize)).b32.s1);
        flush_list((*mem.offset((q + 2i32) as isize)).b32.s1);
        p = (*mem.offset((*mem.offset(q as isize)).b32.s1 as isize))
            .b32
            .s1;
        if (*mem.offset((q + 1i32) as isize)).b32.s1 == -0x40000000i32 {
            /*831: */
            (*mem.offset((q + 1i32) as isize)).b32.s1 = 0i32;
            r = (*mem.offset(q as isize)).b32.s1;
            s = (*mem.offset((r + 1i32) as isize)).b32.s0;
            if s != 0i32 {
                let ref mut fresh69 = (*mem.offset(0)).b32.s1;
                *fresh69 += 1;
                delete_glue_ref(s);
                (*mem.offset((r + 1i32) as isize)).b32.s0 = 0i32
            }
        }
        if (*mem.offset(q as isize)).b32.s0 != 4999999i32 - 9i32 {
            /*832: */
            t = (*mem.offset((q + 1i32) as isize)).b32.s1
                + (*mem.offset(
                    ((*mem.offset(((*mem.offset(q as isize)).b32.s1 + 1i32) as isize))
                        .b32
                        .s0
                        + 1i32) as isize,
                ))
                .b32
                .s1; /*:833 */
            r = (*mem.offset(q as isize)).b32.s0;
            s = 4999999i32 - 9i32;
            (*mem.offset(s as isize)).b32.s0 = p;
            n = 1i32;
            loop {
                (*mem.offset((r + 1i32) as isize)).b32.s1 =
                    (*mem.offset((r + 1i32) as isize)).b32.s1 - t;
                u = (*mem.offset(r as isize)).b32.s0;
                while (*mem.offset(r as isize)).b32.s1 > n {
                    s = (*mem.offset(s as isize)).b32.s0;
                    n = (*mem.offset((*mem.offset(s as isize)).b32.s0 as isize))
                        .b32
                        .s1
                        + 1i32
                }
                if (*mem.offset(r as isize)).b32.s1 < n {
                    (*mem.offset(r as isize)).b32.s0 = (*mem.offset(s as isize)).b32.s0;
                    (*mem.offset(s as isize)).b32.s0 = r;
                    let ref mut fresh70 = (*mem.offset(r as isize)).b32.s1;
                    *fresh70 -= 1;
                    s = r
                } else {
                    if (*mem.offset((r + 1i32) as isize)).b32.s1
                        > (*mem.offset(((*mem.offset(s as isize)).b32.s0 + 1i32) as isize))
                            .b32
                            .s1
                    {
                        (*mem.offset(((*mem.offset(s as isize)).b32.s0 + 1i32) as isize))
                            .b32
                            .s1 = (*mem.offset((r + 1i32) as isize)).b32.s1
                    }
                    free_node(r, 2i32);
                }
                r = u;
                if r == 4999999i32 - 9i32 {
                    break;
                }
            }
        }
        (*mem.offset(q as isize)).b16.s1 = 13_u16;
        (*mem.offset(q as isize)).b16.s0 = 0_u16;
        (*mem.offset((q + 3i32) as isize)).b32.s1 = 0i32;
        (*mem.offset((q + 2i32) as isize)).b32.s1 = 0i32;
        (*mem.offset((q + 5i32) as isize)).b16.s0 = 0_u16;
        (*mem.offset((q + 5i32) as isize)).b16.s1 = 0_u16;
        (*mem.offset((q + 6i32) as isize)).b32.s1 = 0i32;
        (*mem.offset((q + 4i32) as isize)).b32.s1 = 0i32;
        q = p;
        if q == -0xfffffffi32 {
            break;
        }
    }
    save_ptr = save_ptr - 2i32;
    pack_begin_line = -cur_list.mode_line;
    if cur_list.mode as i32 == -1i32 {
        rule_save = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 16i32) as isize,
        ))
        .b32
        .s1;
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 16i32) as isize,
        ))
        .b32
        .s1 = 0i32;
        p = hpack(
            (*mem.offset((4999999i32 - 8i32) as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 as small_number,
        );
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 16i32) as isize,
        ))
        .b32
        .s1 = rule_save
    } else {
        q = (*mem.offset((*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 as isize))
            .b32
            .s1;
        loop {
            (*mem.offset((q + 3i32) as isize)).b32.s1 = (*mem.offset((q + 1i32) as isize)).b32.s1;
            (*mem.offset((q + 1i32) as isize)).b32.s1 = 0i32;
            q = (*mem.offset((*mem.offset(q as isize)).b32.s1 as isize))
                .b32
                .s1;
            if q == -0xfffffffi32 {
                break;
            }
        }
        p = vpackage(
            (*mem.offset((4999999i32 - 8i32) as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 as small_number,
            0x3fffffffi32,
        );
        q = (*mem.offset((*mem.offset((4999999i32 - 8i32) as isize)).b32.s1 as isize))
            .b32
            .s1;
        loop {
            (*mem.offset((q + 1i32) as isize)).b32.s1 = (*mem.offset((q + 3i32) as isize)).b32.s1;
            (*mem.offset((q + 3i32) as isize)).b32.s1 = 0i32;
            q = (*mem.offset((*mem.offset(q as isize)).b32.s1 as isize))
                .b32
                .s1;
            if q == -0xfffffffi32 {
                break;
            }
        }
    }
    pack_begin_line = 0i32;
    q = (*mem.offset(cur_list.head as isize)).b32.s1;
    s = cur_list.head;
    while q != -0xfffffffi32 {
        if !is_char_node(q) {
            if (*mem.offset(q as isize)).b16.s1 as i32 == 13i32 {
                /*836: */
                if cur_list.mode as i32 == -1i32 {
                    (*mem.offset(q as isize)).b16.s1 = 0_u16;
                    (*mem.offset((q + 1i32) as isize)).b32.s1 =
                        (*mem.offset((p + 1i32) as isize)).b32.s1;
                    if (*nest.offset((nest_ptr - 1i32) as isize)).mode as i32 == 207i32 {
                        (*mem.offset(q as isize)).b16.s0 = 2_u16
                    }
                } else {
                    (*mem.offset(q as isize)).b16.s1 = 1_u16;
                    (*mem.offset((q + 3i32) as isize)).b32.s1 =
                        (*mem.offset((p + 3i32) as isize)).b32.s1
                }
                (*mem.offset((q + 5i32) as isize)).b16.s0 =
                    (*mem.offset((p + 5i32) as isize)).b16.s0;
                (*mem.offset((q + 5i32) as isize)).b16.s1 =
                    (*mem.offset((p + 5i32) as isize)).b16.s1;
                (*mem.offset((q + 6i32) as isize)).gr = (*mem.offset((p + 6i32) as isize)).gr;
                (*mem.offset((q + 4i32) as isize)).b32.s1 = o;
                r = (*mem.offset((*mem.offset((q + 5i32) as isize)).b32.s1 as isize))
                    .b32
                    .s1;
                s = (*mem.offset((*mem.offset((p + 5i32) as isize)).b32.s1 as isize))
                    .b32
                    .s1;
                loop {
                    /*837: */
                    n = (*mem.offset(r as isize)).b16.s0 as i32; /*840: */
                    t = (*mem.offset((s + 1i32) as isize)).b32.s1;
                    w = t;
                    u = 4999999i32 - 4i32;
                    (*mem.offset(r as isize)).b16.s0 = 0_u16;
                    while n > 0i32 {
                        n -= 1;
                        s = (*mem.offset(s as isize)).b32.s1;
                        v = (*mem.offset((s + 1i32) as isize)).b32.s0;
                        (*mem.offset(u as isize)).b32.s1 = new_glue(v);
                        u = (*mem.offset(u as isize)).b32.s1;
                        (*mem.offset(u as isize)).b16.s0 = (11i32 + 1i32) as u16;
                        t = t + (*mem.offset((v + 1i32) as isize)).b32.s1;
                        if (*mem.offset((p + 5i32) as isize)).b16.s1 as i32 == 1i32 {
                            if (*mem.offset(v as isize)).b16.s1 as i32
                                == (*mem.offset((p + 5i32) as isize)).b16.s0 as i32
                            {
                                t = t + tex_round(
                                    (*mem.offset((p + 6i32) as isize)).gr
                                        * (*mem.offset((v + 2i32) as isize)).b32.s1 as f64,
                                )
                            }
                        } else if (*mem.offset((p + 5i32) as isize)).b16.s1 as i32 == 2i32 {
                            if (*mem.offset(v as isize)).b16.s0 as i32
                                == (*mem.offset((p + 5i32) as isize)).b16.s0 as i32
                            {
                                t = t - tex_round(
                                    (*mem.offset((p + 6i32) as isize)).gr
                                        * (*mem.offset((v + 3i32) as isize)).b32.s1 as f64,
                                )
                            }
                        }
                        s = (*mem.offset(s as isize)).b32.s1;
                        (*mem.offset(u as isize)).b32.s1 = new_null_box();
                        u = (*mem.offset(u as isize)).b32.s1;
                        t = t + (*mem.offset((s + 1i32) as isize)).b32.s1;
                        if cur_list.mode as i32 == -1i32 {
                            (*mem.offset((u + 1i32) as isize)).b32.s1 =
                                (*mem.offset((s + 1i32) as isize)).b32.s1
                        } else {
                            (*mem.offset(u as isize)).b16.s1 = 1_u16;
                            (*mem.offset((u + 3i32) as isize)).b32.s1 =
                                (*mem.offset((s + 1i32) as isize)).b32.s1
                        }
                    }
                    if cur_list.mode as i32 == -1i32 {
                        /*839: */
                        (*mem.offset((r + 3i32) as isize)).b32.s1 =
                            (*mem.offset((q + 3i32) as isize)).b32.s1;
                        (*mem.offset((r + 2i32) as isize)).b32.s1 =
                            (*mem.offset((q + 2i32) as isize)).b32.s1;
                        if t == (*mem.offset((r + 1i32) as isize)).b32.s1 {
                            (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
                            (*mem.offset((r + 5i32) as isize)).b16.s0 = 0_u16;
                            (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
                        } else if t > (*mem.offset((r + 1i32) as isize)).b32.s1 {
                            (*mem.offset((r + 5i32) as isize)).b16.s1 = 1_u16;
                            if (*mem.offset((r + 6i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
                            } else {
                                (*mem.offset((r + 6i32) as isize)).gr =
                                    (t - (*mem.offset((r + 1i32) as isize)).b32.s1) as f64
                                        / (*mem.offset((r + 6i32) as isize)).b32.s1 as f64
                            }
                        } else {
                            (*mem.offset((r + 5i32) as isize)).b16.s0 =
                                (*mem.offset((r + 5i32) as isize)).b16.s1;
                            (*mem.offset((r + 5i32) as isize)).b16.s1 = 2_u16;
                            if (*mem.offset((r + 4i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
                            } else if (*mem.offset((r + 5i32) as isize)).b16.s0 as i32 == 0i32
                                && (*mem.offset((r + 1i32) as isize)).b32.s1 - t
                                    > (*mem.offset((r + 4i32) as isize)).b32.s1
                            {
                                (*mem.offset((r + 6i32) as isize)).gr = 1.0f64
                            } else {
                                (*mem.offset((r + 6i32) as isize)).gr =
                                    ((*mem.offset((r + 1i32) as isize)).b32.s1 - t) as f64
                                        / (*mem.offset((r + 4i32) as isize)).b32.s1 as f64
                            }
                        }
                        (*mem.offset((r + 1i32) as isize)).b32.s1 = w;
                        (*mem.offset(r as isize)).b16.s1 = 0_u16
                    } else {
                        (*mem.offset((r + 1i32) as isize)).b32.s1 =
                            (*mem.offset((q + 1i32) as isize)).b32.s1;
                        if t == (*mem.offset((r + 3i32) as isize)).b32.s1 {
                            (*mem.offset((r + 5i32) as isize)).b16.s1 = 0_u16;
                            (*mem.offset((r + 5i32) as isize)).b16.s0 = 0_u16;
                            (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
                        } else if t > (*mem.offset((r + 3i32) as isize)).b32.s1 {
                            (*mem.offset((r + 5i32) as isize)).b16.s1 = 1_u16;
                            if (*mem.offset((r + 6i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
                            } else {
                                (*mem.offset((r + 6i32) as isize)).gr =
                                    (t - (*mem.offset((r + 3i32) as isize)).b32.s1) as f64
                                        / (*mem.offset((r + 6i32) as isize)).b32.s1 as f64
                            }
                        } else {
                            (*mem.offset((r + 5i32) as isize)).b16.s0 =
                                (*mem.offset((r + 5i32) as isize)).b16.s1;
                            (*mem.offset((r + 5i32) as isize)).b16.s1 = 2_u16;
                            if (*mem.offset((r + 4i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset((r + 6i32) as isize)).gr = 0.0f64
                            } else if (*mem.offset((r + 5i32) as isize)).b16.s0 as i32 == 0i32
                                && (*mem.offset((r + 3i32) as isize)).b32.s1 - t
                                    > (*mem.offset((r + 4i32) as isize)).b32.s1
                            {
                                (*mem.offset((r + 6i32) as isize)).gr = 1.0f64
                            } else {
                                (*mem.offset((r + 6i32) as isize)).gr =
                                    ((*mem.offset((r + 3i32) as isize)).b32.s1 - t) as f64
                                        / (*mem.offset((r + 4i32) as isize)).b32.s1 as f64
                            }
                        }
                        (*mem.offset((r + 3i32) as isize)).b32.s1 = w;
                        (*mem.offset(r as isize)).b16.s1 = 1_u16
                    }
                    (*mem.offset((r + 4i32) as isize)).b32.s1 = 0i32;
                    if u != 4999999i32 - 4i32 {
                        (*mem.offset(u as isize)).b32.s1 = (*mem.offset(r as isize)).b32.s1;
                        (*mem.offset(r as isize)).b32.s1 =
                            (*mem.offset((4999999i32 - 4i32) as isize)).b32.s1;
                        r = u
                    }
                    r = (*mem.offset((*mem.offset(r as isize)).b32.s1 as isize))
                        .b32
                        .s1;
                    s = (*mem.offset((*mem.offset(s as isize)).b32.s1 as isize))
                        .b32
                        .s1;
                    if r == -0xfffffffi32 {
                        break;
                    }
                }
            } else if (*mem.offset(q as isize)).b16.s1 as i32 == 2i32 {
                /*835: */
                if (*mem.offset((q + 1i32) as isize)).b32.s1 == -0x40000000i32 {
                    (*mem.offset((q + 1i32) as isize)).b32.s1 =
                        (*mem.offset((p + 1i32) as isize)).b32.s1
                }
                if (*mem.offset((q + 3i32) as isize)).b32.s1 == -0x40000000i32 {
                    (*mem.offset((q + 3i32) as isize)).b32.s1 =
                        (*mem.offset((p + 3i32) as isize)).b32.s1
                }
                if (*mem.offset((q + 2i32) as isize)).b32.s1 == -0x40000000i32 {
                    (*mem.offset((q + 2i32) as isize)).b32.s1 =
                        (*mem.offset((p + 2i32) as isize)).b32.s1
                }
                if o != 0i32 {
                    r = (*mem.offset(q as isize)).b32.s1;
                    (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
                    q = hpack(q, 0i32, 1i32 as small_number);
                    (*mem.offset((q + 4i32) as isize)).b32.s1 = o;
                    (*mem.offset(q as isize)).b32.s1 = r;
                    (*mem.offset(s as isize)).b32.s1 = q
                }
            }
        }
        s = q;
        q = (*mem.offset(q as isize)).b32.s1
    }
    flush_node_list(p);
    pop_alignment();
    aux_save = cur_list.aux;
    p = (*mem.offset(cur_list.head as isize)).b32.s1;
    q = cur_list.tail;
    pop_nest();
    if cur_list.mode as i32 == 207i32 {
        /*1241: */
        do_assignments(); /*1232: */
        if cur_cmd as i32 != 3i32 {
            /*1242: */
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Missing $$ inserted\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] = b"Displays can use special alignments (like \\eqalignno)\x00"
                as *const u8 as *const i8;
            help_line[0] = b"only if nothing but the alignment itself is between $$\'s.\x00"
                as *const u8 as *const i8;
            back_error();
        } else {
            get_x_token();
            if cur_cmd as i32 != 3i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Display math should end with $$\x00" as *const u8 as *const i8);
                help_ptr = 2_u8;
                help_line[1] = b"The `$\' that I just saw supposedly matches a previous `$$\'.\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"So I shall assume that you typed `$$\' both times.\x00"
                    as *const u8 as *const i8;
                back_error();
            }
        }
        flush_node_list(cur_list.eTeX_aux);
        pop_nest();
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_penalty(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 11i32) as isize,
            ))
            .b32
            .s1,
        );
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_param_glue(3i32 as small_number);
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        if p != -0xfffffffi32 {
            cur_list.tail = q
        }
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_penalty(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 12i32) as isize,
            ))
            .b32
            .s1,
        );
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_param_glue(4i32 as small_number);
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        cur_list.aux.b32.s1 = aux_save.b32.s1;
        resume_after_display();
    } else {
        cur_list.aux = aux_save;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        if p != -0xfffffffi32 {
            cur_list.tail = q
        }
        if cur_list.mode as i32 == 1i32 {
            build_page();
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn align_peek() {
    loop {
        align_state = 1000000i64 as i32;
        loop {
            get_x_or_protected();
            if cur_cmd as i32 != 10i32 {
                break;
            }
        }
        if cur_cmd as i32 == 34i32 {
            scan_left_brace();
            new_save_level(7i32 as group_code);
            if cur_list.mode as i32 == -1i32 {
                normal_paragraph();
            }
            break;
        } else if cur_cmd as i32 == 2i32 {
            fin_align();
            break;
        } else {
            if cur_cmd as i32 == 5i32 && cur_chr == 0x10ffffi32 + 4i32 {
                continue;
            }
            init_row();
            init_col();
            break;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn max_hyphenatable_length() -> i32 {
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 82i32) as isize,
    ))
    .b32
    .s1 > 4095i32
    {
        return 4095i32;
    }
    (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 82i32) as isize,
    ))
    .b32
    .s1
}
#[no_mangle]
pub unsafe extern "C" fn eTeX_enabled(mut b: bool, mut j: u16, mut k: i32) -> bool {
    if !b {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Improper \x00" as *const u8 as *const i8);
        print_cmd_chr(j, k);
        help_ptr = 1_u8;
        help_line[0] =
            b"Sorry, this optional e-TeX feature has been disabled.\x00" as *const u8 as *const i8;
        error();
    }
    b
}
#[no_mangle]
pub unsafe extern "C" fn show_save_groups() {
    let mut current_block: u64;
    let mut p: i32 = 0;
    let mut m: i16 = 0;
    let mut v: save_pointer = 0;
    let mut l: u16 = 0;
    let mut c: group_code = 0;
    let mut a: i8 = 0;
    let mut i: i32 = 0;
    let mut j: u16 = 0;
    let mut s: *const i8 = 0 as *const i8;
    p = nest_ptr;
    *nest.offset(p as isize) = cur_list;
    v = save_ptr;
    l = cur_level;
    c = cur_group;
    save_ptr = cur_boundary;
    cur_level = cur_level.wrapping_sub(1);
    a = 1_i8;
    print_nl_cstr(b"\x00" as *const u8 as *const i8);
    print_ln();
    loop {
        print_nl_cstr(b"### \x00" as *const u8 as *const i8);
        print_group(1i32 != 0);
        if cur_group as i32 == 0i32 {
            break;
        }
        loop {
            m = (*nest.offset(p as isize)).mode;
            if p > 0i32 {
                p -= 1
            } else {
                m = 1_i16
            }
            if !(m as i32 == 104i32) {
                break;
            }
        }
        print_cstr(b" (\x00" as *const u8 as *const i8);
        match cur_group as i32 {
            1 => {
                p += 1;
                current_block = 11054735442240645164;
            }
            2 | 3 => {
                s = b"hbox\x00" as *const u8 as *const i8;
                current_block = 6002151390280567665;
            }
            4 => {
                s = b"vbox\x00" as *const u8 as *const i8;
                current_block = 6002151390280567665;
            }
            5 => {
                s = b"vtop\x00" as *const u8 as *const i8;
                current_block = 6002151390280567665;
            }
            6 => {
                if a as i32 == 0i32 {
                    if m as i32 == -1i32 {
                        s = b"halign\x00" as *const u8 as *const i8
                    } else {
                        s = b"valign\x00" as *const u8 as *const i8
                    }
                    a = 1_i8;
                    current_block = 17798259985923180687;
                } else {
                    if a as i32 == 1i32 {
                        print_cstr(b"align entry\x00" as *const u8 as *const i8);
                    } else {
                        print_esc_cstr(b"cr\x00" as *const u8 as *const i8);
                    }
                    if p >= a as i32 {
                        p = p - a as i32
                    }
                    a = 0_i8;
                    current_block = 5407796692416645153;
                }
            }
            7 => {
                p += 1;
                a = -1_i8;
                print_esc_cstr(b"noalign\x00" as *const u8 as *const i8);
                current_block = 11054735442240645164;
            }
            8 => {
                print_esc_cstr(b"output\x00" as *const u8 as *const i8);
                current_block = 5407796692416645153;
            }
            9 => {
                current_block = 11054735442240645164;
            }
            10 | 13 => {
                if cur_group as i32 == 10i32 {
                    print_esc_cstr(b"discretionary\x00" as *const u8 as *const i8);
                } else {
                    print_esc_cstr(b"mathchoice\x00" as *const u8 as *const i8);
                }
                i = 1i32;
                while i <= 3i32 {
                    if i <= (*save_stack.offset((save_ptr - 2i32) as isize)).b32.s1 {
                        print_cstr(b"{}\x00" as *const u8 as *const i8);
                    }
                    i += 1
                }
                current_block = 11054735442240645164;
            }
            11 => {
                if (*save_stack.offset((save_ptr - 2i32) as isize)).b32.s1 == 255i32 {
                    print_esc_cstr(b"vadjust\x00" as *const u8 as *const i8);
                } else {
                    print_esc_cstr(b"insert\x00" as *const u8 as *const i8);
                    print_int((*save_stack.offset((save_ptr - 2i32) as isize)).b32.s1);
                }
                current_block = 11054735442240645164;
            }
            12 => {
                s = b"vcenter\x00" as *const u8 as *const i8;
                current_block = 17798259985923180687;
            }
            14 => {
                p += 1;
                print_esc_cstr(b"begingroup\x00" as *const u8 as *const i8);
                current_block = 5407796692416645153;
            }
            15 => {
                if m as i32 == 207i32 {
                    print_char('$' as i32);
                    current_block = 17441561948628420366;
                } else if (*nest.offset(p as isize)).mode as i32 == 207i32 {
                    print_cmd_chr(
                        48_u16,
                        (*save_stack.offset((save_ptr - 2i32) as isize)).b32.s1,
                    );
                    current_block = 5407796692416645153;
                } else {
                    current_block = 17441561948628420366;
                }
                match current_block {
                    5407796692416645153 => {}
                    _ => {
                        print_char('$' as i32);
                        current_block = 5407796692416645153;
                    }
                }
            }
            16 => {
                if (*mem.offset((*nest.offset((p + 1i32) as isize)).eTeX_aux as isize))
                    .b16
                    .s1 as i32
                    == 30i32
                {
                    print_esc_cstr(b"left\x00" as *const u8 as *const i8);
                } else {
                    print_esc_cstr(b"middle\x00" as *const u8 as *const i8);
                }
                current_block = 5407796692416645153;
            }
            _ => {
                current_block = 6002151390280567665;
            }
        }
        match current_block {
            6002151390280567665 => {
                i = (*save_stack.offset((save_ptr - 4i32) as isize)).b32.s1;
                if i != 0i32 {
                    if i < 0x40000000i32 {
                        if ((*nest.offset(p as isize)).mode as i32).abs() == 1i32 {
                            j = 21_u16
                        } else {
                            j = 22_u16
                        }
                        if i > 0i32 {
                            print_cmd_chr(j, 0i32);
                        } else {
                            print_cmd_chr(j, 1i32);
                        }
                        print_scaled(i.abs());
                        print_cstr(b"pt\x00" as *const u8 as *const i8);
                    } else if i < 0x40010000i32 {
                        if i >= 0x40008000i32 {
                            print_esc_cstr(b"global\x00" as *const u8 as *const i8);
                            i = i - (0x40008000i32 - 0x40000000i32)
                        }
                        print_esc_cstr(b"setbox\x00" as *const u8 as *const i8);
                        print_int(i - 0x40000000i32);
                        print_char('=' as i32);
                    } else {
                        print_cmd_chr(31_u16, i - (0x40010001i32 - 100i32));
                    }
                }
                current_block = 17798259985923180687;
            }
            _ => {}
        }
        match current_block {
            17798259985923180687 => {
                print_esc_cstr(s);
                if (*save_stack.offset((save_ptr - 2i32) as isize)).b32.s1 != 0i32 {
                    print_char(' ' as i32);
                    if (*save_stack.offset((save_ptr - 3i32) as isize)).b32.s1 == 0i32 {
                        print_cstr(b"to\x00" as *const u8 as *const i8);
                    } else {
                        print_cstr(b"spread\x00" as *const u8 as *const i8);
                    }
                    print_scaled((*save_stack.offset((save_ptr - 2i32) as isize)).b32.s1);
                    print_cstr(b"pt\x00" as *const u8 as *const i8);
                }
                current_block = 11054735442240645164;
            }
            _ => {}
        }
        match current_block {
            11054735442240645164 => {
                print_char('{' as i32);
            }
            _ => {}
        }
        print_char(')' as i32);
        cur_level = cur_level.wrapping_sub(1);
        cur_group = (*save_stack.offset(save_ptr as isize)).b16.s0 as group_code;
        save_ptr = (*save_stack.offset(save_ptr as isize)).b32.s1
    }
    save_ptr = v;
    cur_level = l;
    cur_group = c;
}
#[no_mangle]
pub unsafe extern "C" fn vert_break(mut p: i32, mut h: scaled_t, mut d: scaled_t) -> i32 {
    let mut current_block: u64;
    let mut prev_p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut pi: i32 = 0;
    let mut b: i32 = 0;
    let mut least_cost: i32 = 0;
    let mut best_place: i32 = -0xfffffffi32;
    let mut prev_dp: scaled_t = 0;
    let mut t: small_number = 0;
    prev_p = p;
    least_cost = 0x3fffffffi32;
    active_width[1] = 0i32;
    active_width[2] = 0i32;
    active_width[3] = 0i32;
    active_width[4] = 0i32;
    active_width[5] = 0i32;
    active_width[6] = 0i32;
    prev_dp = 0i32;
    loop {
        if p == -0xfffffffi32 {
            pi = -10000i32;
            current_block = 9007357115414505193;
        } else {
            /*1008: */
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 | 2 => {
                    current_block = 15992561690600734426; /*:1010 */
                    match current_block {
                        5335814873276400744 => {
                            confusion(b"vertbreak\x00" as *const u8 as *const i8);
                        }
                        15992561690600734426 => {
                            active_width[1] = active_width[1]
                                + prev_dp
                                + (*mem.offset((p + 3i32) as isize)).b32.s1;
                            prev_dp = (*mem.offset((p + 2i32) as isize)).b32.s1;
                            current_block = 10249009913728301645;
                        }
                        17919980485942902313 => {
                            if (*mem.offset(p as isize)).b32.s1 == -0xfffffffi32 {
                                t = 12i32 as small_number
                            } else {
                                t = (*mem.offset((*mem.offset(p as isize)).b32.s1 as isize))
                                    .b16
                                    .s1 as small_number
                            }
                            if t as i32 == 10i32 {
                                pi = 0i32;
                                current_block = 9007357115414505193;
                            } else {
                                current_block = 11492179201936201469;
                            }
                        }
                        9310447521173000071 => {
                            if (*mem.offset(p as isize)).b16.s0 as i32 == 43i32
                                || (*mem.offset(p as isize)).b16.s0 as i32 == 44i32
                            {
                                active_width[1] = active_width[1]
                                    + prev_dp
                                    + (*mem.offset((p + 3i32) as isize)).b32.s1;
                                prev_dp = (*mem.offset((p + 2i32) as isize)).b32.s1
                            }
                            current_block = 10249009913728301645;
                        }
                        17538459923738996256 => {
                            pi = (*mem.offset((p + 1i32) as isize)).b32.s1;
                            current_block = 9007357115414505193;
                        }
                        _ => {
                            if is_non_discardable_node(prev_p) {
                                pi = 0i32;
                                current_block = 9007357115414505193;
                            } else {
                                current_block = 11492179201936201469;
                            }
                        }
                    }
                }
                8 => {
                    if (*mem.offset(p as isize)).b16.s0 as i32 == 43i32
                        || (*mem.offset(p as isize)).b16.s0 as i32 == 44i32
                    {
                        active_width[1] =
                            active_width[1] + prev_dp + (*mem.offset((p + 3i32) as isize)).b32.s1;
                        prev_dp = (*mem.offset((p + 2i32) as isize)).b32.s1
                    }
                    current_block = 10249009913728301645;
                }
                10 => {
                    if is_non_discardable_node(prev_p) {
                        pi = 0i32;
                        current_block = 9007357115414505193;
                    } else {
                        current_block = 11492179201936201469;
                    }
                }
                11 => {
                    if (*mem.offset(p as isize)).b32.s1 == -0xfffffffi32 {
                        t = 12i32 as small_number
                    } else {
                        t = (*mem.offset((*mem.offset(p as isize)).b32.s1 as isize))
                            .b16
                            .s1 as small_number
                    }
                    if t as i32 == 10i32 {
                        pi = 0i32;
                        current_block = 9007357115414505193;
                    } else {
                        current_block = 11492179201936201469;
                    }
                }
                12 => {
                    pi = (*mem.offset((p + 1i32) as isize)).b32.s1;
                    current_block = 9007357115414505193;
                }
                4 | 3 => {
                    current_block = 10249009913728301645;
                }
                _ => {
                    current_block = 5335814873276400744;
                    confusion(b"vertbreak\x00" as *const u8 as *const i8);
                }
            }
        }
        match current_block {
            9007357115414505193 => {
                if pi < 10000i32 {
                    if active_width[1] < h {
                        if active_width[3] != 0i32
                            || active_width[4] != 0i32
                            || active_width[5] != 0i32
                        {
                            b = 0i32
                        } else {
                            b = badness(h - active_width[1], active_width[2])
                        }
                    } else if active_width[1] - h > active_width[6] {
                        b = 0x3fffffffi32
                    } else {
                        b = badness(active_width[1] - h, active_width[6])
                    }
                    if b < 0x3fffffffi32 {
                        if pi <= -10000i32 {
                            b = pi
                        } else if b < 10000i32 {
                            b = b + pi
                        } else {
                            b = 100000i64 as i32
                        }
                    }
                    if b <= least_cost {
                        best_place = p;
                        least_cost = b;
                        best_height_plus_depth = active_width[1] + prev_dp
                    }
                    if b == 0x3fffffffi32 || pi <= -10000i32 {
                        break;
                    }
                }
                if ((*mem.offset(p as isize)).b16.s1 as i32) < 10i32
                    || (*mem.offset(p as isize)).b16.s1 as i32 > 11i32
                {
                    current_block = 10249009913728301645;
                } else {
                    current_block = 11492179201936201469;
                }
            }
            _ => {}
        }
        match current_block {
            11492179201936201469 => {
                /*update_heights *//*1011: */
                if (*mem.offset(p as isize)).b16.s1 as i32 == 11i32 {
                    q = p
                } else {
                    q = (*mem.offset((p + 1i32) as isize)).b32.s0; /*:1011 */
                    active_width[(2i32 + (*mem.offset(q as isize)).b16.s1 as i32) as usize] =
                        active_width[(2i32 + (*mem.offset(q as isize)).b16.s1 as i32) as usize]
                            + (*mem.offset((q + 2i32) as isize)).b32.s1; /*:1014*/
                    active_width[6] = active_width[6] + (*mem.offset((q + 3i32) as isize)).b32.s1;
                    if (*mem.offset(q as isize)).b16.s0 as i32 != 0i32
                        && (*mem.offset((q + 3i32) as isize)).b32.s1 != 0i32
                    {
                        if file_line_error_style_p != 0 {
                            print_file_line();
                        } else {
                            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                        }
                        print_cstr(
                            b"Infinite glue shrinkage found in box being split\x00" as *const u8
                                as *const i8,
                        );
                        help_ptr = 4_u8;
                        help_line[3] = b"The box you are \\vsplitting contains some infinitely\x00"
                            as *const u8 as *const i8;
                        help_line[2] =
                            b"shrinkable glue, e.g., `\\vss\' or `\\vskip 0pt minus 1fil\'.\x00"
                                as *const u8 as *const i8;
                        help_line[1] =
                            b"Such glue doesn\'t belong there; but you can safely proceed,\x00"
                                as *const u8 as *const i8;
                        help_line[0] =
                            b"since the offensive shrinkability has been made finite.\x00"
                                as *const u8 as *const i8;
                        error();
                        r = new_spec(q);
                        (*mem.offset(r as isize)).b16.s0 = 0_u16;
                        delete_glue_ref(q);
                        (*mem.offset((p + 1i32) as isize)).b32.s0 = r;
                        q = r
                    }
                }
                active_width[1] =
                    active_width[1] + prev_dp + (*mem.offset((q + 1i32) as isize)).b32.s1;
                prev_dp = 0i32
            }
            _ => {}
        }
        if prev_dp > d {
            active_width[1] = active_width[1] + prev_dp - d;
            prev_dp = d
        }
        prev_p = p;
        p = (*mem.offset(prev_p as isize)).b32.s1
    }
    best_place
}
#[no_mangle]
pub unsafe extern "C" fn vsplit(mut n: i32, mut h: scaled_t) -> i32 {
    let mut v: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    cur_val = n;
    if cur_val < 256i32 {
        v = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + cur_val) as isize,
        ))
        .b32
        .s1
    } else {
        find_sa_element(4i32 as small_number, cur_val, false);
        if cur_ptr == -0xfffffffi32 {
            v = -0xfffffffi32
        } else {
            v = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
        }
    }
    flush_node_list(disc_ptr[3]);
    disc_ptr[3] = -0xfffffffi32;
    if sa_root[7] != -0xfffffffi32 {
        if do_marks(0i32 as small_number, 0i32 as small_number, sa_root[7]) {
            sa_root[7] = -0xfffffffi32
        }
    }
    if cur_mark[3] != -0xfffffffi32 {
        delete_token_ref(cur_mark[3]);
        cur_mark[3] = -0xfffffffi32;
        delete_token_ref(cur_mark[4]);
        cur_mark[4] = -0xfffffffi32
    }
    if v == -0xfffffffi32 {
        return -0xfffffffi32;
    }
    if (*mem.offset(v as isize)).b16.s1 as i32 != 1i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"\x00" as *const u8 as *const i8);
        print_esc_cstr(b"vsplit\x00" as *const u8 as *const i8);
        print_cstr(b" needs a \x00" as *const u8 as *const i8);
        print_esc_cstr(b"vbox\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"The box you are trying to split is an \\hbox.\x00" as *const u8 as *const i8;
        help_line[0] =
            b"I can\'t split such a box, so I\'ll leave it alone.\x00" as *const u8 as *const i8;
        error();
        return -0xfffffffi32;
    }
    q = vert_break(
        (*mem.offset((v + 5i32) as isize)).b32.s1,
        h,
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 6i32) as isize,
        ))
        .b32
        .s1,
    );
    p = (*mem.offset((v + 5i32) as isize)).b32.s1;
    if p == q {
        (*mem.offset((v + 5i32) as isize)).b32.s1 = -0xfffffffi32
    } else {
        loop {
            if (*mem.offset(p as isize)).b16.s1 as i32 == 4i32 {
                if (*mem.offset((p + 1i32) as isize)).b32.s0 != 0i32 {
                    /*1615: */
                    find_sa_element(
                        7i32 as small_number,
                        (*mem.offset((p + 1i32) as isize)).b32.s0,
                        true,
                    );
                    if (*mem.offset((cur_ptr + 2i32) as isize)).b32.s1 == -0xfffffffi32 {
                        (*mem.offset((cur_ptr + 2i32) as isize)).b32.s1 =
                            (*mem.offset((p + 1i32) as isize)).b32.s1;
                        let ref mut fresh71 = (*mem
                            .offset((*mem.offset((p + 1i32) as isize)).b32.s1 as isize))
                        .b32
                        .s0;
                        *fresh71 += 1
                    } else {
                        delete_token_ref((*mem.offset((cur_ptr + 3i32) as isize)).b32.s0);
                    }
                    (*mem.offset((cur_ptr + 3i32) as isize)).b32.s0 =
                        (*mem.offset((p + 1i32) as isize)).b32.s1;
                    let ref mut fresh72 = (*mem
                        .offset((*mem.offset((p + 1i32) as isize)).b32.s1 as isize))
                    .b32
                    .s0;
                    *fresh72 += 1
                } else if cur_mark[3] == -0xfffffffi32 {
                    cur_mark[3] = (*mem.offset((p + 1i32) as isize)).b32.s1;
                    cur_mark[4] = cur_mark[3];
                    (*mem.offset(cur_mark[3] as isize)).b32.s0 =
                        (*mem.offset(cur_mark[3] as isize)).b32.s0 + 2i32
                } else {
                    delete_token_ref(cur_mark[4]);
                    cur_mark[4] = (*mem.offset((p + 1i32) as isize)).b32.s1;
                    let ref mut fresh73 = (*mem.offset(cur_mark[4] as isize)).b32.s0;
                    *fresh73 += 1
                }
            }
            if (*mem.offset(p as isize)).b32.s1 == q {
                (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
                break;
            } else {
                p = (*mem.offset(p as isize)).b32.s1
            }
        }
    }
    q = prune_page_top(
        q,
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 65i32) as isize,
        ))
        .b32
        .s1 > 0i32,
    );
    p = (*mem.offset((v + 5i32) as isize)).b32.s1;
    free_node(v, 8i32);
    if q != -0xfffffffi32 {
        q = vpackage(q, 0i32, 1i32 as small_number, 0x3fffffffi32)
    }
    if cur_val < 256i32 {
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + cur_val) as isize,
        ))
        .b32
        .s1 = q
    } else {
        find_sa_element(4i32 as small_number, cur_val, false);
        if cur_ptr != -0xfffffffi32 {
            (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1 = q;
            let ref mut fresh74 = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s0;
            *fresh74 += 1;
            delete_sa_ref(cur_ptr);
        }
    }
    vpackage(
        p,
        h,
        0i32 as small_number,
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 6i32) as isize,
        ))
        .b32
        .s1,
    )
}
#[no_mangle]
pub unsafe extern "C" fn print_totals() {
    print_scaled(page_so_far[1]);
    if page_so_far[2] != 0i32 {
        print_cstr(b" plus \x00" as *const u8 as *const i8);
        print_scaled(page_so_far[2]);
        print_cstr(b"\x00" as *const u8 as *const i8);
    }
    if page_so_far[3] != 0i32 {
        print_cstr(b" plus \x00" as *const u8 as *const i8);
        print_scaled(page_so_far[3]);
        print_cstr(b"fil\x00" as *const u8 as *const i8);
    }
    if page_so_far[4] != 0i32 {
        print_cstr(b" plus \x00" as *const u8 as *const i8);
        print_scaled(page_so_far[4]);
        print_cstr(b"fill\x00" as *const u8 as *const i8);
    }
    if page_so_far[5] != 0i32 {
        print_cstr(b" plus \x00" as *const u8 as *const i8);
        print_scaled(page_so_far[5]);
        print_cstr(b"filll\x00" as *const u8 as *const i8);
    }
    if page_so_far[6] != 0i32 {
        print_cstr(b" minus \x00" as *const u8 as *const i8);
        print_scaled(page_so_far[6]);
    };
}
#[no_mangle]
pub unsafe extern "C" fn box_error(mut n: eight_bits) {
    error();
    begin_diagnostic();
    print_nl_cstr(b"The following box has been deleted:\x00" as *const u8 as *const i8);
    show_box(
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + n as i32) as isize,
        ))
        .b32
        .s1,
    );
    end_diagnostic(1i32 != 0);
    flush_node_list(
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + n as i32) as isize,
        ))
        .b32
        .s1,
    );
    (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + n as i32) as isize,
    ))
    .b32
    .s1 = -0xfffffffi32;
}
#[no_mangle]
pub unsafe extern "C" fn app_space() {
    let mut q: i32 = 0;
    if cur_list.aux.b32.s0 >= 2000i32
        && (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 13i32) as isize,
        ))
        .b32
        .s1 != 0i32
    {
        q = new_param_glue(13i32 as small_number)
    } else {
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 12i32) as isize,
        ))
        .b32
        .s1 != 0i32
        {
            main_p = (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 12i32) as isize,
            ))
            .b32
            .s1
        } else {
            /*1077: */
            main_p = *font_glue.offset(
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32) as isize,
                ))
                .b32
                .s1 as isize,
            ); /*:1079 */
            if main_p == -0xfffffffi32 {
                main_p = new_spec(0i32);
                main_k = *param_base.offset(
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32) as isize,
                    ))
                    .b32
                    .s1 as isize,
                ) + 2i32;
                (*mem.offset((main_p + 1i32) as isize)).b32.s1 =
                    (*font_info.offset(main_k as isize)).b32.s1;
                (*mem.offset((main_p + 2i32) as isize)).b32.s1 =
                    (*font_info.offset((main_k + 1i32) as isize)).b32.s1;
                (*mem.offset((main_p + 3i32) as isize)).b32.s1 =
                    (*font_info.offset((main_k + 2i32) as isize)).b32.s1;
                *font_glue.offset(
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32) as isize,
                    ))
                    .b32
                    .s1 as isize,
                ) = main_p
            }
        }
        main_p = new_spec(main_p);
        if cur_list.aux.b32.s0 >= 2000i32 {
            (*mem.offset((main_p + 1i32) as isize)).b32.s1 =
                (*mem.offset((main_p + 1i32) as isize)).b32.s1
                    + (*font_info.offset(
                        (7i32
                            + *param_base.offset(
                                (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32) as isize,
                                ))
                                .b32
                                .s1 as isize,
                            )) as isize,
                    ))
                    .b32
                    .s1
        }
        (*mem.offset((main_p + 2i32) as isize)).b32.s1 = xn_over_d(
            (*mem.offset((main_p + 2i32) as isize)).b32.s1,
            cur_list.aux.b32.s0,
            1000i32,
        );
        (*mem.offset((main_p + 3i32) as isize)).b32.s1 = xn_over_d(
            (*mem.offset((main_p + 3i32) as isize)).b32.s1,
            1000i32,
            cur_list.aux.b32.s0,
        );
        q = new_glue(main_p);
        (*mem.offset(main_p as isize)).b32.s1 = -0xfffffffi32
    }
    (*mem.offset(cur_list.tail as isize)).b32.s1 = q;
    cur_list.tail = q;
}
#[no_mangle]
pub unsafe extern "C" fn insert_dollar_sign() {
    back_input();
    cur_tok = 0x600000i32 + 36i32;
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Missing $ inserted\x00" as *const u8 as *const i8);
    help_ptr = 2_u8;
    help_line[1] =
        b"I\'ve inserted a begin-math/end-math symbol since I think\x00" as *const u8 as *const i8;
    help_line[0] =
        b"you left one out. Proceed, with fingers crossed.\x00" as *const u8 as *const i8;
    ins_error();
}
#[no_mangle]
pub unsafe extern "C" fn you_cant() {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"You can\'t use `\x00" as *const u8 as *const i8);
    print_cmd_chr(cur_cmd as u16, cur_chr);
    print_in_mode(cur_list.mode as i32);
}
#[no_mangle]
pub unsafe extern "C" fn report_illegal_case() {
    you_cant();
    help_ptr = 4_u8;
    help_line[3] =
        b"Sorry, but I\'m not programmed to handle this case;\x00" as *const u8 as *const i8;
    help_line[2] = b"I\'ll just pretend that you didn\'t ask for it.\x00" as *const u8 as *const i8;
    help_line[1] =
        b"If you\'re in the wrong mode, you might be able to\x00" as *const u8 as *const i8;
    help_line[0] = b"return to the right one by typing `I}\' or `I$\' or `I\\par\'.\x00"
        as *const u8 as *const i8;
    error();
}
#[no_mangle]
pub unsafe extern "C" fn privileged() -> bool {
    if cur_list.mode as i32 > 0i32 {
        true
    } else {
        report_illegal_case();
        false
    }
}
#[no_mangle]
pub unsafe extern "C" fn its_all_over() -> bool {
    if privileged() {
        if 4999999i32 - 2i32 == page_tail && cur_list.head == cur_list.tail && dead_cycles == 0i32 {
            return true;
        }
        back_input();
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_null_box();
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 3i32) as isize,
        ))
        .b32
        .s1;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_glue(8i32);
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_penalty(-0x40000000i32);
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        build_page();
    }
    false
}
#[no_mangle]
pub unsafe extern "C" fn append_glue() {
    let mut s: small_number = 0;
    s = cur_chr as small_number;
    match s as i32 {
        0 => cur_val = 4i32,
        1 => cur_val = 8i32,
        2 => cur_val = 12i32,
        3 => cur_val = 16i32,
        4 => {
            scan_glue(2i32 as small_number);
        }
        5 => {
            scan_glue(3i32 as small_number);
        }
        _ => {}
    }
    (*mem.offset(cur_list.tail as isize)).b32.s1 = new_glue(cur_val);
    cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
    if s as i32 >= 4i32 {
        let ref mut fresh75 = (*mem.offset(cur_val as isize)).b32.s1;
        *fresh75 -= 1;
        if s as i32 > 4i32 {
            (*mem.offset(cur_list.tail as isize)).b16.s0 = 99_u16
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn append_kern() {
    let mut s: u16 = 0;
    s = cur_chr as u16;
    scan_dimen(s as i32 == 99i32, false, false);
    (*mem.offset(cur_list.tail as isize)).b32.s1 = new_kern(cur_val);
    cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
    (*mem.offset(cur_list.tail as isize)).b16.s0 = s;
}
#[no_mangle]
pub unsafe extern "C" fn off_save() {
    let mut p: i32 = 0;
    if cur_group as i32 == 0i32 {
        /*1101:*/
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Extra \x00" as *const u8 as *const i8);
        print_cmd_chr(cur_cmd as u16, cur_chr);
        help_ptr = 1_u8;
        help_line[0] = b"Things are pretty mixed up, but I think the worst is over.\x00"
            as *const u8 as *const i8;
        error();
    } else {
        back_input();
        p = get_avail();
        (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 = p;
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Missing \x00" as *const u8 as *const i8);
        match cur_group as i32 {
            14 => {
                (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
                    + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 2i32);
                print_esc_cstr(b"endgroup\x00" as *const u8 as *const i8);
            }
            15 => {
                (*mem.offset(p as isize)).b32.s0 = 0x600000i32 + '$' as i32;
                print_char('$' as i32);
            }
            16 => {
                (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
                    + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 3i32);
                (*mem.offset(p as isize)).b32.s1 = get_avail();
                p = (*mem.offset(p as isize)).b32.s1;
                (*mem.offset(p as isize)).b32.s0 = 0x1800000i32 + '.' as i32;
                print_esc_cstr(b"right.\x00" as *const u8 as *const i8);
            }
            _ => {
                (*mem.offset(p as isize)).b32.s0 = 0x400000i32 + '}' as i32;
                print_char('}' as i32);
            }
        }
        print_cstr(b" inserted\x00" as *const u8 as *const i8);
        begin_token_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1, 5_u16);
        help_ptr = 5_u8;
        help_line[4] =
            b"I\'ve inserted something that you may have forgotten.\x00" as *const u8 as *const i8;
        help_line[3] = b"(See the <inserted text> above.)\x00" as *const u8 as *const i8;
        help_line[2] =
            b"With luck, this will get me unwedged. But if you\x00" as *const u8 as *const i8;
        help_line[1] = b"really didn\'t forget anything, try typing `2\' now; then\x00" as *const u8
            as *const i8;
        help_line[0] = b"my insertion and my current dilemma will both disappear.\x00" as *const u8
            as *const i8;
        error();
    };
}
#[no_mangle]
pub unsafe extern "C" fn extra_right_brace() {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Extra }, or forgotten \x00" as *const u8 as *const i8);
    match cur_group as i32 {
        14 => {
            print_esc_cstr(b"endgroup\x00" as *const u8 as *const i8);
        }
        15 => {
            print_char('$' as i32);
        }
        16 => {
            print_esc_cstr(b"right\x00" as *const u8 as *const i8);
        }
        _ => {}
    }
    help_ptr = 5_u8;
    help_line[4] = b"I\'ve deleted a group-closing symbol because it seems to be\x00" as *const u8
        as *const i8;
    help_line[3] = b"spurious, as in `$x}$\'. But perhaps the } is legitimate and\x00" as *const u8
        as *const i8;
    help_line[2] = b"you forgot something else, as in `\\hbox{$x}\'. In such cases\x00" as *const u8
        as *const i8;
    help_line[1] =
        b"the way to recover is to insert both the forgotten and the\x00" as *const u8 as *const i8;
    help_line[0] = b"deleted material, e.g., by typing `I$}\'.\x00" as *const u8 as *const i8;
    error();
    align_state += 1;
}
#[no_mangle]
pub unsafe extern "C" fn normal_paragraph() {
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 19i32) as isize,
    ))
    .b32
    .s1 != 0i32
    {
        eq_word_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 19i32,
            0i32,
        );
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 85i32
            + 256i32
            + (0x10ffffi32 + 1i32)
            + 17i32) as isize,
    ))
    .b32
    .s1 != 0i32
    {
        eq_word_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)
                + 17i32,
            0i32,
        );
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 41i32) as isize,
    ))
    .b32
    .s1 != 1i32
    {
        eq_word_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 41i32,
            1i32,
        );
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 0i32) as isize,
    ))
    .b32
    .s1 != -0xfffffffi32
    {
        eq_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 0i32,
            120_u16,
            -0xfffffffi32,
        );
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 0i32) as isize,
    ))
    .b32
    .s1 != -0xfffffffi32
    {
        eq_define(
            1i32 + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 0i32,
            120_u16,
            -0xfffffffi32,
        );
    };
}
/*1110: "The box_end procedure does the right thing with cur_box, if
 * box_context represents the context as explained [as follows]." The
 * box_context is one of (1) a signed shift amount; (2) BOX_FLAG+N, signifying
 * a `\setbox<N>`; (3) GLOBAL_BOX_FLAG+N, signifying `\global\setbox<N>`; (4)
 * SHIP_OUT_FLAG, signifying `\shipout`; or (5) LEADER_FLAG+k, signifying (in
 * order) `\leaders`, `\cleaders`, or `\xleaders`. */
#[no_mangle]
pub unsafe extern "C" fn box_end(mut box_context: i32) {
    let mut p: i32 = 0;
    let mut a: small_number = 0;
    if box_context < 0x40000000i32 {
        /*1111:*/
        if cur_box != -0xfffffffi32 {
            (*mem.offset((cur_box + 4i32) as isize)).b32.s1 = box_context;
            if (cur_list.mode as i32).abs() == 1i32 {
                if pre_adjust_tail != -0xfffffffi32 {
                    if 4999999i32 - 14i32 != pre_adjust_tail {
                        (*mem.offset(cur_list.tail as isize)).b32.s1 =
                            (*mem.offset((4999999i32 - 14i32) as isize)).b32.s1;
                        cur_list.tail = pre_adjust_tail
                    }
                    pre_adjust_tail = -0xfffffffi32
                }
                append_to_vlist(cur_box);
                if adjust_tail != -0xfffffffi32 {
                    if 4999999i32 - 5i32 != adjust_tail {
                        (*mem.offset(cur_list.tail as isize)).b32.s1 =
                            (*mem.offset((4999999i32 - 5i32) as isize)).b32.s1;
                        cur_list.tail = adjust_tail
                    }
                    adjust_tail = -0xfffffffi32
                }
                if cur_list.mode as i32 > 0i32 {
                    build_page();
                }
            } else {
                if (cur_list.mode as i32).abs() == 104i32 {
                    cur_list.aux.b32.s0 = 1000i32
                } else {
                    p = new_noad();
                    (*mem.offset((p + 1i32) as isize)).b32.s1 = 2i32;
                    (*mem.offset((p + 1i32) as isize)).b32.s0 = cur_box;
                    cur_box = p
                }
                (*mem.offset(cur_list.tail as isize)).b32.s1 = cur_box;
                cur_list.tail = cur_box
            }
        }
    } else if box_context < 0x40010000i32 {
        /*1112:*/
        if box_context < 0x40008000i32 {
            cur_val = box_context - 0x40000000i32;
            a = 0i32 as small_number
        } else {
            cur_val = box_context - 0x40008000i32;
            a = 4i32 as small_number
        }
        if cur_val < 256i32 {
            if a as i32 >= 4i32 {
                geq_define(
                    1i32 + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val,
                    121_u16,
                    cur_box,
                );
            } else {
                eq_define(
                    1i32 + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val,
                    121_u16,
                    cur_box,
                );
            }
        } else {
            find_sa_element(4i32 as small_number, cur_val, true);
            if a as i32 >= 4i32 {
                gsa_def(cur_ptr, cur_box);
            } else {
                sa_def(cur_ptr, cur_box);
            }
        }
    } else if cur_box != -0xfffffffi32 {
        if box_context > 0x40010000i32 {
            loop
            /*1113:*/
            {
                get_x_token();
                if !(cur_cmd as i32 == 10i32 || cur_cmd as i32 == 0i32) {
                    break;
                }
            }
            if cur_cmd as i32 == 26i32 && (cur_list.mode as i32).abs() != 1i32
                || cur_cmd as i32 == 27i32 && (cur_list.mode as i32).abs() == 1i32
            {
                append_glue();
                (*mem.offset(cur_list.tail as isize)).b16.s0 =
                    (box_context - (0x40010001i32 - 100i32)) as u16;
                (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = cur_box
            } else {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Leaders not followed by proper glue\x00" as *const u8 as *const i8);
                help_ptr = 3_u8;
                help_line[2] = b"You should say `\\leaders <box or rule><hskip or vskip>\'.\x00"
                    as *const u8 as *const i8;
                help_line[1] = b"I found the <box or rule>, but there\'s no suitable\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"<hskip or vskip>, so I\'m ignoring these leaders.\x00" as *const u8
                    as *const i8;
                back_error();
                flush_node_list(cur_box);
            }
        } else {
            ship_out(cur_box);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn begin_box(mut box_context: i32) {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut fm: bool = false;
    let mut tx: i32 = 0;
    let mut m: u16 = 0;
    let mut k: i32 = 0;
    let mut n: i32 = 0;
    match cur_chr {
        0 => {
            scan_register_num();
            if cur_val < 256i32 {
                cur_box = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr == -0xfffffffi32 {
                    cur_box = -0xfffffffi32
                } else {
                    cur_box = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                }
            }
            if cur_val < 256i32 {
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1 = -0xfffffffi32
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr != -0xfffffffi32 {
                    (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1 = -0xfffffffi32;
                    let ref mut fresh76 = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s0;
                    *fresh76 += 1;
                    delete_sa_ref(cur_ptr);
                }
            }
        }
        1 => {
            scan_register_num();
            if cur_val < 256i32 {
                q = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr == -0xfffffffi32 {
                    q = -0xfffffffi32
                } else {
                    q = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                }
            }
            cur_box = copy_node_list(q)
        }
        2 => {
            cur_box = -0xfffffffi32;
            if (cur_list.mode as i32).abs() == 207i32 {
                you_cant();
                help_ptr = 1_u8;
                help_line[0] = b"Sorry; this \\lastbox will be void.\x00" as *const u8 as *const i8;
                error();
            } else if cur_list.mode as i32 == 1i32 && cur_list.head == cur_list.tail {
                you_cant();
                help_ptr = 2_u8;
                help_line[1] = b"Sorry...I usually can\'t take things from the current page.\x00"
                    as *const u8 as *const i8;
                help_line[0] =
                    b"This \\lastbox will therefore be void.\x00" as *const u8 as *const i8;
                error();
            } else {
                let mut current_block_79: u64;
                tx = cur_list.tail;
                if tx < hi_mem_min {
                    if (*mem.offset(tx as isize)).b16.s1 as i32 == 9i32
                        && (*mem.offset(tx as isize)).b16.s0 as i32 == 3i32
                    {
                        r = cur_list.head;
                        loop {
                            q = r;
                            r = (*mem.offset(q as isize)).b32.s1;
                            if !(r != tx) {
                                break;
                            }
                        }
                        tx = q
                    }
                }
                if tx < hi_mem_min {
                    if (*mem.offset(tx as isize)).b16.s1 as i32 == 0i32
                        || (*mem.offset(tx as isize)).b16.s1 as i32 == 1i32
                    {
                        /*1116:*/
                        q = cur_list.head;
                        p = -0xfffffffi32;
                        loop {
                            r = p;
                            p = q;
                            fm = false;
                            if q < hi_mem_min {
                                if (*mem.offset(q as isize)).b16.s1 as i32 == 7i32 {
                                    m = 1_u16;
                                    while m as i32 <= (*mem.offset(q as isize)).b16.s0 as i32 {
                                        p = (*mem.offset(p as isize)).b32.s1;
                                        m = m.wrapping_add(1)
                                    }
                                    if p == tx {
                                        current_block_79 = 1209030638129645089;
                                        break;
                                    }
                                } else if (*mem.offset(q as isize)).b16.s1 as i32 == 9i32
                                    && (*mem.offset(q as isize)).b16.s0 as i32 == 2i32
                                {
                                    fm = true
                                }
                            }
                            q = (*mem.offset(p as isize)).b32.s1;
                            if !(q != tx) {
                                current_block_79 = 12961834331865314435;
                                break;
                            }
                        }
                        match current_block_79 {
                            1209030638129645089 => {}
                            _ => {
                                q = (*mem.offset(tx as isize)).b32.s1;
                                (*mem.offset(p as isize)).b32.s1 = q;
                                (*mem.offset(tx as isize)).b32.s1 = -0xfffffffi32;
                                if q == -0xfffffffi32 {
                                    if fm {
                                        confusion(b"tail1\x00" as *const u8 as *const i8);
                                    } else {
                                        cur_list.tail = p
                                    }
                                } else if fm {
                                    cur_list.tail = r;
                                    (*mem.offset(r as isize)).b32.s1 = -0xfffffffi32;
                                    flush_node_list(p);
                                }
                                cur_box = tx;
                                (*mem.offset((cur_box + 4i32) as isize)).b32.s1 = 0i32
                            }
                        }
                    }
                }
            }
        }
        3 => {
            scan_register_num();
            n = cur_val;
            if !scan_keyword(b"to\x00" as *const u8 as *const i8) {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Missing `to\' inserted\x00" as *const u8 as *const i8);
                help_ptr = 2_u8;
                help_line[1] = b"I\'m working on `\\vsplit<box number> to <dimen>\';\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"will look for the <dimen> next.\x00" as *const u8 as *const i8;
                error();
            }
            scan_dimen(false, false, false);
            cur_box = vsplit(n, cur_val)
        }
        _ => {
            k = cur_chr - 4i32;
            (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 = box_context;
            if k == 104i32 {
                if box_context < 0x40000000i32 && (cur_list.mode as i32).abs() == 1i32 {
                    scan_spec(3i32 as group_code, true);
                } else {
                    scan_spec(2i32 as group_code, true);
                }
            } else {
                if k == 1i32 {
                    scan_spec(4i32 as group_code, true);
                } else {
                    scan_spec(5i32 as group_code, true);
                    k = 1i32
                }
                normal_paragraph();
            }
            push_nest();
            cur_list.mode = -k as i16;
            if k == 1i32 {
                cur_list.aux.b32.s1 = -65536000i32;
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 6i32) as isize,
                ))
                .b32
                .s1 != -0xfffffffi32
                {
                    begin_token_list(
                        (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 6i32) as isize,
                        ))
                        .b32
                        .s1,
                        12_u16,
                    );
                }
            } else {
                cur_list.aux.b32.s0 = 1000i32;
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 5i32) as isize,
                ))
                .b32
                .s1 != -0xfffffffi32
                {
                    begin_token_list(
                        (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 5i32) as isize,
                        ))
                        .b32
                        .s1,
                        11_u16,
                    );
                }
            }
            return;
        }
    }
    box_end(box_context);
}
#[no_mangle]
pub unsafe extern "C" fn scan_box(mut box_context: i32) {
    loop {
        get_x_token();
        if !(cur_cmd as i32 == 10i32 || cur_cmd as i32 == 0i32) {
            break;
        }
    }
    if cur_cmd as i32 == 20i32 {
        begin_box(box_context);
    } else if box_context >= 0x40010001i32 && (cur_cmd as i32 == 36i32 || cur_cmd as i32 == 35i32) {
        cur_box = scan_rule_spec();
        box_end(box_context);
    } else {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"A <box> was supposed to be here\x00" as *const u8 as *const i8);
        help_ptr = 3_u8;
        help_line[2] = b"I was expecting to see \\hbox or \\vbox or \\copy or \\box or\x00"
            as *const u8 as *const i8;
        help_line[1] = b"something like that. So you might find something missing in\x00"
            as *const u8 as *const i8;
        help_line[0] =
            b"your output. But keep trying; you can fix this later.\x00" as *const u8 as *const i8;
        back_error();
    };
}
#[no_mangle]
pub unsafe extern "C" fn package(mut c: small_number) {
    let mut h: scaled_t = 0;
    let mut p: i32 = 0;
    let mut d: scaled_t = 0;
    let mut u: i32 = 0;
    let mut v: i32 = 0;
    d = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 85i32
            + 256i32
            + (0x10ffffi32 + 1i32)
            + 7i32) as isize,
    ))
    .b32
    .s1;
    u = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 73i32) as isize,
    ))
    .b32
    .s1;
    unsave();
    save_ptr = save_ptr - 3i32;
    v = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 73i32) as isize,
    ))
    .b32
    .s1;
    (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 73i32) as isize,
    ))
    .b32
    .s1 = u;
    if cur_list.mode as i32 == -104i32 {
        cur_box = hpack(
            (*mem.offset(cur_list.head as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 2i32) as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1 as small_number,
        )
    } else {
        cur_box = vpackage(
            (*mem.offset(cur_list.head as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 2i32) as isize)).b32.s1,
            (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1 as small_number,
            d,
        );
        if c as i32 == 4i32 {
            /*1122: */
            h = 0i32;
            p = (*mem.offset((cur_box + 5i32) as isize)).b32.s1;
            if p != -0xfffffffi32 {
                if (*mem.offset(p as isize)).b16.s1 as i32 <= 2i32 {
                    h = (*mem.offset((p + 3i32) as isize)).b32.s1
                }
            }
            (*mem.offset((cur_box + 2i32) as isize)).b32.s1 =
                (*mem.offset((cur_box + 2i32) as isize)).b32.s1 - h
                    + (*mem.offset((cur_box + 3i32) as isize)).b32.s1;
            (*mem.offset((cur_box + 3i32) as isize)).b32.s1 = h
        }
    }
    (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 73i32) as isize,
    ))
    .b32
    .s1 = v;
    pop_nest();
    box_end((*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1);
}
#[no_mangle]
pub unsafe extern "C" fn norm_min(mut h: i32) -> small_number {
    (if h <= 0 {
        1
    } else if h >= 63i32 {
        63
    } else {
        h
    }) as small_number
}
#[no_mangle]
pub unsafe extern "C" fn new_graf(mut indented: bool) {
    cur_list.prev_graf = 0i32;
    if cur_list.mode as i32 == 1i32 || cur_list.head != cur_list.tail {
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_param_glue(2i32 as small_number);
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
    }
    push_nest();
    cur_list.mode = 104_i16;
    cur_list.aux.b32.s0 = 1000i32;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 50i32) as isize,
    ))
    .b32
    .s1 <= 0i32
    {
        cur_lang = 0_u8
    } else if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 50i32) as isize,
    ))
    .b32
    .s1 > 255i32
    {
        cur_lang = 0_u8
    } else {
        cur_lang = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 50i32) as isize,
        ))
        .b32
        .s1 as u8
    }
    cur_list.aux.b32.s1 = cur_lang as i32;
    cur_list.prev_graf = ((norm_min(
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 51i32) as isize,
        ))
        .b32
        .s1,
    ) as i32
        * 64i32
        + norm_min(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 52i32) as isize,
            ))
            .b32
            .s1,
        ) as i32) as i64
        * 65536
        + cur_lang as i64) as i32;
    if indented {
        cur_list.tail = new_null_box();
        (*mem.offset(cur_list.head as isize)).b32.s1 = cur_list.tail;
        (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)) as isize,
        ))
        .b32
        .s1;
        if insert_src_special_every_par {
            insert_src_special();
        }
    }
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 2i32) as isize,
    ))
    .b32
    .s1 != -0xfffffffi32
    {
        begin_token_list(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 2i32) as isize,
            ))
            .b32
            .s1,
            8_u16,
        );
    }
    if nest_ptr == 1i32 {
        build_page();
    };
}
#[no_mangle]
pub unsafe extern "C" fn indent_in_hmode() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    if cur_chr > 0i32 {
        p = new_null_box();
        (*mem.offset((p + 1i32) as isize)).b32.s1 = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 85i32
                + 256i32
                + (0x10ffffi32 + 1i32)) as isize,
        ))
        .b32
        .s1;
        if (cur_list.mode as i32).abs() == 104i32 {
            cur_list.aux.b32.s0 = 1000i32
        } else {
            q = new_noad();
            (*mem.offset((q + 1i32) as isize)).b32.s1 = 2i32;
            (*mem.offset((q + 1i32) as isize)).b32.s0 = p;
            p = q
        }
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
    };
}
#[no_mangle]
pub unsafe extern "C" fn head_for_vmode() {
    if (cur_list.mode as i32) < 0i32 {
        if cur_cmd as i32 != 36i32 {
            off_save();
        } else {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"You can\'t use `\x00" as *const u8 as *const i8);
            print_esc_cstr(b"hrule\x00" as *const u8 as *const i8);
            print_cstr(b"\' here except with leaders\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] = b"To put a horizontal rule in an hbox or an alignment,\x00" as *const u8
                as *const i8;
            help_line[0] = b"you should use \\leaders or \\hrulefill (see The TeXbook).\x00"
                as *const u8 as *const i8;
            error();
        }
    } else {
        back_input();
        cur_tok = par_token;
        back_input();
        cur_input.index = 5_u16
    };
}
#[no_mangle]
pub unsafe extern "C" fn end_graf() {
    if cur_list.mode as i32 == 104i32 {
        if cur_list.head == cur_list.tail {
            pop_nest();
        } else {
            line_break(false);
        }
        if cur_list.eTeX_aux != -0xfffffffi32 {
            flush_list(cur_list.eTeX_aux);
            cur_list.eTeX_aux = -0xfffffffi32
        }
        normal_paragraph();
        error_count = 0_i8
    };
}
#[no_mangle]
pub unsafe extern "C" fn begin_insert_or_adjust() {
    if cur_cmd as i32 == 38i32 {
        cur_val = 255i32
    } else {
        scan_eight_bit_int();
        if cur_val == 255i32 {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"You can\'t \x00" as *const u8 as *const i8);
            print_esc_cstr(b"insert\x00" as *const u8 as *const i8);
            print_int(255i32);
            help_ptr = 1_u8;
            help_line[0] =
                b"I\'m changing to \\insert0; box 255 is special.\x00" as *const u8 as *const i8;
            error();
            cur_val = 0i32
        }
    }
    (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 = cur_val;
    if cur_cmd as i32 == 38i32 && scan_keyword(b"pre\x00" as *const u8 as *const i8) as i32 != 0 {
        (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1 = 1i32
    } else {
        (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1 = 0i32
    }
    save_ptr = save_ptr + 2i32;
    new_save_level(11i32 as group_code);
    scan_left_brace();
    normal_paragraph();
    push_nest();
    cur_list.mode = -1_i16;
    cur_list.aux.b32.s1 = -65536000i32;
}
#[no_mangle]
pub unsafe extern "C" fn make_mark() {
    let mut p: i32 = 0;
    let mut c: i32 = 0;
    if cur_chr == 0i32 {
        c = 0i32
    } else {
        scan_register_num();
        c = cur_val
    }
    p = scan_toks(false, true);
    p = get_node(2i32);
    (*mem.offset((p + 1i32) as isize)).b32.s0 = c;
    (*mem.offset(p as isize)).b16.s1 = 4_u16;
    (*mem.offset(p as isize)).b16.s0 = 0_u16;
    (*mem.offset((p + 1i32) as isize)).b32.s1 = def_ref;
    (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
    cur_list.tail = p;
}
#[no_mangle]
pub unsafe extern "C" fn append_penalty() {
    scan_int();
    (*mem.offset(cur_list.tail as isize)).b32.s1 = new_penalty(cur_val);
    cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
    if cur_list.mode as i32 == 1i32 {
        build_page();
    };
}
#[no_mangle]
pub unsafe extern "C" fn delete_last() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut fm: bool = false;
    let mut tx: i32 = 0;
    let mut m: u16 = 0;
    if cur_list.mode as i32 == 1i32 && cur_list.tail == cur_list.head {
        /*1141: */
        if cur_chr != 10i32 || last_glue != 0x3fffffffi32 {
            you_cant();
            help_ptr = 2_u8;
            help_line[1] = b"Sorry...I usually can\'t take things from the current page.\x00"
                as *const u8 as *const i8;
            help_line[0] = b"Try `I\\vskip-\\lastskip\' instead.\x00" as *const u8 as *const i8;
            if cur_chr == 11i32 {
                help_line[0] = b"Try `I\\kern-\\lastkern\' instead.\x00" as *const u8 as *const i8
            } else if cur_chr != 10i32 {
                help_line[0] =
                    b"Perhaps you can make the output routine do it.\x00" as *const u8 as *const i8
            }
            error();
        }
    } else {
        tx = cur_list.tail;
        if !is_char_node(tx) {
            if (*mem.offset(tx as isize)).b16.s1 as i32 == 9i32
                && (*mem.offset(tx as isize)).b16.s0 as i32 == 3i32
            {
                r = cur_list.head;
                loop {
                    q = r;
                    r = (*mem.offset(q as isize)).b32.s1;
                    if r == tx {
                        break;
                    }
                }
                tx = q
            }
        }
        if !is_char_node(tx) {
            if (*mem.offset(tx as isize)).b16.s1 as i32 == cur_chr {
                q = cur_list.head;
                p = -0xfffffffi32;
                loop {
                    r = p;
                    p = q;
                    fm = false;
                    if !is_char_node(q) {
                        if (*mem.offset(q as isize)).b16.s1 as i32 == 7i32 {
                            let mut for_end: i32 = 0;
                            m = 1_u16;
                            for_end = (*mem.offset(q as isize)).b16.s0 as i32;
                            if m as i32 <= for_end {
                                loop {
                                    p = (*mem.offset(p as isize)).b32.s1;
                                    let fresh77 = m;
                                    m = m.wrapping_add(1);
                                    if !((fresh77 as i32) < for_end) {
                                        break;
                                    }
                                }
                            }
                            if p == tx {
                                return;
                            }
                        } else if (*mem.offset(q as isize)).b16.s1 as i32 == 9i32
                            && (*mem.offset(q as isize)).b16.s0 as i32 == 2i32
                        {
                            fm = true
                        }
                    }
                    q = (*mem.offset(p as isize)).b32.s1;
                    if q == tx {
                        break;
                    }
                }
                q = (*mem.offset(tx as isize)).b32.s1;
                (*mem.offset(p as isize)).b32.s1 = q;
                (*mem.offset(tx as isize)).b32.s1 = -0xfffffffi32;
                if q == -0xfffffffi32 {
                    if fm {
                        confusion(b"tail1\x00" as *const u8 as *const i8);
                    } else {
                        cur_list.tail = p
                    }
                } else if fm {
                    cur_list.tail = r;
                    (*mem.offset(r as isize)).b32.s1 = -0xfffffffi32;
                    flush_node_list(p);
                }
                flush_node_list(tx);
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn unpackage() {
    let mut p: i32 = 0;
    let mut r: i32 = 0;
    let mut c: u8 = 0;
    if cur_chr > 1i32 {
        /*1651: */
        (*mem.offset(cur_list.tail as isize)).b32.s1 = disc_ptr[cur_chr as usize]; /*:1156 */
        disc_ptr[cur_chr as usize] = -0xfffffffi32
    } else {
        c = cur_chr as u8;
        scan_register_num();
        if cur_val < 256i32 {
            p = (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + cur_val) as isize,
            ))
            .b32
            .s1
        } else {
            find_sa_element(4i32 as small_number, cur_val, false);
            if cur_ptr == -0xfffffffi32 {
                p = -0xfffffffi32
            } else {
                p = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
            }
        }
        if p == -0xfffffffi32 {
            return;
        }
        if (cur_list.mode as i32).abs() == 207i32
            || (cur_list.mode as i32).abs() == 1i32
                && (*mem.offset(p as isize)).b16.s1 as i32 != 1i32
            || (cur_list.mode as i32).abs() == 104i32
                && (*mem.offset(p as isize)).b16.s1 as i32 != 0i32
        {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Incompatible list can\'t be unboxed\x00" as *const u8 as *const i8);
            help_ptr = 3_u8;
            help_line[2] = b"Sorry, Pandora. (You sneaky devil.)\x00" as *const u8 as *const i8;
            help_line[1] = b"I refuse to unbox an \\hbox in vertical mode or vice versa.\x00"
                as *const u8 as *const i8;
            help_line[0] =
                b"And I can\'t open any boxes in math mode.\x00" as *const u8 as *const i8;
            error();
            return;
        }
        if c as i32 == 1i32 {
            (*mem.offset(cur_list.tail as isize)).b32.s1 =
                copy_node_list((*mem.offset((p + 5i32) as isize)).b32.s1)
        } else {
            (*mem.offset(cur_list.tail as isize)).b32.s1 =
                (*mem.offset((p + 5i32) as isize)).b32.s1;
            if cur_val < 256i32 {
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1 = -0xfffffffi32
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr != -0xfffffffi32 {
                    (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1 = -0xfffffffi32;
                    let ref mut fresh78 = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s0;
                    *fresh78 += 1;
                    delete_sa_ref(cur_ptr);
                }
            }
            free_node(p, 8i32);
        }
    }
    while (*mem.offset(cur_list.tail as isize)).b32.s1 != -0xfffffffi32 {
        r = (*mem.offset(cur_list.tail as isize)).b32.s1;
        if !is_char_node(r) && (*mem.offset(r as isize)).b16.s1 as i32 == 40i32 {
            (*mem.offset(cur_list.tail as isize)).b32.s1 = (*mem.offset(r as isize)).b32.s1;
            free_node(r, 3i32);
        }
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
    }
}
#[no_mangle]
pub unsafe extern "C" fn append_italic_correction() {
    let mut p: i32 = 0;
    let mut f: internal_font_number = 0;
    if cur_list.tail != cur_list.head {
        if is_char_node(cur_list.tail) {
            p = cur_list.tail
        } else if (*mem.offset(cur_list.tail as isize)).b16.s1 as i32 == 6i32 {
            p = cur_list.tail + 1i32
        } else if (*mem.offset(cur_list.tail as isize)).b16.s1 as i32 == 8i32 {
            if (*mem.offset(cur_list.tail as isize)).b16.s0 as i32 == 40i32
                || (*mem.offset(cur_list.tail as isize)).b16.s0 as i32 == 41i32
            {
                (*mem.offset(cur_list.tail as isize)).b32.s1 = new_kern(
                    real_get_native_italic_correction(&mut *mem.offset(cur_list.tail as isize)
                        as *mut memory_word
                        as *mut libc::c_void),
                );
                cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                (*mem.offset(cur_list.tail as isize)).b16.s0 = 1_u16
            } else if (*mem.offset(cur_list.tail as isize)).b16.s0 as i32 == 42i32 {
                (*mem.offset(cur_list.tail as isize)).b32.s1 =
                    new_kern(real_get_native_glyph_italic_correction(
                        &mut *mem.offset(cur_list.tail as isize) as *mut memory_word
                            as *mut libc::c_void,
                    ));
                cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                (*mem.offset(cur_list.tail as isize)).b16.s0 = 1_u16
            }
            return;
        } else {
            return;
        }
        f = (*mem.offset(p as isize)).b16.s1 as internal_font_number;
        (*mem.offset(cur_list.tail as isize)).b32.s1 = new_kern(
            (*font_info.offset(
                (*italic_base.offset(f as isize)
                    + (*font_info.offset(
                        (*char_base.offset(f as isize)
                            + effective_char(1i32 != 0, f, (*mem.offset(p as isize)).b16.s0))
                            as isize,
                    ))
                    .b16
                    .s1 as i32
                        / 4i32) as isize,
            ))
            .b32
            .s1,
        );
        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
        (*mem.offset(cur_list.tail as isize)).b16.s0 = 1_u16
    };
}
#[no_mangle]
pub unsafe extern "C" fn append_discretionary() {
    let mut c: i32 = 0;
    (*mem.offset(cur_list.tail as isize)).b32.s1 = new_disc();
    cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
    if cur_chr == 1i32 {
        c = *hyphen_char.offset(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32) as isize,
            ))
            .b32
            .s1 as isize,
        );
        if c >= 0i32 {
            if c <= 0xffffi32 {
                (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s0 = new_character(
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32) as isize,
                    ))
                    .b32
                    .s1,
                    c as UTF16_code,
                )
            }
        }
    } else {
        save_ptr += 1;
        (*save_stack.offset((save_ptr - 1i32) as isize)).b32.s1 = 0i32;
        new_save_level(10i32 as group_code);
        scan_left_brace();
        push_nest();
        cur_list.mode = -104_i16;
        cur_list.aux.b32.s0 = 1000i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn build_discretionary() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut n: i32 = 0;
    unsave();
    q = cur_list.head;
    p = (*mem.offset(q as isize)).b32.s1;
    n = 0i32;
    while p != -0xfffffffi32 {
        if !is_char_node(p) {
            if (*mem.offset(p as isize)).b16.s1 as i32 > 2i32 {
                if (*mem.offset(p as isize)).b16.s1 as i32 != 11i32 {
                    if (*mem.offset(p as isize)).b16.s1 as i32 != 6i32 {
                        if (*mem.offset(p as isize)).b16.s1 as i32 != 8i32
                            || (*mem.offset(p as isize)).b16.s0 as i32 != 40i32
                                && (*mem.offset(p as isize)).b16.s0 as i32 != 41i32
                                && (*mem.offset(p as isize)).b16.s0 as i32 != 42i32
                        {
                            if file_line_error_style_p != 0 {
                                print_file_line();
                            } else {
                                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                            }
                            print_cstr(
                                b"Improper discretionary list\x00" as *const u8 as *const i8,
                            );
                            help_ptr = 1_u8;
                            help_line[0] =
                                b"Discretionary lists must contain only boxes and kerns.\x00"
                                    as *const u8 as *const i8;
                            error();
                            begin_diagnostic();
                            print_nl_cstr(
                                b"The following discretionary sublist has been deleted:\x00"
                                    as *const u8 as *const i8,
                            );
                            show_box(p);
                            end_diagnostic(1i32 != 0);
                            flush_node_list(p);
                            (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
                            break;
                        }
                    }
                }
            }
        }
        q = p;
        p = (*mem.offset(q as isize)).b32.s1;
        n += 1
    }
    p = (*mem.offset(cur_list.head as isize)).b32.s1;
    pop_nest();
    match (*save_stack.offset((save_ptr - 1i32) as isize)).b32.s1 {
        0 => (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s0 = p,
        1 => (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = p,
        2 => {
            if n > 0i32 && (cur_list.mode as i32).abs() == 207i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Illegal math \x00" as *const u8 as *const i8);
                print_esc_cstr(b"discretionary\x00" as *const u8 as *const i8);
                help_ptr = 2_u8;
                help_line[1] = b"Sorry: The third part of a discretionary break must be\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"empty, in math formulas. I had to delete your third part.\x00"
                    as *const u8 as *const i8;
                flush_node_list(p);
                n = 0i32;
                error();
            } else {
                (*mem.offset(cur_list.tail as isize)).b32.s1 = p
            }
            if n <= 65535i32 {
                (*mem.offset(cur_list.tail as isize)).b16.s0 = n as u16
            } else {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Discretionary list is too long\x00" as *const u8 as *const i8);
                help_ptr = 2_u8;
                help_line[1] = b"Wow---I never thought anybody would tweak me here.\x00"
                    as *const u8 as *const i8;
                help_line[0] = b"You can\'t seriously need such a huge discretionary list?\x00"
                    as *const u8 as *const i8;
                error();
            }
            if n > 0i32 {
                cur_list.tail = q
            }
            save_ptr -= 1;
            return;
        }
        _ => {}
    }
    let ref mut fresh79 = (*save_stack.offset((save_ptr - 1i32) as isize)).b32.s1;
    *fresh79 += 1;
    new_save_level(10i32 as group_code);
    scan_left_brace();
    push_nest();
    cur_list.mode = -104_i16;
    cur_list.aux.b32.s0 = 1000i32;
}
#[no_mangle]
pub unsafe extern "C" fn make_accent() {
    let mut s: f64 = 0.;
    let mut t: f64 = 0.;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut f: internal_font_number = 0;
    let mut a: scaled_t = 0;
    let mut h: scaled_t = 0;
    let mut x: scaled_t = 0;
    let mut w: scaled_t = 0;
    let mut delta: scaled_t = 0;
    let mut lsb: scaled_t = 0;
    let mut rsb: scaled_t = 0;
    let mut i: b16x4 = b16x4 {
        s0: 0,
        s1: 0,
        s2: 0,
        s3: 0,
    };
    scan_char_num();
    f = (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32) as isize,
    ))
    .b32
    .s1;
    p = new_character(f, cur_val as UTF16_code);
    if p != -0xfffffffi32 {
        x = (*font_info.offset((5i32 + *param_base.offset(f as isize)) as isize))
            .b32
            .s1;
        s = (*font_info.offset((1i32 + *param_base.offset(f as isize)) as isize))
            .b32
            .s1 as f64
            / 65536.0f64;
        if font_area[f as usize] as u32 == 0xffffu32
            || font_area[f as usize] as u32 == 0xfffeu32
        {
            a = (*mem.offset((p + 1i32) as isize)).b32.s1;
            if a == 0i32 {
                get_native_char_sidebearings(f, cur_val, &mut lsb, &mut rsb);
            }
        } else {
            a = (*font_info.offset(
                (*width_base.offset(f as isize)
                    + (*font_info.offset(
                        (*char_base.offset(f as isize)
                            + effective_char(1i32 != 0, f, (*mem.offset(p as isize)).b16.s0))
                            as isize,
                    ))
                    .b16
                    .s3 as i32) as isize,
            ))
            .b32
            .s1
        }
        do_assignments();
        q = -0xfffffffi32;
        f = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32) as isize,
        ))
        .b32
        .s1;
        if cur_cmd as i32 == 11i32 || cur_cmd as i32 == 12i32 || cur_cmd as i32 == 68i32 {
            q = new_character(f, cur_chr as UTF16_code);
            cur_val = cur_chr
        } else if cur_cmd as i32 == 16i32 {
            scan_char_num();
            q = new_character(f, cur_val as UTF16_code)
        } else {
            back_input();
        }
        if q != -0xfffffffi32 {
            /*1160: */
            t = (*font_info.offset((1i32 + *param_base.offset(f as isize)) as isize))
                .b32
                .s1 as f64
                / 65536.0f64;
            if font_area[f as usize] as u32 == 0xffffu32
                || font_area[f as usize] as u32 == 0xfffeu32
            {
                w = (*mem.offset((q + 1i32) as isize)).b32.s1;
                get_native_char_height_depth(f, cur_val, &mut h, &mut delta);
            } else {
                i = (*font_info.offset(
                    (*char_base.offset(f as isize)
                        + effective_char(1i32 != 0, f, (*mem.offset(q as isize)).b16.s0))
                        as isize,
                ))
                .b16;
                w = (*font_info.offset((*width_base.offset(f as isize) + i.s3 as i32) as isize))
                    .b32
                    .s1;
                h = (*font_info
                    .offset((*height_base.offset(f as isize) + i.s2 as i32 / 16i32) as isize))
                .b32
                .s1
            }
            if h != x {
                p = hpack(p, 0i32, 1i32 as small_number);
                (*mem.offset((p + 4i32) as isize)).b32.s1 = x - h
            }
            if (font_area[f as usize] as u32 == 0xffffu32
                || font_area[f as usize] as u32 == 0xfffeu32)
                && a == 0i32
            {
                delta = tex_round((w - lsb + rsb) as f64 / 2.0f64 + h as f64 * t - x as f64 * s)
            } else {
                delta = tex_round((w - a) as f64 / 2.0f64 + h as f64 * t - x as f64 * s)
            }
            r = new_kern(delta);
            (*mem.offset(r as isize)).b16.s0 = 2_u16;
            (*mem.offset(cur_list.tail as isize)).b32.s1 = r;
            (*mem.offset(r as isize)).b32.s1 = p;
            cur_list.tail = new_kern(-a - delta);
            (*mem.offset(cur_list.tail as isize)).b16.s0 = 2_u16;
            (*mem.offset(p as isize)).b32.s1 = cur_list.tail;
            p = q
        }
        (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
        cur_list.tail = p;
        cur_list.aux.b32.s0 = 1000i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn align_error() {
    if align_state.abs() > 2i32 {
        /*1163: */
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Misplaced \x00" as *const u8 as *const i8);
        print_cmd_chr(cur_cmd as u16, cur_chr);
        if cur_tok == 0x800000i32 + 38i32 {
            help_ptr = 6_u8;
            help_line[5] = b"I can\'t figure out why you would want to use a tab mark\x00"
                as *const u8 as *const i8;
            help_line[4] =
                b"here. If you just want an ampersand, the remedy is\x00" as *const u8 as *const i8;
            help_line[3] = b"simple: Just type `I\\&\' now. But if some right brace\x00"
                as *const u8 as *const i8;
            help_line[2] = b"up above has ended a previous alignment prematurely,\x00" as *const u8
                as *const i8;
            help_line[1] = b"you\'re probably due for more error messages, and you\x00" as *const u8
                as *const i8;
            help_line[0] = b"might try typing `S\' now just to see what is salvageable.\x00"
                as *const u8 as *const i8
        } else {
            help_ptr = 5_u8;
            help_line[4] = b"I can\'t figure out why you would want to use a tab mark\x00"
                as *const u8 as *const i8;
            help_line[3] = b"or \\cr or \\span just now. If something like a right brace\x00"
                as *const u8 as *const i8;
            help_line[2] = b"up above has ended a previous alignment prematurely,\x00" as *const u8
                as *const i8;
            help_line[1] = b"you\'re probably due for more error messages, and you\x00" as *const u8
                as *const i8;
            help_line[0] = b"might try typing `S\' now just to see what is salvageable.\x00"
                as *const u8 as *const i8
        }
        error();
    } else {
        back_input();
        if align_state < 0i32 {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Missing { inserted\x00" as *const u8 as *const i8);
            align_state += 1;
            cur_tok = 0x200000i32 + 123i32
        } else {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Missing } inserted\x00" as *const u8 as *const i8);
            align_state -= 1;
            cur_tok = 0x400000i32 + 125i32
        }
        help_ptr = 3_u8;
        help_line[2] =
            b"I\'ve put in what seems to be necessary to fix\x00" as *const u8 as *const i8;
        help_line[1] =
            b"the current column of the current alignment.\x00" as *const u8 as *const i8;
        help_line[0] = b"Try to go on, since this might almost work.\x00" as *const u8 as *const i8;
        ins_error();
    };
}
#[no_mangle]
pub unsafe extern "C" fn no_align_error() {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Misplaced \x00" as *const u8 as *const i8);
    print_esc_cstr(b"noalign\x00" as *const u8 as *const i8);
    help_ptr = 2_u8;
    help_line[1] =
        b"I expect to see \\noalign only after the \\cr of\x00" as *const u8 as *const i8;
    help_line[0] =
        b"an alignment. Proceed, and I\'ll ignore this case.\x00" as *const u8 as *const i8;
    error();
}
#[no_mangle]
pub unsafe extern "C" fn omit_error() {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Misplaced \x00" as *const u8 as *const i8);
    print_esc_cstr(b"omit\x00" as *const u8 as *const i8);
    help_ptr = 2_u8;
    help_line[1] =
        b"I expect to see \\omit only after tab marks or the \\cr of\x00" as *const u8 as *const i8;
    help_line[0] =
        b"an alignment. Proceed, and I\'ll ignore this case.\x00" as *const u8 as *const i8;
    error();
}
#[no_mangle]
pub unsafe extern "C" fn do_endv() {
    base_ptr = input_ptr;
    *input_stack.offset(base_ptr as isize) = cur_input;
    while (*input_stack.offset(base_ptr as isize)).index as i32 != 2i32
        && (*input_stack.offset(base_ptr as isize)).loc == -0xfffffffi32
        && (*input_stack.offset(base_ptr as isize)).state as i32 == 0i32
    {
        base_ptr -= 1
    }
    if (*input_stack.offset(base_ptr as isize)).index as i32 != 2i32
        || (*input_stack.offset(base_ptr as isize)).loc != -0xfffffffi32
        || (*input_stack.offset(base_ptr as isize)).state as i32 != 0i32
    {
        fatal_error(
            b"(interwoven alignment preambles are not allowed)\x00" as *const u8 as *const i8,
        );
    }
    if cur_group as i32 == 6i32 {
        end_graf();
        if fin_col() {
            fin_row();
        }
    } else {
        off_save();
    };
}
#[no_mangle]
pub unsafe extern "C" fn cs_error() {
    if file_line_error_style_p != 0 {
        print_file_line();
    } else {
        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
    }
    print_cstr(b"Extra \x00" as *const u8 as *const i8);
    print_esc_cstr(b"endcsname\x00" as *const u8 as *const i8);
    help_ptr = 1_u8;
    help_line[0] =
        b"I\'m ignoring this, since I wasn\'t doing a \\csname.\x00" as *const u8 as *const i8;
    error();
}
#[no_mangle]
pub unsafe extern "C" fn push_math(mut c: group_code) {
    push_nest();
    cur_list.mode = -207_i16;
    cur_list.aux.b32.s1 = -0xfffffffi32;
    new_save_level(c);
}
#[no_mangle]
pub unsafe extern "C" fn just_copy(mut p: i32, mut h: i32, mut t: i32) {
    let mut r: i32 = 0;
    let mut words: u8 = 0;
    while p != -0xfffffffi32 {
        let mut current_block_50: u64;
        words = 1_u8;
        if is_char_node(p) {
            r = get_avail();
            current_block_50 = 2500484646272006982;
        } else {
            match (*mem.offset(p as isize)).b16.s1 as i32 {
                0 | 1 => {
                    r = get_node(8i32);
                    (*mem.offset((r + 8i32 - 1i32) as isize)).b32.s0 =
                        (*mem.offset((p + 8i32 - 1i32) as isize)).b32.s0;
                    (*mem.offset((r + 8i32 - 1i32) as isize)).b32.s1 =
                        (*mem.offset((p + 8i32 - 1i32) as isize)).b32.s1;
                    *mem.offset((r + 6i32) as isize) = *mem.offset((p + 6i32) as isize);
                    *mem.offset((r + 5i32) as isize) = *mem.offset((p + 5i32) as isize);
                    words = 5_u8;
                    (*mem.offset((r + 5i32) as isize)).b32.s1 = -0xfffffffi32;
                    current_block_50 = 2500484646272006982;
                }
                2 => {
                    r = get_node(5i32);
                    words = 5_u8;
                    current_block_50 = 2500484646272006982;
                }
                6 => {
                    r = get_avail();
                    *mem.offset(r as isize) = *mem.offset((p + 1i32) as isize);
                    current_block_50 = 1668590571950580537;
                }
                11 | 9 => {
                    words = 3_u8;
                    r = get_node(words as i32);
                    current_block_50 = 2500484646272006982;
                }
                10 => {
                    r = get_node(3i32);
                    let ref mut fresh80 = (*mem
                        .offset((*mem.offset((p + 1i32) as isize)).b32.s0 as isize))
                    .b32
                    .s1;
                    *fresh80 += 1;
                    (*mem.offset((r + 3i32 - 1i32) as isize)).b32.s0 =
                        (*mem.offset((p + 3i32 - 1i32) as isize)).b32.s0;
                    (*mem.offset((r + 3i32 - 1i32) as isize)).b32.s1 =
                        (*mem.offset((p + 3i32 - 1i32) as isize)).b32.s1;
                    (*mem.offset((r + 1i32) as isize)).b32.s0 =
                        (*mem.offset((p + 1i32) as isize)).b32.s0;
                    (*mem.offset((r + 1i32) as isize)).b32.s1 = -0xfffffffi32;
                    current_block_50 = 2500484646272006982;
                }
                8 => {
                    match (*mem.offset(p as isize)).b16.s0 as i32 {
                        0 => {
                            r = get_node(3i32);
                            words = 3_u8
                        }
                        1 | 3 => {
                            r = get_node(2i32);
                            let ref mut fresh81 = (*mem
                                .offset((*mem.offset((p + 1i32) as isize)).b32.s1 as isize))
                            .b32
                            .s0;
                            *fresh81 += 1;
                            words = 2_u8
                        }
                        2 | 4 => {
                            r = get_node(2i32);
                            words = 2_u8
                        }
                        40 | 41 => {
                            words = (*mem.offset((p + 4i32) as isize)).b16.s3 as u8;
                            r = get_node(words as i32);
                            while words as i32 > 0i32 {
                                words = words.wrapping_sub(1);
                                *mem.offset((r + words as i32) as isize) =
                                    *mem.offset((p + words as i32) as isize)
                            }
                            let ref mut fresh82 = (*mem.offset((r + 5i32) as isize)).ptr;
                            *fresh82 = 0 as *mut libc::c_void;
                            (*mem.offset((r + 4i32) as isize)).b16.s0 = 0_u16;
                            copy_native_glyph_info(p, r);
                        }
                        42 => {
                            r = get_node(5i32);
                            words = 5_u8
                        }
                        43 | 44 => {
                            words = (9i32 as u64).wrapping_add(
                                ((*mem.offset((p + 4i32) as isize)).b16.s1 as u64)
                                    .wrapping_add(::std::mem::size_of::<memory_word>() as u64)
                                    .wrapping_sub(1i32 as u64)
                                    .wrapping_div(::std::mem::size_of::<memory_word>() as u64),
                            ) as u8;
                            r = get_node(words as i32)
                        }
                        6 => r = get_node(2i32),
                        _ => {
                            confusion(b"ext2\x00" as *const u8 as *const i8);
                        }
                    }
                    current_block_50 = 2500484646272006982;
                }
                _ => {
                    current_block_50 = 17768496421797376910;
                }
            }
        }
        match current_block_50 {
            2500484646272006982 => {
                while words as i32 > 0i32 {
                    words = words.wrapping_sub(1);
                    *mem.offset((r + words as i32) as isize) =
                        *mem.offset((p + words as i32) as isize)
                }
                current_block_50 = 1668590571950580537;
            }
            _ => {}
        }
        match current_block_50 {
            1668590571950580537 => {
                (*mem.offset(h as isize)).b32.s1 = r;
                h = r
            }
            _ => {}
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
    (*mem.offset(h as isize)).b32.s1 = t;
}
#[no_mangle]
pub unsafe extern "C" fn just_reverse(mut p: i32) {
    let mut l: i32 = 0;
    let mut t: i32 = 0;
    let mut q: i32 = 0;
    let mut m: i32 = 0;
    let mut n: i32 = 0;
    m = -0xfffffffi32;
    n = -0xfffffffi32;
    if (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 == -0xfffffffi32 {
        just_copy(
            (*mem.offset(p as isize)).b32.s1,
            4999999i32 - 3i32,
            -0xfffffffi32,
        );
        q = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1
    } else {
        q = (*mem.offset(p as isize)).b32.s1;
        (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32;
        flush_node_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1);
    }
    t = new_edge(cur_dir, 0i32);
    l = t;
    cur_dir = (1i32 - cur_dir as i32) as small_number;
    while q != -0xfffffffi32 {
        if is_char_node(q) {
            loop {
                p = q;
                q = (*mem.offset(p as isize)).b32.s1;
                (*mem.offset(p as isize)).b32.s1 = l;
                l = p;
                if !is_char_node(q) {
                    break;
                }
            }
        } else {
            p = q;
            q = (*mem.offset(p as isize)).b32.s1;
            if (*mem.offset(p as isize)).b16.s1 as i32 == 9i32 {
                /*1527: */
                if (*mem.offset(p as isize)).b16.s0 as i32 & 1i32 != 0 {
                    if (*mem.offset(LR_ptr as isize)).b32.s0
                        != 4i32 * ((*mem.offset(p as isize)).b16.s0 as i32 / 4i32) + 3i32
                    {
                        (*mem.offset(p as isize)).b16.s1 = 11_u16;
                        LR_problems += 1
                    } else {
                        temp_ptr = LR_ptr;
                        LR_ptr = (*mem.offset(temp_ptr as isize)).b32.s1;
                        (*mem.offset(temp_ptr as isize)).b32.s1 = avail;
                        avail = temp_ptr;
                        if n > -0xfffffffi32 {
                            n -= 1;
                            let ref mut fresh83 = (*mem.offset(p as isize)).b16.s0;
                            *fresh83 = (*fresh83).wrapping_sub(1)
                        } else if m > -0xfffffffi32 {
                            m -= 1;
                            (*mem.offset(p as isize)).b16.s1 = 11_u16
                        } else {
                            (*mem.offset((t + 1i32) as isize)).b32.s1 =
                                (*mem.offset((p + 1i32) as isize)).b32.s1;
                            (*mem.offset(t as isize)).b32.s1 = q;
                            free_node(p, 3i32);
                            break;
                        }
                    }
                } else {
                    temp_ptr = get_avail();
                    (*mem.offset(temp_ptr as isize)).b32.s0 =
                        4i32 * ((*mem.offset(p as isize)).b16.s0 as i32 / 4i32) + 3i32;
                    (*mem.offset(temp_ptr as isize)).b32.s1 = LR_ptr;
                    LR_ptr = temp_ptr;
                    if n > -0xfffffffi32
                        || (*mem.offset(p as isize)).b16.s0 as i32 / 8i32 != cur_dir as i32
                    {
                        n += 1;
                        let ref mut fresh84 = (*mem.offset(p as isize)).b16.s0;
                        *fresh84 = (*fresh84).wrapping_add(1)
                    } else {
                        (*mem.offset(p as isize)).b16.s1 = 11_u16;
                        m += 1
                    }
                }
            }
            (*mem.offset(p as isize)).b32.s1 = l;
            l = p
        }
    }
    (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 = l;
}
#[no_mangle]
pub unsafe extern "C" fn get_r_token() {
    loop {
        loop {
            get_token();
            if !(cur_tok == 0x1400020i32) {
                break;
            }
        }
        if !(cur_cs == 0i32
            || cur_cs > eqtb_top
            || cur_cs > 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32
                && cur_cs
                    <= 1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 85i32
                        + 256i32
                        + (0x10ffffi32 + 1i32)
                        + 23i32
                        + 256i32
                        - 1i32)
        {
            break;
        }
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Missing control sequence inserted\x00" as *const u8 as *const i8);
        help_ptr = 5_u8;
        help_line[4] = b"Please don\'t say `\\def cs{...}\', say `\\def\\cs{...}\'.\x00"
            as *const u8 as *const i8;
        help_line[3] = b"I\'ve inserted an inaccessible control sequence so that your\x00"
            as *const u8 as *const i8;
        help_line[2] = b"definition will be completed without mixing me up too badly.\x00"
            as *const u8 as *const i8;
        help_line[1] =
            b"You can recover graciously from this error, if you\'re\x00" as *const u8 as *const i8;
        help_line[0] = b"careful; see exercise 27.2 in The TeXbook.\x00" as *const u8 as *const i8;
        if cur_cs == 0i32 {
            back_input();
        }
        cur_tok = 0x1ffffffi32
            + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 0i32);
        ins_error();
    }
}
#[no_mangle]
pub unsafe extern "C" fn trap_zero_glue() {
    if (*mem.offset((cur_val + 1i32) as isize)).b32.s1 == 0i32
        && (*mem.offset((cur_val + 2i32) as isize)).b32.s1 == 0i32
        && (*mem.offset((cur_val + 3i32) as isize)).b32.s1 == 0i32
    {
        let ref mut fresh85 = (*mem.offset(0)).b32.s1;
        *fresh85 += 1;
        delete_glue_ref(cur_val);
        cur_val = 0i32
    };
}
#[no_mangle]
pub unsafe extern "C" fn do_register_command(mut a: small_number) {
    let mut current_block: u64;
    let mut l: i32 = -0xfffffffi32;
    let mut q: i32 = 0;
    let mut r: i32 = 0;
    let mut s: i32 = -0xfffffffi32;
    let mut p: u8 = 0;
    let mut e: bool = false;
    let mut w: i32 = 0i32;
    q = cur_cmd as i32;
    e = false;
    if q != 91i32 {
        get_x_token();
        if cur_cmd as i32 >= 74i32 && cur_cmd as i32 <= 77i32 {
            l = cur_chr;
            p = (cur_cmd as i32 - 74i32) as u8;
            current_block = 16534065480145571271;
        } else {
            if cur_cmd as i32 != 91i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"You can\'t use `\x00" as *const u8 as *const i8);
                print_cmd_chr(cur_cmd as u16, cur_chr);
                print_cstr(b"\' after \x00" as *const u8 as *const i8);
                print_cmd_chr(q as u16, 0i32);
                help_ptr = 1_u8;
                help_line[0] = b"I\'m forgetting what you said and not changing anything.\x00"
                    as *const u8 as *const i8;
                error();
                return;
            }
            current_block = 4808432441040389987;
        }
    } else {
        current_block = 4808432441040389987;
    }
    match current_block {
        4808432441040389987 => {
            if cur_chr < 0i32 || cur_chr > 19i32 {
                /*lo_mem_stat_max*/
                l = cur_chr;
                p = ((*mem.offset(l as isize)).b16.s1 as i32 / 64i32) as u8;
                e = true
            } else {
                p = cur_chr as u8;
                scan_register_num();
                if cur_val > 255i32 {
                    find_sa_element(p as small_number, cur_val, true);
                    l = cur_ptr;
                    e = true
                } else {
                    match p as i32 {
                        0 => {
                            l = cur_val
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 85i32)
                        }
                        1 => {
                            l = cur_val
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 85i32
                                    + 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + 23i32)
                        }
                        2 => {
                            l = cur_val
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32)
                        }
                        3 => {
                            l = cur_val
                                + (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32)
                        }
                        _ => {}
                    }
                }
            }
        }
        _ => {}
    }
    if (p as i32) < 2i32 {
        if e {
            w = (*mem.offset((l + 2i32) as isize)).b32.s1
        } else {
            w = (*eqtb.offset(l as isize)).b32.s1
        }
    } else if e {
        s = (*mem.offset((l + 1i32) as isize)).b32.s1
    } else {
        s = (*eqtb.offset(l as isize)).b32.s1
        /*:1272*/
    } /*1275:*/
    if q == 91i32 {
        scan_optional_equals();
    } else {
        scan_keyword(b"by\x00" as *const u8 as *const i8);
    }
    arith_error = false;
    if q < 93i32 {
        /*1273:*/
        if (p as i32) < 2i32 {
            if p as i32 == 0i32 {
                scan_int();
            } else {
                scan_dimen(false, false, false);
            }
            if q == 92i32 {
                cur_val = cur_val + w
            }
        } else {
            scan_glue(p as small_number);
            if q == 92i32 {
                /*1274:*/
                q = new_spec(cur_val);
                r = s;
                delete_glue_ref(cur_val);
                (*mem.offset((q + 1i32) as isize)).b32.s1 =
                    (*mem.offset((q + 1i32) as isize)).b32.s1
                        + (*mem.offset((r + 1i32) as isize)).b32.s1;
                if (*mem.offset((q + 2i32) as isize)).b32.s1 == 0i32 {
                    (*mem.offset(q as isize)).b16.s1 = 0_u16
                }
                if (*mem.offset(q as isize)).b16.s1 as i32
                    == (*mem.offset(r as isize)).b16.s1 as i32
                {
                    (*mem.offset((q + 2i32) as isize)).b32.s1 =
                        (*mem.offset((q + 2i32) as isize)).b32.s1
                            + (*mem.offset((r + 2i32) as isize)).b32.s1
                } else if ((*mem.offset(q as isize)).b16.s1 as i32)
                    < (*mem.offset(r as isize)).b16.s1 as i32
                    && (*mem.offset((r + 2i32) as isize)).b32.s1 != 0i32
                {
                    (*mem.offset((q + 2i32) as isize)).b32.s1 =
                        (*mem.offset((r + 2i32) as isize)).b32.s1;
                    (*mem.offset(q as isize)).b16.s1 = (*mem.offset(r as isize)).b16.s1
                }
                if (*mem.offset((q + 3i32) as isize)).b32.s1 == 0i32 {
                    (*mem.offset(q as isize)).b16.s0 = 0_u16
                }
                if (*mem.offset(q as isize)).b16.s0 as i32
                    == (*mem.offset(r as isize)).b16.s0 as i32
                {
                    (*mem.offset((q + 3i32) as isize)).b32.s1 =
                        (*mem.offset((q + 3i32) as isize)).b32.s1
                            + (*mem.offset((r + 3i32) as isize)).b32.s1
                } else if ((*mem.offset(q as isize)).b16.s0 as i32)
                    < (*mem.offset(r as isize)).b16.s0 as i32
                    && (*mem.offset((r + 3i32) as isize)).b32.s1 != 0i32
                {
                    (*mem.offset((q + 3i32) as isize)).b32.s1 =
                        (*mem.offset((r + 3i32) as isize)).b32.s1;
                    (*mem.offset(q as isize)).b16.s0 = (*mem.offset(r as isize)).b16.s0
                }
                cur_val = q
            }
        }
    } else {
        scan_int();
        if (p as i32) < 2i32 {
            if q == 93i32 {
                if p as i32 == 0i32 {
                    cur_val = mult_and_add(w, cur_val, 0i32, 0x7fffffffi32)
                } else {
                    cur_val = mult_and_add(w, cur_val, 0i32, 0x3fffffffi32)
                }
            } else {
                cur_val = x_over_n(w, cur_val)
            }
        } else {
            r = new_spec(s);
            if q == 93i32 {
                (*mem.offset((r + 1i32) as isize)).b32.s1 = mult_and_add(
                    (*mem.offset((s + 1i32) as isize)).b32.s1,
                    cur_val,
                    0i32,
                    0x3fffffffi32,
                );
                (*mem.offset((r + 2i32) as isize)).b32.s1 = mult_and_add(
                    (*mem.offset((s + 2i32) as isize)).b32.s1,
                    cur_val,
                    0i32,
                    0x3fffffffi32,
                );
                (*mem.offset((r + 3i32) as isize)).b32.s1 = mult_and_add(
                    (*mem.offset((s + 3i32) as isize)).b32.s1,
                    cur_val,
                    0i32,
                    0x3fffffffi32,
                )
            } else {
                (*mem.offset((r + 1i32) as isize)).b32.s1 =
                    x_over_n((*mem.offset((s + 1i32) as isize)).b32.s1, cur_val);
                (*mem.offset((r + 2i32) as isize)).b32.s1 =
                    x_over_n((*mem.offset((s + 2i32) as isize)).b32.s1, cur_val);
                (*mem.offset((r + 3i32) as isize)).b32.s1 =
                    x_over_n((*mem.offset((s + 3i32) as isize)).b32.s1, cur_val)
            }
            cur_val = r
        }
    }
    if arith_error {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Arithmetic overflow\x00" as *const u8 as *const i8);
        help_ptr = 2_u8;
        help_line[1] =
            b"I can\'t carry out that multiplication or division,\x00" as *const u8 as *const i8;
        help_line[0] = b"since the result is out of range.\x00" as *const u8 as *const i8;
        if p as i32 >= 2i32 {
            delete_glue_ref(cur_val);
        }
        error();
        return;
    }
    if (p as i32) < 2i32 {
        if e {
            if a as i32 >= 4i32 {
                gsa_w_def(l, cur_val);
            } else {
                sa_w_def(l, cur_val);
            }
        } else if a as i32 >= 4i32 {
            geq_word_define(l, cur_val);
        } else {
            eq_word_define(l, cur_val);
        }
    } else {
        trap_zero_glue();
        if e {
            if a as i32 >= 4i32 {
                gsa_def(l, cur_val);
            } else {
                sa_def(l, cur_val);
            }
        } else if a as i32 >= 4i32 {
            geq_define(l, 119_u16, cur_val);
        } else {
            eq_define(l, 119_u16, cur_val);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn alter_aux() {
    let mut c: i32 = 0;
    if cur_chr != (cur_list.mode as i32).abs() {
        report_illegal_case();
    } else {
        c = cur_chr;
        scan_optional_equals();
        if c == 1i32 {
            scan_dimen(false, false, false);
            cur_list.aux.b32.s1 = cur_val
        } else {
            scan_int();
            if cur_val <= 0i32 || cur_val > 32767i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Bad space factor\x00" as *const u8 as *const i8);
                help_ptr = 1_u8;
                help_line[0] = b"I allow only values in the range 1..32767 here.\x00" as *const u8
                    as *const i8;
                int_error(cur_val);
            } else {
                cur_list.aux.b32.s0 = cur_val
            }
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn alter_prev_graf() {
    let mut p: i32 = 0;
    *nest.offset(nest_ptr as isize) = cur_list;
    p = nest_ptr;
    while ((*nest.offset(p as isize)).mode as i32).abs() != 1i32 {
        p -= 1
    }
    scan_optional_equals();
    scan_int();
    if cur_val < 0i32 {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"Bad \x00" as *const u8 as *const i8);
        print_esc_cstr(b"prevgraf\x00" as *const u8 as *const i8);
        help_ptr = 1_u8;
        help_line[0] = b"I allow only nonnegative values here.\x00" as *const u8 as *const i8;
        int_error(cur_val);
    } else {
        (*nest.offset(p as isize)).prev_graf = cur_val;
        cur_list = *nest.offset(nest_ptr as isize)
    };
}
#[no_mangle]
pub unsafe extern "C" fn alter_page_so_far() {
    let mut c: u8 = 0;
    c = cur_chr as u8;
    scan_optional_equals();
    scan_dimen(false, false, false);
    page_so_far[c as usize] = cur_val;
}
#[no_mangle]
pub unsafe extern "C" fn alter_integer() {
    let mut c: small_number = 0;
    c = cur_chr as small_number;
    scan_optional_equals();
    scan_int();
    if c as i32 == 0i32 {
        dead_cycles = cur_val
    } else if c as i32 == 2i32 {
        if cur_val < 0i32 || cur_val > 3i32 {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Bad interaction mode\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] =
                b"Modes are 0=batch, 1=nonstop, 2=scroll, and\x00" as *const u8 as *const i8;
            help_line[0] =
                b"3=errorstop. Proceed, and I\'ll ignore this case.\x00" as *const u8 as *const i8;
            int_error(cur_val);
        } else {
            cur_chr = cur_val;
            new_interaction();
        }
    } else {
        insert_penalties = cur_val
    };
}
#[no_mangle]
pub unsafe extern "C" fn alter_box_dimen() {
    let mut c: small_number = 0;
    let mut b: i32 = 0;
    c = cur_chr as small_number;
    scan_register_num();
    if cur_val < 256i32 {
        b = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + cur_val) as isize,
        ))
        .b32
        .s1
    } else {
        find_sa_element(4i32 as small_number, cur_val, false);
        if cur_ptr == -0xfffffffi32 {
            b = -0xfffffffi32
        } else {
            b = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
        }
    }
    scan_optional_equals();
    scan_dimen(false, false, false);
    if b != -0xfffffffi32 {
        (*mem.offset((b + c as i32) as isize)).b32.s1 = cur_val
    };
}
#[no_mangle]
pub unsafe extern "C" fn new_font(mut a: small_number) {
    let mut current_block: u64;
    let mut u: i32 = 0;
    let mut s: scaled_t = 0;
    let mut f: internal_font_number = 0;
    let mut t: str_number = 0;
    if job_name == 0i32 {
        open_log_file();
    }
    get_r_token();
    u = cur_cs;
    if u >= 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 {
        t = (*hash.offset(u as isize)).s1
    } else if u >= 1i32 + (0x10ffffi32 + 1i32) {
        if u == 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) {
            t = maketexstring(b"FONT\x00" as *const u8 as *const i8)
        } else {
            t = u - (1i32 + (0x10ffffi32 + 1i32))
        }
    } else {
        let old_setting_0 = selector;
        selector = Selector::NEW_STRING;
        print_cstr(b"FONT\x00" as *const u8 as *const i8);
        print(u - 1i32);
        selector = old_setting_0;
        if pool_ptr + 1i32 > pool_size {
            overflow(
                b"pool size\x00" as *const u8 as *const i8,
                pool_size - init_pool_ptr,
            );
        }
        t = make_string()
    }
    if a as i32 >= 4i32 {
        geq_define(u, 89_u16, 0i32);
    } else {
        eq_define(u, 89_u16, 0i32);
    }
    scan_optional_equals();
    scan_file_name();
    name_in_progress = true;
    if scan_keyword(b"at\x00" as *const u8 as *const i8) {
        /*1294: */
        scan_dimen(false, false, false); /*:1293 */
        s = cur_val; /*:79 */
        if s <= 0i32 || s >= 0x8000000i32 {
            if file_line_error_style_p != 0 {
                print_file_line(); /*1318: */
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Improper `at\' size (\x00" as *const u8 as *const i8);
            print_scaled(s);
            print_cstr(b"pt), replaced by 10pt\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] =
                b"I can only handle fonts at positive sizes that are\x00" as *const u8 as *const i8;
            help_line[0] = b"less than 2048pt, so I\'ve changed what you said to 10pt.\x00"
                as *const u8 as *const i8;
            error();
            s = (10i32 as i64 * 65536) as scaled_t
        }
    } else if scan_keyword(b"scaled\x00" as *const u8 as *const i8) {
        scan_int();
        s = -cur_val;
        if cur_val <= 0i32 || cur_val as i64 > 32768 {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(
                b"Illegal magnification has been changed to 1000\x00" as *const u8 as *const i8,
            );
            help_ptr = 1_u8;
            help_line[0] = b"The magnification ratio must be between 1 and 32768.\x00" as *const u8
                as *const i8;
            int_error(cur_val);
            s = -1000i32
        }
    } else {
        s = -1000i32
    }
    name_in_progress = false;
    let mut for_end: i32 = 0;
    f = 0i32 + 1i32;
    for_end = font_ptr;
    if f <= for_end {
        current_block = 17075014677070940716;
    } else {
        current_block = 6838274324784804404;
    }
    loop {
        match current_block {
            6838274324784804404 => {
                f = read_font_info(u, cur_name, cur_area, s);
                break;
            }
            _ => {
                if str_eq_str(*font_name.offset(f as isize), cur_name) as i32 != 0
                    && (length(cur_area) == 0i32
                        && (font_area[f as usize] as u32 == 0xffffu32
                            || font_area[f as usize] as u32 == 0xfffeu32)
                        || str_eq_str(font_area[f as usize], cur_area) as i32 != 0)
                {
                    if s > 0i32 {
                        if s == *font_size.offset(f as isize) {
                            break;
                        }
                    } else if *font_size.offset(f as isize)
                        == xn_over_d(*font_dsize.offset(f as isize), -s, 1000i32)
                    {
                        break;
                    }
                }
                append_str(cur_area);
                append_str(cur_name);
                append_str(cur_ext);
                if str_eq_str(*font_name.offset(f as isize), make_string()) {
                    str_ptr -= 1;
                    pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize);
                    if font_area[f as usize] as u32 == 0xffffu32
                        || font_area[f as usize] as u32 == 0xfffeu32
                    {
                        if s > 0i32 {
                            if s == *font_size.offset(f as isize) {
                                break;
                            }
                        } else if *font_size.offset(f as isize)
                            == xn_over_d(*font_dsize.offset(f as isize), -s, 1000i32)
                        {
                            break;
                        }
                    }
                } else {
                    str_ptr -= 1;
                    pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize)
                }
                let fresh86 = f;
                f = f + 1;
                if fresh86 < for_end {
                    current_block = 17075014677070940716;
                } else {
                    current_block = 6838274324784804404;
                }
            }
        }
    }
    if a as i32 >= 4i32 {
        geq_define(u, 89_u16, f);
    } else {
        eq_define(u, 89_u16, f);
    }
    *eqtb.offset(
        (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 12i32 + f) as isize,
    ) = *eqtb.offset(u as isize);
    (*hash.offset(
        (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 12i32 + f) as isize,
    ))
    .s1 = t;
}
#[no_mangle]
pub unsafe extern "C" fn new_interaction() {
    print_ln();
    interaction = cur_chr as u8;
    if interaction as i32 == 0i32 {
        selector = Selector::NO_PRINT
    } else {
        selector = Selector::TERM_ONLY
    }
    if log_opened {
        selector = (u8::from(selector)).wrapping_add(2).into()
    };
}
#[no_mangle]
pub unsafe extern "C" fn issue_message() {
    let mut c: u8 = 0;
    let mut s: str_number = 0;
    c = cur_chr as u8;
    (*mem.offset((4999999i32 - 12i32) as isize)).b32.s1 = scan_toks(false, true);
    let old_setting_0 = selector;
    selector = Selector::NEW_STRING;
    token_show(def_ref);
    selector = old_setting_0;
    flush_list(def_ref);
    if pool_ptr + 1i32 > pool_size {
        overflow(
            b"pool size\x00" as *const u8 as *const i8,
            pool_size - init_pool_ptr,
        );
    }
    s = make_string();
    if c as i32 == 0i32 {
        /*1315: */
        if term_offset + length(s) > max_print_line - 2i32 {
            print_ln();
        } else if term_offset > 0i32 || file_offset > 0i32 {
            print_char(' ' as i32);
        }
        print(s);
        rust_stdout.as_mut().unwrap().flush().unwrap();
    } else {
        if file_line_error_style_p != 0 {
            print_file_line();
        } else {
            print_nl_cstr(b"! \x00" as *const u8 as *const i8);
        }
        print_cstr(b"\x00" as *const u8 as *const i8);
        print(s);
        if (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 9i32) as isize,
        ))
        .b32
        .s1 != -0xfffffffi32
        {
            use_err_help = true
        } else if long_help_seen {
            help_ptr = 1_u8;
            help_line[0] = b"(That was another \\errmessage.)\x00" as *const u8 as *const i8
        } else {
            if (interaction as i32) < 3i32 {
                long_help_seen = true
            }
            help_ptr = 4_u8;
            help_line[3] = b"This error message was generated by an \\errmessage\x00" as *const u8
                as *const i8;
            help_line[2] =
                b"command, so I can\'t give any explicit help.\x00" as *const u8 as *const i8;
            help_line[1] = b"Pretend that you\'re Hercule Poirot: Examine all clues,\x00"
                as *const u8 as *const i8;
            help_line[0] =
                b"and deduce the truth by order and method.\x00" as *const u8 as *const i8
        }
        error();
        use_err_help = false
    }
    str_ptr -= 1;
    pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize);
}
#[no_mangle]
pub unsafe extern "C" fn shift_case() {
    let mut b: i32 = 0;
    let mut p: i32 = 0;
    let mut t: i32 = 0;
    let mut c: i32 = 0;
    b = cur_chr;
    p = scan_toks(false, false);
    p = (*mem.offset(def_ref as isize)).b32.s1;
    while p != -0xfffffffi32 {
        t = (*mem.offset(p as isize)).b32.s0;
        if t < 0x1ffffffi32 + (1i32 + (0x10ffffi32 + 1i32)) {
            c = t % 0x200000i32;
            if (*eqtb.offset((b + c) as isize)).b32.s1 != 0i32 {
                (*mem.offset(p as isize)).b32.s0 = t - c + (*eqtb.offset((b + c) as isize)).b32.s1
            }
        }
        p = (*mem.offset(p as isize)).b32.s1
    }
    begin_token_list((*mem.offset(def_ref as isize)).b32.s1, 3_u16);
    (*mem.offset(def_ref as isize)).b32.s1 = avail;
    avail = def_ref;
}
#[no_mangle]
pub unsafe extern "C" fn show_whatever() {
    let mut current_block: u64;
    let mut p: i32 = 0;
    let mut t: small_number = 0;
    let mut m: u8 = 0;
    let mut l: i32 = 0;
    let mut n: i32 = 0;
    match cur_chr {
        3 => {
            begin_diagnostic();
            show_activities();
            current_block = 7330218953828964527;
        }
        1 => {
            scan_register_num();
            if cur_val < 256i32 {
                p = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + cur_val) as isize,
                ))
                .b32
                .s1
            } else {
                find_sa_element(4i32 as small_number, cur_val, false);
                if cur_ptr == -0xfffffffi32 {
                    p = -0xfffffffi32
                } else {
                    p = (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1
                }
            }
            begin_diagnostic();
            print_nl_cstr(b"> \\box\x00" as *const u8 as *const i8);
            print_int(cur_val);
            print_char('=' as i32);
            if p == -0xfffffffi32 {
                print_cstr(b"void\x00" as *const u8 as *const i8);
            } else {
                show_box(p);
            }
            current_block = 7330218953828964527;
        }
        0 => {
            get_token();
            print_nl_cstr(b"> \x00" as *const u8 as *const i8);
            if cur_cs != 0i32 {
                sprint_cs(cur_cs);
                print_char('=' as i32);
            }
            print_meaning();
            current_block = 6249296489108783913;
        }
        4 => {
            begin_diagnostic();
            show_save_groups();
            current_block = 7330218953828964527;
        }
        6 => {
            begin_diagnostic();
            print_nl_cstr(b"\x00" as *const u8 as *const i8);
            print_ln();
            if cond_ptr == -0xfffffffi32 {
                print_nl_cstr(b"### \x00" as *const u8 as *const i8);
                print_cstr(b"no active conditionals\x00" as *const u8 as *const i8);
            } else {
                p = cond_ptr;
                n = 0i32;
                loop {
                    n += 1;
                    p = (*mem.offset(p as isize)).b32.s1;
                    if p == -0xfffffffi32 {
                        break;
                    }
                }
                p = cond_ptr;
                t = cur_if;
                l = if_line;
                m = if_limit;
                loop {
                    print_nl_cstr(b"### level \x00" as *const u8 as *const i8);
                    print_int(n);
                    print_cstr(b": \x00" as *const u8 as *const i8);
                    print_cmd_chr(107_u16, t as i32);
                    if m as i32 == 2i32 {
                        print_esc_cstr(b"else\x00" as *const u8 as *const i8);
                    }
                    if l != 0i32 {
                        print_cstr(b" entered on line \x00" as *const u8 as *const i8);
                        print_int(l);
                    }
                    n -= 1;
                    t = (*mem.offset(p as isize)).b16.s0 as small_number;
                    l = (*mem.offset((p + 1i32) as isize)).b32.s1;
                    m = (*mem.offset(p as isize)).b16.s1 as u8;
                    p = (*mem.offset(p as isize)).b32.s1;
                    if p == -0xfffffffi32 {
                        break;
                    }
                }
            }
            current_block = 7330218953828964527;
        }
        _ => {
            p = the_toks();
            print_nl_cstr(b"> \x00" as *const u8 as *const i8);
            token_show(4999999i32 - 3i32);
            flush_list((*mem.offset((4999999i32 - 3i32) as isize)).b32.s1);
            current_block = 6249296489108783913;
        }
    }
    match current_block {
        7330218953828964527 => {
            end_diagnostic(1i32 != 0);
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"OK\x00" as *const u8 as *const i8);
            if selector == Selector::TERM_AND_LOG {
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 29i32) as isize,
                ))
                .b32
                .s1 <= 0i32
                {
                    selector = Selector::TERM_ONLY;
                    print_cstr(b" (see the transcript file)\x00" as *const u8 as *const i8);
                    selector = Selector::TERM_AND_LOG
                }
            }
        }
        _ => {}
    }
    if (interaction as i32) < 3i32 {
        help_ptr = 0_u8;
        error_count -= 1
    } else if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 29i32) as isize,
    ))
    .b32
    .s1 > 0i32
    {
        help_ptr = 3_u8;
        help_line[2] = b"This isn\'t an error message; I\'m just \\showing something.\x00"
            as *const u8 as *const i8;
        help_line[1] =
            b"Type `I\\show...\' to show more (e.g., \\show\\cs,\x00" as *const u8 as *const i8;
        help_line[0] =
            b"\\showthe\\count10, \\showbox255, \\showlists).\x00" as *const u8 as *const i8
    } else {
        help_ptr = 5_u8;
        help_line[4] = b"This isn\'t an error message; I\'m just \\showing something.\x00"
            as *const u8 as *const i8;
        help_line[3] =
            b"Type `I\\show...\' to show more (e.g., \\show\\cs,\x00" as *const u8 as *const i8;
        help_line[2] =
            b"\\showthe\\count10, \\showbox255, \\showlists).\x00" as *const u8 as *const i8;
        help_line[1] = b"And type `I\\tracingonline=1\\show...\' to show boxes and\x00" as *const u8
            as *const i8;
        help_line[0] = b"lists on your terminal as well as in the transcript file.\x00" as *const u8
            as *const i8
    }
    error();
}
#[no_mangle]
pub unsafe extern "C" fn new_write_whatsit(mut w: small_number) {
    new_whatsit(cur_chr as small_number, w);
    if w as i32 != 2i32 {
        scan_four_bit_int();
    } else {
        scan_int();
        if cur_val < 0i32 {
            cur_val = 17i32
        } else if cur_val > 15i32 && cur_val != 18i32 {
            cur_val = 16i32
        }
    }
    (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s0 = cur_val;
}
#[no_mangle]
pub unsafe extern "C" fn scan_and_pack_name() {
    scan_file_name();
    pack_file_name(cur_name, cur_area, cur_ext);
}
#[no_mangle]
pub unsafe extern "C" fn do_extension() {
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut k: i32 = 0;
    let mut p: i32 = 0;
    match cur_chr {
        0 => {
            new_write_whatsit(3i32 as small_number);
            scan_optional_equals();
            scan_file_name();
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = cur_name;
            (*mem.offset((cur_list.tail + 2i32) as isize)).b32.s0 = cur_area;
            (*mem.offset((cur_list.tail + 2i32) as isize)).b32.s1 = cur_ext
        }
        1 => {
            k = cur_cs;
            new_write_whatsit(2i32 as small_number);
            cur_cs = k;
            p = scan_toks(false, false);
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = def_ref
        }
        2 => {
            new_write_whatsit(2i32 as small_number);
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = -0xfffffffi32
        }
        3 => {
            new_whatsit(3i32 as small_number, 2i32 as small_number);
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s0 = -0xfffffffi32;
            p = scan_toks(false, true);
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = def_ref
        }
        4 => {
            get_x_token();
            if cur_cmd as i32 == 59i32 && cur_chr <= 2i32 {
                p = cur_list.tail;
                do_extension();
                out_what(cur_list.tail);
                flush_node_list(cur_list.tail);
                cur_list.tail = p;
                (*mem.offset(p as isize)).b32.s1 = -0xfffffffi32
            } else {
                back_input();
            }
        }
        5 => {
            if (cur_list.mode as i32).abs() != 104i32 {
                report_illegal_case();
            } else {
                new_whatsit(4i32 as small_number, 2i32 as small_number);
                scan_int();
                if cur_val <= 0i32 {
                    cur_list.aux.b32.s1 = 0i32
                } else if cur_val > 255i32 {
                    cur_list.aux.b32.s1 = 0i32
                } else {
                    cur_list.aux.b32.s1 = cur_val
                }
                (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = cur_list.aux.b32.s1;
                (*mem.offset((cur_list.tail + 1i32) as isize)).b16.s1 = norm_min(
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 51i32) as isize,
                    ))
                    .b32
                    .s1,
                ) as u16;
                (*mem.offset((cur_list.tail + 1i32) as isize)).b16.s0 = norm_min(
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 52i32) as isize,
                    ))
                    .b32
                    .s1,
                ) as u16
            }
        }
        41 => {
            if (cur_list.mode as i32).abs() == 207i32 {
                report_illegal_case();
            } else {
                load_picture(false);
            }
        }
        42 => {
            if (cur_list.mode as i32).abs() == 207i32 {
                report_illegal_case();
            } else {
                load_picture(1i32 != 0);
            }
        }
        43 => {
            if (cur_list.mode as i32).abs() == 1i32 {
                back_input();
                new_graf(1i32 != 0);
            } else if (cur_list.mode as i32).abs() == 207i32 {
                report_illegal_case();
            } else if font_area[
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32) as isize,
                ))
                .b32
                .s1 as usize] as u32 == 0xffffu32
                || font_area[
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32) as isize,
                    ))
                    .b32
                    .s1 as usize] as u32 == 0xfffeu32
            {
                new_whatsit(42i32 as small_number, 5i32 as small_number);
                scan_int();
                if cur_val < 0i32 || cur_val as i64 > 65535 {
                    if file_line_error_style_p != 0 {
                        print_file_line();
                    } else {
                        print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                    }
                    print_cstr(b"Bad glyph number\x00" as *const u8 as *const i8);
                    help_ptr = 2_u8;
                    help_line[1] = b"A glyph number must be between 0 and 65535.\x00" as *const u8
                        as *const i8;
                    help_line[0] = b"I changed this one to zero.\x00" as *const u8 as *const i8;
                    int_error(cur_val);
                    cur_val = 0i32
                }
                (*mem.offset((cur_list.tail + 4i32) as isize)).b16.s2 = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32) as isize,
                ))
                .b32
                .s1 as u16;
                (*mem.offset((cur_list.tail + 4i32) as isize)).b16.s1 = cur_val as u16;
                measure_native_glyph(
                    &mut *mem.offset(cur_list.tail as isize) as *mut memory_word
                        as *mut libc::c_void,
                    ((*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 74i32) as isize,
                    ))
                    .b32
                    .s1 > 0i32) as i32,
                );
            } else {
                not_native_font_error(
                    59i32,
                    43i32,
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32) as isize,
                    ))
                    .b32
                    .s1,
                );
            }
        }
        44 => {
            scan_and_pack_name();
            i = get_encoding_mode_and_info(&mut j);
            if i == 0i32 {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(
                    b"Encoding mode `auto\' is not valid for \\XeTeXinputencoding\x00" as *const u8
                        as *const i8,
                );
                help_ptr = 2_u8;
                help_line[1] =
                    b"You can\'t use `auto\' encoding here, only for \\XeTeXdefaultencoding.\x00"
                        as *const u8 as *const i8;
                help_line[0] = b"I\'ll ignore this and leave the current encoding unchanged.\x00"
                    as *const u8 as *const i8;
                error();
            } else {
                set_input_file_encoding(*input_file.offset(in_open as isize), i, j);
            }
        }
        45 => {
            scan_and_pack_name();
            i = get_encoding_mode_and_info(&mut j);
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 77i32) as isize,
            ))
            .b32
            .s1 = i;
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 78i32) as isize,
            ))
            .b32
            .s1 = j
        }
        46 => {
            scan_file_name();
            if length(cur_name) == 0i32 {
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 68i32) as isize,
                ))
                .b32
                .s1 = 0i32
            } else {
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 68i32) as isize,
                ))
                .b32
                .s1 = cur_name
            }
        }
        6 => {
            new_whatsit(6i32 as small_number, 2i32 as small_number);
        }
        _ => {
            confusion(b"ext1\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn fix_language() {
    let mut l: UTF16_code = 0;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 50i32) as isize,
    ))
    .b32
    .s1 <= 0i32
    {
        l = 0i32 as UTF16_code
    } else if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 13i32
            + 256i32
            + 4i32
            + 256i32
            + 1i32
            + 3i32 * 256i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 50i32) as isize,
    ))
    .b32
    .s1 > 255i32
    {
        l = 0i32 as UTF16_code
    } else {
        l = (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 13i32
                + 256i32
                + 4i32
                + 256i32
                + 1i32
                + 3i32 * 256i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 50i32) as isize,
        ))
        .b32
        .s1 as UTF16_code
    }
    if l as i32 != cur_list.aux.b32.s1 {
        new_whatsit(4i32 as small_number, 2i32 as small_number);
        (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = l as i32;
        cur_list.aux.b32.s1 = l as i32;
        (*mem.offset((cur_list.tail + 1i32) as isize)).b16.s1 = norm_min(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 51i32) as isize,
            ))
            .b32
            .s1,
        ) as u16;
        (*mem.offset((cur_list.tail + 1i32) as isize)).b16.s0 = norm_min(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 52i32) as isize,
            ))
            .b32
            .s1,
        ) as u16
    };
}
#[no_mangle]
pub unsafe extern "C" fn insert_src_special() {
    let mut toklist: i32 = 0;
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    if *source_filename_stack.offset(in_open as isize) > 0i32
        && is_new_source(*source_filename_stack.offset(in_open as isize), line) as i32 != 0
    {
        toklist = get_avail();
        p = toklist;
        (*mem.offset(p as isize)).b32.s0 = 0x1ffffffi32
            + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 10i32);
        (*mem.offset(p as isize)).b32.s1 = get_avail();
        p = (*mem.offset(p as isize)).b32.s1;
        (*mem.offset(p as isize)).b32.s0 = 0x200000i32 + '{' as i32;
        q = str_toks(make_src_special(
            *source_filename_stack.offset(in_open as isize),
            line,
        ));
        (*mem.offset(p as isize)).b32.s1 = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
        p = q;
        (*mem.offset(p as isize)).b32.s1 = get_avail();
        p = (*mem.offset(p as isize)).b32.s1;
        (*mem.offset(p as isize)).b32.s0 = 0x400000i32 + '}' as i32;
        begin_token_list(toklist, 5_u16);
        remember_source_info(*source_filename_stack.offset(in_open as isize), line);
    };
}
#[no_mangle]
pub unsafe extern "C" fn append_src_special() {
    if *source_filename_stack.offset(in_open as isize) > 0i32
        && is_new_source(*source_filename_stack.offset(in_open as isize), line) as i32 != 0
    {
        new_whatsit(3i32 as small_number, 2i32 as small_number);
        (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s0 = 0i32;
        def_ref = get_avail();
        (*mem.offset(def_ref as isize)).b32.s0 = -0xfffffffi32;
        str_toks(make_src_special(
            *source_filename_stack.offset(in_open as isize),
            line,
        ));
        (*mem.offset(def_ref as isize)).b32.s1 = (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1;
        (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = def_ref;
        remember_source_info(*source_filename_stack.offset(in_open as isize), line);
    };
}
#[no_mangle]
pub unsafe extern "C" fn handle_right_brace() {
    let mut p: i32 = 0;
    let mut q: i32 = 0;
    let mut d: scaled_t = 0;
    let mut f: i32 = 0;
    match cur_group as i32 {
        1 => {
            unsave();
        }
        0 => {
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Too many }\'s\x00" as *const u8 as *const i8);
            help_ptr = 2_u8;
            help_line[1] =
                b"You\'ve closed more groups than you opened.\x00" as *const u8 as *const i8;
            help_line[0] = b"Such booboos are generally harmless, so keep going.\x00" as *const u8
                as *const i8;
            error();
        }
        14 | 15 | 16 => {
            extra_right_brace();
        }
        2 => {
            package(0i32 as small_number);
        }
        3 => {
            adjust_tail = 4999999i32 - 5i32;
            pre_adjust_tail = 4999999i32 - 14i32;
            package(0i32 as small_number);
        }
        4 => {
            end_graf();
            package(0i32 as small_number);
        }
        5 => {
            end_graf();
            package(4i32 as small_number);
        }
        11 => {
            end_graf();
            q = (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 10i32) as isize,
            ))
            .b32
            .s1;
            let ref mut fresh87 = (*mem.offset(q as isize)).b32.s1;
            *fresh87 += 1;
            d = (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 85i32
                    + 256i32
                    + (0x10ffffi32 + 1i32)
                    + 6i32) as isize,
            ))
            .b32
            .s1;
            f = (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 42i32) as isize,
            ))
            .b32
            .s1;
            unsave();
            save_ptr = save_ptr - 2i32;
            p = vpackage(
                (*mem.offset(cur_list.head as isize)).b32.s1,
                0i32,
                1i32 as small_number,
                0x3fffffffi32,
            );
            pop_nest();
            if (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 < 255i32 {
                (*mem.offset(cur_list.tail as isize)).b32.s1 = get_node(5i32);
                cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                (*mem.offset(cur_list.tail as isize)).b16.s1 = 3_u16;
                (*mem.offset(cur_list.tail as isize)).b16.s0 =
                    (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 as u16;
                (*mem.offset((cur_list.tail + 3i32) as isize)).b32.s1 =
                    (*mem.offset((p + 3i32) as isize)).b32.s1
                        + (*mem.offset((p + 2i32) as isize)).b32.s1;
                (*mem.offset((cur_list.tail + 4i32) as isize)).b32.s0 =
                    (*mem.offset((p + 5i32) as isize)).b32.s1;
                (*mem.offset((cur_list.tail + 4i32) as isize)).b32.s1 = q;
                (*mem.offset((cur_list.tail + 2i32) as isize)).b32.s1 = d;
                (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = f
            } else {
                (*mem.offset(cur_list.tail as isize)).b32.s1 = get_node(2i32);
                cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                (*mem.offset(cur_list.tail as isize)).b16.s1 = 5_u16;
                (*mem.offset(cur_list.tail as isize)).b16.s0 =
                    (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1 as u16;
                (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 =
                    (*mem.offset((p + 5i32) as isize)).b32.s1;
                delete_glue_ref(q);
            }
            free_node(p, 8i32);
            if nest_ptr == 0i32 {
                build_page();
            }
        }
        8 => {
            /*1062:*/
            if cur_input.loc != -0xfffffffi32
                || cur_input.index as i32 != 7i32 && cur_input.index as i32 != 3i32
            {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Unbalanced output routine\x00" as *const u8 as *const i8);
                help_ptr = 2_u8;
                help_line[1] = b"Your sneaky output routine has problematic {\'s and/or }\'s.\x00"
                    as *const u8 as *const i8;
                help_line[0] =
                    b"I can\'t handle that very well; good luck.\x00" as *const u8 as *const i8;
                error();
                loop {
                    get_token();
                    if !(cur_input.loc != -0xfffffffi32) {
                        break;
                    }
                }
            }
            end_token_list();
            end_graf();
            unsave();
            output_active = false;
            insert_penalties = 0i32;
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 255i32) as isize,
            ))
            .b32
            .s1 != -0xfffffffi32
            {
                if file_line_error_style_p != 0 {
                    print_file_line();
                } else {
                    print_nl_cstr(b"! \x00" as *const u8 as *const i8);
                }
                print_cstr(b"Output routine didn\'t use all of \x00" as *const u8 as *const i8);
                print_esc_cstr(b"box\x00" as *const u8 as *const i8);
                print_int(255i32);
                help_ptr = 3_u8;
                help_line[2] =
                    b"Your \\output commands should empty \\box255,\x00" as *const u8 as *const i8;
                help_line[1] =
                    b"e.g., by saying `\\shipout\\box255\'.\x00" as *const u8 as *const i8;
                help_line[0] =
                    b"Proceed; I\'ll discard its present contents.\x00" as *const u8 as *const i8;
                box_error(255i32 as eight_bits);
            }
            if cur_list.tail != cur_list.head {
                (*mem.offset(page_tail as isize)).b32.s1 =
                    (*mem.offset(cur_list.head as isize)).b32.s1;
                page_tail = cur_list.tail
            }
            if (*mem.offset((4999999i32 - 2i32) as isize)).b32.s1 != -0xfffffffi32 {
                if (*mem.offset((4999999i32 - 1i32) as isize)).b32.s1 == -0xfffffffi32 {
                    (*nest.offset(0)).tail = page_tail
                }
                (*mem.offset(page_tail as isize)).b32.s1 =
                    (*mem.offset((4999999i32 - 1i32) as isize)).b32.s1;
                (*mem.offset((4999999i32 - 1i32) as isize)).b32.s1 =
                    (*mem.offset((4999999i32 - 2i32) as isize)).b32.s1;
                (*mem.offset((4999999i32 - 2i32) as isize)).b32.s1 = -0xfffffffi32;
                page_tail = 4999999i32 - 2i32
            }
            flush_node_list(disc_ptr[2]);
            disc_ptr[2] = -0xfffffffi32;
            pop_nest();
            build_page();
        }
        10 => {
            build_discretionary();
        }
        6 => {
            back_input();
            cur_tok = 0x1ffffffi32
                + (1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32 + 15000i32 + 1i32);
            if file_line_error_style_p != 0 {
                print_file_line();
            } else {
                print_nl_cstr(b"! \x00" as *const u8 as *const i8);
            }
            print_cstr(b"Missing \x00" as *const u8 as *const i8);
            print_esc_cstr(b"cr\x00" as *const u8 as *const i8);
            print_cstr(b" inserted\x00" as *const u8 as *const i8);
            help_ptr = 1_u8;
            help_line[0] = b"I\'m guessing that you meant to end an alignment here.\x00"
                as *const u8 as *const i8;
            ins_error();
        }
        7 => {
            end_graf();
            unsave();
            align_peek();
        }
        12 => {
            end_graf();
            unsave();
            save_ptr = save_ptr - 2i32;
            p = vpackage(
                (*mem.offset(cur_list.head as isize)).b32.s1,
                (*save_stack.offset((save_ptr + 1i32) as isize)).b32.s1,
                (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 as small_number,
                0x3fffffffi32,
            );
            pop_nest();
            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_noad();
            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
            (*mem.offset(cur_list.tail as isize)).b16.s1 = 29_u16;
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1 = 2i32;
            (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s0 = p
        }
        13 => {
            build_choices();
        }
        9 => {
            unsave();
            save_ptr -= 1;
            (*mem.offset((*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 as isize))
                .b32
                .s1 = 3i32;
            p = fin_mlist(-0xfffffffi32);
            (*mem.offset((*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1 as isize))
                .b32
                .s0 = p;
            if p != -0xfffffffi32 {
                if (*mem.offset(p as isize)).b32.s1 == -0xfffffffi32 {
                    if (*mem.offset(p as isize)).b16.s1 as i32 == 16i32 {
                        if (*mem.offset((p + 3i32) as isize)).b32.s1 == 0i32 {
                            if (*mem.offset((p + 2i32) as isize)).b32.s1 == 0i32 {
                                (*mem.offset(
                                    (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1
                                        as isize,
                                ))
                                .b32 = (*mem.offset((p + 1i32) as isize)).b32;
                                free_node(p, 4i32);
                            }
                        }
                    } else if (*mem.offset(p as isize)).b16.s1 as i32 == 28i32 {
                        if (*save_stack.offset((save_ptr + 0i32) as isize)).b32.s1
                            == cur_list.tail + 1i32
                        {
                            if (*mem.offset(cur_list.tail as isize)).b16.s1 as i32 == 16i32 {
                                /*1222:*/
                                q = cur_list.head;
                                while (*mem.offset(q as isize)).b32.s1 != cur_list.tail {
                                    q = (*mem.offset(q as isize)).b32.s1
                                }
                                (*mem.offset(q as isize)).b32.s1 = p;
                                free_node(cur_list.tail, 4i32);
                                cur_list.tail = p
                            }
                        }
                    }
                }
            }
        }
        _ => {
            confusion(b"rightbrace\x00" as *const u8 as *const i8);
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn main_control() {
    let mut current_block: u64;
    let mut t: i32 = 0;
    if (*eqtb.offset(
        (1i32
            + (0x10ffffi32 + 1i32)
            + (0x10ffffi32 + 1i32)
            + 1i32
            + 15000i32
            + 12i32
            + 9000i32
            + 1i32
            + 1i32
            + 19i32
            + 256i32
            + 256i32
            + 7i32) as isize,
    ))
    .b32
    .s1 != -0xfffffffi32
    {
        begin_token_list(
            (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 7i32) as isize,
            ))
            .b32
            .s1,
            13_u16,
        );
    }
    'c_125208: loop {
        /* big_switch */
        get_x_token();
        loop {
            /*1066: */
            if (*eqtb.offset(
                (1i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 1i32
                    + 15000i32
                    + 12i32
                    + 9000i32
                    + 1i32
                    + 1i32
                    + 19i32
                    + 256i32
                    + 256i32
                    + 13i32
                    + 256i32
                    + 4i32
                    + 256i32
                    + 1i32
                    + 3i32 * 256i32
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + (0x10ffffi32 + 1i32)
                    + 36i32) as isize,
            ))
            .b32
            .s1 > 0i32
            {
                show_cur_cmd_chr(); /*:1490 */
            }
            match (cur_list.mode as i32).abs() + cur_cmd as i32 {
                115 | 116 | 172 => {}
                120 => {
                    scan_usv_num();
                    cur_chr = cur_val
                }
                169 => {
                    get_x_token();
                    if cur_cmd as i32 == 11i32
                        || cur_cmd as i32 == 12i32
                        || cur_cmd as i32 == 68i32
                        || cur_cmd as i32 == 16i32
                    {
                        cancel_boundary = true
                    }
                    continue;
                }
                _ => {
                    if (cur_list.mode as i32).abs() == 104i32 {
                        if (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 75i32) as isize,
                        ))
                        .b32
                        .s1 > 0i32
                            && space_class != 4096i32
                            && prev_class != 4096i32 - 1i32
                        {
                            prev_class = 4096i32 - 1i32;
                            find_sa_element(
                                6i32 as small_number,
                                space_class * 4096i32 + (4096i32 - 1i32),
                                false,
                            );
                            if cur_ptr != -0xfffffffi32 {
                                if cur_cs == 0i32 {
                                    if cur_cmd as i32 == 16i32 {
                                        cur_cmd = 12i32 as eight_bits
                                    }
                                    cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr
                                } else {
                                    cur_tok = 0x1ffffffi32 + cur_cs
                                }
                                back_input();
                                begin_token_list(
                                    (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1,
                                    17_u16,
                                );
                                continue 'c_125208;
                            }
                        }
                    }
                    match (cur_list.mode as i32).abs() + cur_cmd as i32 {
                        114 => {
                            if cur_list.aux.b32.s0 == 1000i32 {
                                current_block = 1496671425652391013;
                                break;
                            } else {
                                current_block = 11459959175219260272;
                                break;
                            }
                        }
                        168 | 271 => {
                            current_block = 1496671425652391013;
                            break;
                        }
                        40 | 143 | 246 => {
                            if cur_chr == 0i32 {
                                loop {
                                    get_x_token();
                                    if !(cur_cmd as i32 == 10i32) {
                                        break;
                                    }
                                }
                                continue;
                            } else {
                                t = scanner_status as i32;
                                scanner_status = 0_u8;
                                get_next();
                                scanner_status = t as u8;
                                if cur_cs
                                    < 1i32 + (0x10ffffi32 + 1i32) + (0x10ffffi32 + 1i32) + 1i32
                                {
                                    cur_cs = prim_lookup(cur_cs - (1i32 + (0x10ffffi32 + 1i32)))
                                } else {
                                    cur_cs = prim_lookup((*hash.offset(cur_cs as isize)).s1)
                                }
                                if !(cur_cs != 0i32) {
                                    continue 'c_125208;
                                }
                                cur_cmd = prim_eqtb[cur_cs as usize].b16.s1 as eight_bits;
                                cur_chr = prim_eqtb[cur_cs as usize].b32.s1;
                                continue;
                            }
                        }
                        15 => {
                            if its_all_over() {
                                return;
                            }
                            continue 'c_125208;
                        }
                        23 | 125 | 228 | 72 | 175 | 278 | 39 | 45 | 49 | 152 | 7 | 110 | 213 => {
                            report_illegal_case();
                            continue 'c_125208;
                        }
                        8 | 111 | 9 | 112 | 18 | 121 | 70 | 173 | 71 | 174 | 51 | 154 | 16
                        | 119 | 50 | 153 | 53 | 156 | 67 | 170 | 54 | 157 | 55 | 158 | 57 | 160
                        | 56 | 159 | 31 | 134 | 52 | 155 | 29 | 132 | 47 | 150 | 216 | 220
                        | 221 | 234 | 231 | 240 | 243 => {
                            insert_dollar_sign();
                            continue 'c_125208;
                        }
                        37 | 139 | 242 => {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 = scan_rule_spec();
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            if (cur_list.mode as i32).abs() == 1i32 {
                                cur_list.aux.b32.s1 = -65536000i32
                            } else if (cur_list.mode as i32).abs() == 104i32 {
                                cur_list.aux.b32.s0 = 1000i32
                            }
                            continue 'c_125208;
                        }
                        28 | 130 | 233 | 235 => {
                            append_glue();
                            continue 'c_125208;
                        }
                        30 | 133 | 236 | 237 => {
                            append_kern();
                            continue 'c_125208;
                        }
                        2 | 105 => {
                            new_save_level(1i32 as group_code);
                            continue 'c_125208;
                        }
                        62 | 165 | 268 => {
                            new_save_level(14i32 as group_code);
                            continue 'c_125208;
                        }
                        63 | 166 | 269 => {
                            if cur_group as i32 == 14i32 {
                                unsave();
                            } else {
                                off_save();
                            }
                            continue 'c_125208;
                        }
                        3 | 106 | 209 => {
                            handle_right_brace();
                            continue 'c_125208;
                        }
                        22 | 126 | 229 => {
                            t = cur_chr;
                            scan_dimen(false, false, false);
                            if t == 0i32 {
                                scan_box(cur_val);
                            } else {
                                scan_box(-cur_val);
                            }
                            continue 'c_125208;
                        }
                        32 | 135 | 238 => {
                            scan_box(0x40010001i32 - 100i32 + cur_chr);
                            continue 'c_125208;
                        }
                        21 | 124 | 227 => {
                            begin_box(0i32);
                            continue 'c_125208;
                        }
                        44 => {
                            new_graf(cur_chr > 0i32);
                            continue 'c_125208;
                        }
                        12 | 13 | 17 | 69 | 4 | 24 | 36 | 46 | 48 | 27 | 34 | 65 | 66 => {
                            back_input();
                            new_graf(1i32 != 0);
                            continue 'c_125208;
                        }
                        147 | 250 => {
                            indent_in_hmode();
                            continue 'c_125208;
                        }
                        14 => {
                            normal_paragraph();
                            if cur_list.mode as i32 > 0i32 {
                                build_page();
                            }
                            continue 'c_125208;
                        }
                        117 => {
                            if align_state < 0i32 {
                                off_save();
                            }
                            end_graf();
                            if cur_list.mode as i32 == 1i32 {
                                build_page();
                            }
                            continue 'c_125208;
                        }
                        118 | 131 | 140 | 128 | 136 => {
                            head_for_vmode();
                            continue 'c_125208;
                        }
                        38 | 141 | 244 | 142 | 245 => {
                            begin_insert_or_adjust();
                            continue 'c_125208;
                        }
                        19 | 122 | 225 => {
                            make_mark();
                            continue 'c_125208;
                        }
                        43 | 146 | 249 => {
                            append_penalty();
                            continue 'c_125208;
                        }
                        26 | 129 | 232 => {
                            delete_last();
                            continue 'c_125208;
                        }
                        25 | 127 | 230 => {
                            unpackage();
                            continue 'c_125208;
                        }
                        148 => {
                            append_italic_correction();
                            continue 'c_125208;
                        }
                        251 => {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_kern(0i32);
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            continue 'c_125208;
                        }
                        151 | 254 => {
                            append_discretionary();
                            continue 'c_125208;
                        }
                        149 => {
                            make_accent();
                            continue 'c_125208;
                        }
                        6 | 109 | 212 | 5 | 108 | 211 => {
                            align_error();
                            continue 'c_125208;
                        }
                        35 | 138 | 241 => {
                            no_align_error();
                            continue 'c_125208;
                        }
                        64 | 167 | 270 => {
                            omit_error();
                            continue 'c_125208;
                        }
                        33 => {
                            init_align();
                            continue 'c_125208;
                        }
                        137 => {
                            if cur_chr > 0i32 {
                                if eTeX_enabled(
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32
                                            + 1i32
                                            + 3i32 * 256i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 71i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1 > 0i32,
                                    cur_cmd as u16,
                                    cur_chr,
                                ) {
                                    (*mem.offset(cur_list.tail as isize)).b32.s1 =
                                        new_math(0i32, cur_chr as small_number);
                                    cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
                                }
                            } else {
                                init_align();
                            }
                            continue 'c_125208;
                        }
                        239 => {
                            if privileged() {
                                if cur_group as i32 == 15i32 {
                                    init_align();
                                } else {
                                    off_save();
                                }
                            }
                            continue 'c_125208;
                        }
                        10 | 113 => {
                            do_endv();
                            continue 'c_125208;
                        }
                        68 | 171 | 274 => {
                            cs_error();
                            continue 'c_125208;
                        }
                        107 => {
                            init_math();
                            continue 'c_125208;
                        }
                        255 => {
                            if privileged() {
                                if cur_group as i32 == 15i32 {
                                    start_eq_no();
                                } else {
                                    off_save();
                                }
                            }
                            continue 'c_125208;
                        }
                        208 => {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_noad();
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            back_input();
                            scan_math(cur_list.tail + 1i32);
                            continue 'c_125208;
                        }
                        218 | 219 | 275 => {
                            set_math_char(
                                (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + cur_chr) as isize,
                                ))
                                .b32
                                .s1,
                            );
                            continue 'c_125208;
                        }
                        223 => {
                            scan_char_num();
                            cur_chr = cur_val;
                            set_math_char(
                                (*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + cur_chr) as isize,
                                ))
                                .b32
                                .s1,
                            );
                            continue 'c_125208;
                        }
                        224 => {
                            if cur_chr == 2i32 {
                                scan_math_class_int();
                                t = ((cur_val as u32 & 0x7_u32) << 21i32) as i32;
                                scan_math_fam_int();
                                t = (t as u32).wrapping_add((cur_val as u32 & 0xff_u32) << 24i32)
                                    as i32;
                                scan_usv_num();
                                t = t + cur_val;
                                set_math_char(t);
                            } else if cur_chr == 1i32 {
                                scan_xetex_math_char_int();
                                set_math_char(cur_val);
                            } else {
                                scan_fifteen_bit_int();
                                set_math_char(
                                    (((cur_val / 4096i32) as u32 & 0x7_u32) << 21i32)
                                        .wrapping_add(
                                            ((cur_val % 4096i32 / 256i32) as u32 & 0xff_u32)
                                                << 24i32,
                                        )
                                        .wrapping_add((cur_val % 256i32) as u32)
                                        as i32,
                                );
                            }
                            continue 'c_125208;
                        }
                        276 => {
                            set_math_char(
                                (((cur_chr / 4096i32) as u32 & 0x7_u32) << 21i32)
                                    .wrapping_add(
                                        ((cur_chr % 4096i32 / 256i32) as u32 & 0xff_u32) << 24i32,
                                    )
                                    .wrapping_add((cur_chr % 256i32) as u32)
                                    as i32,
                            );
                            continue 'c_125208;
                        }
                        277 => {
                            set_math_char(cur_chr);
                            continue 'c_125208;
                        }
                        222 => {
                            if cur_chr == 1i32 {
                                scan_math_class_int();
                                t = ((cur_val as u32 & 0x7_u32) << 21i32) as i32;
                                scan_math_fam_int();
                                t = (t as u32).wrapping_add((cur_val as u32 & 0xff_u32) << 24i32)
                                    as i32;
                                scan_usv_num();
                                t = t + cur_val;
                                set_math_char(t);
                            } else {
                                scan_delimiter_int();
                                cur_val = cur_val / 4096i32;
                                set_math_char(
                                    (((cur_val / 4096i32) as u32 & 0x7_u32) << 21i32)
                                        .wrapping_add(
                                            ((cur_val % 4096i32 / 256i32) as u32 & 0xff_u32)
                                                << 24i32,
                                        )
                                        .wrapping_add((cur_val % 256i32) as u32)
                                        as i32,
                                );
                            }
                            continue 'c_125208;
                        }
                        257 => {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_noad();
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            (*mem.offset(cur_list.tail as isize)).b16.s1 = cur_chr as u16;
                            scan_math(cur_list.tail + 1i32);
                            continue 'c_125208;
                        }
                        258 => {
                            math_limit_switch();
                            continue 'c_125208;
                        }
                        273 => {
                            math_radical();
                            continue 'c_125208;
                        }
                        252 | 253 => {
                            math_ac();
                            continue 'c_125208;
                        }
                        263 => {
                            scan_spec(12i32 as group_code, false);
                            normal_paragraph();
                            push_nest();
                            cur_list.mode = -1_i16;
                            cur_list.aux.b32.s1 = -65536000i32;
                            if insert_src_special_every_vbox {
                                insert_src_special();
                            }
                            if (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 6i32) as isize,
                            ))
                            .b32
                            .s1 != -0xfffffffi32
                            {
                                begin_token_list(
                                    (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 6i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1,
                                    12_u16,
                                );
                            }
                            continue 'c_125208;
                        }
                        260 => {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 =
                                new_style(cur_chr as small_number);
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            continue 'c_125208;
                        }
                        262 => {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_glue(0i32);
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            (*mem.offset(cur_list.tail as isize)).b16.s0 = 98_u16;
                            continue 'c_125208;
                        }
                        261 => {
                            append_choices();
                            continue 'c_125208;
                        }
                        215 | 214 => {
                            sub_sup();
                            continue 'c_125208;
                        }
                        259 => {
                            math_fraction();
                            continue 'c_125208;
                        }
                        256 => {
                            math_left_right();
                            continue 'c_125208;
                        }
                        210 => {
                            if cur_group as i32 == 15i32 {
                                after_math();
                            } else {
                                off_save();
                            }
                            continue 'c_125208;
                        }
                        73 | 176 | 279 | 74 | 177 | 280 | 75 | 178 | 281 | 76 | 179 | 282 | 77
                        | 180 | 283 | 78 | 181 | 284 | 79 | 182 | 285 | 80 | 183 | 286 | 81
                        | 184 | 287 | 82 | 185 | 288 | 83 | 186 | 289 | 84 | 187 | 290 | 85
                        | 188 | 291 | 86 | 189 | 292 | 87 | 190 | 293 | 88 | 191 | 294 | 89
                        | 192 | 295 | 90 | 193 | 296 | 91 | 194 | 297 | 92 | 195 | 298 | 93
                        | 196 | 299 | 94 | 197 | 300 | 95 | 198 | 301 | 96 | 199 | 302 | 97
                        | 200 | 303 | 98 | 201 | 304 | 99 | 202 | 305 | 100 | 203 | 306 | 101
                        | 204 | 307 | 102 | 205 | 308 | 103 | 206 | 309 => {
                            prefixed_command();
                            continue 'c_125208;
                        }
                        41 | 144 | 247 => {
                            get_token();
                            after_token = cur_tok;
                            continue 'c_125208;
                        }
                        42 | 145 | 248 => {
                            get_token();
                            save_for_after(cur_tok);
                            continue 'c_125208;
                        }
                        61 | 164 | 267 => {
                            open_or_close_in();
                            continue 'c_125208;
                        }
                        59 | 162 | 265 => {
                            issue_message();
                            continue 'c_125208;
                        }
                        58 | 161 | 264 => {
                            shift_case();
                            continue 'c_125208;
                        }
                        20 | 123 | 226 => {
                            show_whatever();
                            continue 'c_125208;
                        }
                        60 | 163 | 266 => {
                            do_extension();
                            continue 'c_125208;
                        }
                        1 | 104 | 207 | 11 | 217 | 272 | _ => {
                            continue 'c_125208;
                        }
                    }
                }
            }
            /*main_loop *//*1069: */
            if cur_list.head == cur_list.tail && cur_list.mode as i32 > 0i32 {
                if insert_src_special_auto {
                    append_src_special();
                }
            }
            prev_class = 4096i32 - 1i32;
            if font_area[
                (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32) as isize,
                ))
                .b32
                .s1 as usize] as u32
                == 0xffffu32
                || font_area[
                    (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32) as isize,
                    ))
                    .b32
                    .s1 as usize] as u32 == 0xfffeu32
            {
                if cur_list.mode as i32 > 0i32 {
                    if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 50i32) as isize,
                    ))
                    .b32
                    .s1 != cur_list.aux.b32.s1
                    {
                        fix_language();
                    }
                }
                main_h = 0i32;
                main_f = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32) as isize,
                ))
                .b32
                .s1;
                native_len = 0i32;
                loop {
                    /*collect_native */
                    main_s = ((*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + cur_chr) as isize,
                    ))
                    .b32
                    .s1 as i64
                        % 65536) as i32;
                    if main_s == 1000i32 {
                        cur_list.aux.b32.s0 = 1000i32
                    } else if main_s < 1000i32 {
                        if main_s > 0i32 {
                            cur_list.aux.b32.s0 = main_s
                        }
                    } else if cur_list.aux.b32.s0 < 1000i32 {
                        cur_list.aux.b32.s0 = 1000i32
                    } else {
                        cur_list.aux.b32.s0 = main_s
                    }
                    cur_ptr = -0xfffffffi32;
                    space_class = ((*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + cur_chr) as isize,
                    ))
                    .b32
                    .s1 as i64
                        / 65536) as i32;
                    if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 75i32) as isize,
                    ))
                    .b32
                    .s1 > 0i32
                        && space_class != 4096i32
                    {
                        if prev_class == 4096i32 - 1i32 {
                            if cur_input.state as i32 != 0i32 || cur_input.index as i32 != 4i32 {
                                find_sa_element(
                                    6i32 as small_number,
                                    (4096i32 - 1i32) * 4096i32 + space_class,
                                    false,
                                );
                                if cur_ptr != -0xfffffffi32 {
                                    if cur_cmd as i32 != 11i32 {
                                        cur_cmd = 12i32 as eight_bits
                                    }
                                    cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr;
                                    back_input();
                                    cur_input.index = 4_u16;
                                    begin_token_list(
                                        (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1,
                                        17_u16,
                                    );
                                    continue 'c_125208;
                                }
                            }
                        } else {
                            find_sa_element(
                                6i32 as small_number,
                                prev_class * 4096i32 + space_class,
                                false,
                            );
                            if cur_ptr != -0xfffffffi32 {
                                if cur_cmd as i32 != 11i32 {
                                    cur_cmd = 12i32 as eight_bits
                                }
                                cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr;
                                back_input();
                                cur_input.index = 4_u16;
                                begin_token_list(
                                    (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1,
                                    17_u16,
                                );
                                prev_class = 4096i32 - 1i32;
                                current_block = 9706274459985797855;
                                break;
                            }
                        }
                        prev_class = space_class
                    }
                    if cur_chr as i64 > 65535 {
                        while native_text_size <= native_len + 2i32 {
                            native_text_size = native_text_size + 128i32;
                            native_text = xrealloc(
                                native_text as *mut libc::c_void,
                                (native_text_size as u64).wrapping_mul(::std::mem::size_of::<
                                    UTF16_code,
                                >(
                                )
                                    as u64),
                            ) as *mut UTF16_code
                        }
                        *native_text.offset(native_len as isize) =
                            ((cur_chr as i64 - 65536) / 1024i32 as i64 + 0xd800i32 as i64)
                                as UTF16_code;
                        native_len += 1;
                        *native_text.offset(native_len as isize) =
                            ((cur_chr as i64 - 65536) % 1024i32 as i64 + 0xdc00i32 as i64)
                                as UTF16_code;
                        native_len += 1
                    } else {
                        while native_text_size <= native_len + 1i32 {
                            native_text_size = native_text_size + 128i32;
                            native_text = xrealloc(
                                native_text as *mut libc::c_void,
                                (native_text_size as u64).wrapping_mul(::std::mem::size_of::<
                                    UTF16_code,
                                >(
                                )
                                    as u64),
                            ) as *mut UTF16_code
                        }
                        *native_text.offset(native_len as isize) = cur_chr as UTF16_code;
                        native_len += 1
                    }
                    is_hyph = cur_chr == *hyphen_char.offset(main_f as isize)
                        || (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32
                                + 1i32
                                + 3i32 * 256i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 72i32) as isize,
                        ))
                        .b32
                        .s1 > 0i32
                            && (cur_chr == 8212i32 || cur_chr == 8211i32);
                    if main_h == 0i32 && is_hyph as i32 != 0 {
                        main_h = native_len
                    }
                    get_next();
                    if cur_cmd as i32 == 11i32 || cur_cmd as i32 == 12i32 || cur_cmd as i32 == 68i32
                    {
                        continue;
                    }
                    x_token();
                    if cur_cmd as i32 == 11i32 || cur_cmd as i32 == 12i32 || cur_cmd as i32 == 68i32
                    {
                        continue;
                    }
                    if cur_cmd as i32 == 16i32 {
                        scan_usv_num();
                        cur_chr = cur_val
                    } else if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 75i32) as isize,
                    ))
                    .b32
                    .s1 > 0i32
                        && space_class != 4096i32
                        && prev_class != 4096i32 - 1i32
                    {
                        current_block = 14170946608255986518;
                        break;
                    } else {
                        current_block = 9706274459985797855;
                        break;
                    }
                }
                match current_block {
                    14170946608255986518 => {
                        prev_class = 4096i32 - 1i32;
                        find_sa_element(
                            6i32 as small_number,
                            space_class * 4096i32 + (4096i32 - 1i32),
                            false,
                        );
                        if cur_ptr != -0xfffffffi32 {
                            if cur_cs == 0i32 {
                                if cur_cmd as i32 == 16i32 {
                                    cur_cmd = 12i32 as eight_bits
                                }
                                cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr
                            } else {
                                cur_tok = 0x1ffffffi32 + cur_cs
                            }
                            back_input();
                            begin_token_list(
                                (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1,
                                17_u16,
                            );
                        }
                    }
                    _ => {}
                }
                /*collected */
                if !(*font_mapping.offset(main_f as isize)).is_null() {
                    main_k = apply_mapping(
                        *font_mapping.offset(main_f as isize),
                        native_text,
                        native_len,
                    );
                    native_len = 0i32;
                    while native_text_size <= native_len + main_k {
                        native_text_size = native_text_size + 128i32;
                        native_text = xrealloc(
                            native_text as *mut libc::c_void,
                            (native_text_size as u64)
                                .wrapping_mul(::std::mem::size_of::<UTF16_code>() as u64),
                        ) as *mut UTF16_code
                    }
                    main_h = 0i32;
                    let mut for_end: i32 = 0;
                    main_p = 0i32;
                    for_end = main_k - 1i32;
                    if main_p <= for_end {
                        loop {
                            *native_text.offset(native_len as isize) =
                                *mapped_text.offset(main_p as isize);
                            native_len += 1;
                            if main_h == 0i32
                                && (*mapped_text.offset(main_p as isize) as i32
                                    == *hyphen_char.offset(main_f as isize)
                                    || (*eqtb.offset(
                                        (1i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 1i32
                                            + 15000i32
                                            + 12i32
                                            + 9000i32
                                            + 1i32
                                            + 1i32
                                            + 19i32
                                            + 256i32
                                            + 256i32
                                            + 13i32
                                            + 256i32
                                            + 4i32
                                            + 256i32
                                            + 1i32
                                            + 3i32 * 256i32
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + (0x10ffffi32 + 1i32)
                                            + 72i32)
                                            as isize,
                                    ))
                                    .b32
                                    .s1 > 0i32
                                        && (*mapped_text.offset(main_p as isize) as i32 == 8212i32
                                            || *mapped_text.offset(main_p as isize) as i32
                                                == 8211i32))
                            {
                                main_h = native_len
                            }
                            let fresh88 = main_p;
                            main_p = main_p + 1;
                            if !(fresh88 < for_end) {
                                break;
                            }
                        }
                    }
                }
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 35i32) as isize,
                ))
                .b32
                .s1 > 0i32
                {
                    temp_ptr = 0i32;
                    while temp_ptr < native_len {
                        main_k = *native_text.offset(temp_ptr as isize) as font_index;
                        temp_ptr += 1;
                        if main_k >= 0xd800i32 && main_k < 0xdc00i32 {
                            main_k =
                                (65536 + ((main_k - 0xd800i32) * 1024i32) as i64) as font_index;
                            main_k =
                                main_k + *native_text.offset(temp_ptr as isize) as i32 - 0xdc00i32;
                            temp_ptr += 1
                        }
                        if map_char_to_glyph(main_f, main_k) == 0i32 {
                            char_warning(main_f, main_k);
                        }
                    }
                }
                main_k = native_len;
                main_pp = cur_list.tail;
                if cur_list.mode as i32 == 104i32 {
                    main_ppp = cur_list.head;
                    if main_ppp != main_pp {
                        while (*mem.offset(main_ppp as isize)).b32.s1 != main_pp {
                            if !is_char_node(main_ppp)
                                && (*mem.offset(main_ppp as isize)).b16.s1 as i32 == 7i32
                            {
                                temp_ptr = main_ppp;
                                let mut for_end_0: i32 = 0;
                                main_p = 1i32;
                                for_end_0 = (*mem.offset(temp_ptr as isize)).b16.s0 as i32;
                                if main_p <= for_end_0 {
                                    loop {
                                        main_ppp = (*mem.offset(main_ppp as isize)).b32.s1;
                                        let fresh89 = main_p;
                                        main_p = main_p + 1;
                                        if !(fresh89 < for_end_0) {
                                            break;
                                        }
                                    }
                                }
                            }
                            if main_ppp != main_pp {
                                main_ppp = (*mem.offset(main_ppp as isize)).b32.s1
                            }
                        }
                    }
                    temp_ptr = 0i32;
                    loop {
                        if main_h == 0i32 {
                            main_h = main_k
                        }
                        if main_pp != -0xfffffffi32
                            && !is_char_node(main_pp)
                            && (*mem.offset(main_pp as isize)).b16.s1 as i32 == 8i32
                            && ((*mem.offset(main_pp as isize)).b16.s0 as i32 == 40i32
                                || (*mem.offset(main_pp as isize)).b16.s0 as i32 == 41i32)
                            && (*mem.offset((main_pp + 4i32) as isize)).b16.s2 as i32 == main_f
                            && main_ppp != main_pp
                            && !is_char_node(main_ppp)
                            && (*mem.offset(main_ppp as isize)).b16.s1 as i32 != 7i32
                        {
                            main_k =
                                main_h + (*mem.offset((main_pp + 4i32) as isize)).b16.s1 as i32;
                            while native_text_size <= native_len + main_k {
                                native_text_size = native_text_size + 128i32;
                                native_text =
                                    xrealloc(
                                        native_text as *mut libc::c_void,
                                        (native_text_size as u64).wrapping_mul(
                                            ::std::mem::size_of::<UTF16_code>() as u64,
                                        ),
                                    ) as *mut UTF16_code
                            }
                            save_native_len = native_len;
                            let mut for_end_1: i32 = 0;
                            main_p = 0i32;
                            for_end_1 =
                                (*mem.offset((main_pp + 4i32) as isize)).b16.s1 as i32 - 1i32;
                            if main_p <= for_end_1 {
                                loop {
                                    *native_text.offset(native_len as isize) = *(&mut *mem
                                        .offset((main_pp + 6i32) as isize)
                                        as *mut memory_word
                                        as *mut u16)
                                        .offset(main_p as isize);
                                    native_len += 1;
                                    let fresh90 = main_p;
                                    main_p = main_p + 1;
                                    if !(fresh90 < for_end_1) {
                                        break;
                                    }
                                }
                            }
                            let mut for_end_2: i32 = 0;
                            main_p = 0i32;
                            for_end_2 = main_h - 1i32;
                            if main_p <= for_end_2 {
                                loop {
                                    *native_text.offset(native_len as isize) =
                                        *native_text.offset((temp_ptr + main_p) as isize);
                                    native_len += 1;
                                    let fresh91 = main_p;
                                    main_p = main_p + 1;
                                    if !(fresh91 < for_end_2) {
                                        break;
                                    }
                                }
                            }
                            do_locale_linebreaks(save_native_len, main_k);
                            native_len = save_native_len;
                            main_k = native_len - main_h - temp_ptr;
                            temp_ptr = main_h;
                            main_h = 0i32;
                            while main_h < main_k
                                && *native_text.offset((temp_ptr + main_h) as isize) as i32
                                    != *hyphen_char.offset(main_f as isize)
                                && (!((*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 72i32) as isize,
                                ))
                                .b32
                                .s1 > 0i32)
                                    || *native_text.offset((temp_ptr + main_h) as isize) as i32
                                        != 8212i32
                                        && *native_text.offset((temp_ptr + main_h) as isize) as i32
                                            != 8211i32)
                            {
                                main_h += 1
                            }
                            if main_h < main_k {
                                main_h += 1
                            }
                            (*mem.offset(main_ppp as isize)).b32.s1 =
                                (*mem.offset(main_pp as isize)).b32.s1;
                            (*mem.offset(main_pp as isize)).b32.s1 = -0xfffffffi32;
                            flush_node_list(main_pp);
                            main_pp = cur_list.tail;
                            while (*mem.offset(main_ppp as isize)).b32.s1 != main_pp {
                                main_ppp = (*mem.offset(main_ppp as isize)).b32.s1
                            }
                        } else {
                            do_locale_linebreaks(temp_ptr, main_h);
                            temp_ptr = temp_ptr + main_h;
                            main_k = main_k - main_h;
                            main_h = 0i32;
                            while main_h < main_k
                                && *native_text.offset((temp_ptr + main_h) as isize) as i32
                                    != *hyphen_char.offset(main_f as isize)
                                && (!((*eqtb.offset(
                                    (1i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 1i32
                                        + 15000i32
                                        + 12i32
                                        + 9000i32
                                        + 1i32
                                        + 1i32
                                        + 19i32
                                        + 256i32
                                        + 256i32
                                        + 13i32
                                        + 256i32
                                        + 4i32
                                        + 256i32
                                        + 1i32
                                        + 3i32 * 256i32
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + (0x10ffffi32 + 1i32)
                                        + 72i32) as isize,
                                ))
                                .b32
                                .s1 > 0i32)
                                    || *native_text.offset((temp_ptr + main_h) as isize) as i32
                                        != 8212i32
                                        && *native_text.offset((temp_ptr + main_h) as isize) as i32
                                            != 8211i32)
                            {
                                main_h += 1
                            }
                            if main_h < main_k {
                                main_h += 1
                            }
                        }
                        if main_k > 0i32 || is_hyph as i32 != 0 {
                            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_disc();
                            cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1;
                            main_pp = cur_list.tail
                        }
                        if main_k == 0i32 {
                            break;
                        }
                    }
                } else {
                    main_ppp = cur_list.head;
                    if main_ppp != main_pp {
                        while (*mem.offset(main_ppp as isize)).b32.s1 != main_pp {
                            if !is_char_node(main_ppp)
                                && (*mem.offset(main_ppp as isize)).b16.s1 as i32 == 7i32
                            {
                                temp_ptr = main_ppp;
                                let mut for_end_3: i32 = 0;
                                main_p = 1i32;
                                for_end_3 = (*mem.offset(temp_ptr as isize)).b16.s0 as i32;
                                if main_p <= for_end_3 {
                                    loop {
                                        main_ppp = (*mem.offset(main_ppp as isize)).b32.s1;
                                        let fresh92 = main_p;
                                        main_p = main_p + 1;
                                        if !(fresh92 < for_end_3) {
                                            break;
                                        }
                                    }
                                }
                            }
                            if main_ppp != main_pp {
                                main_ppp = (*mem.offset(main_ppp as isize)).b32.s1
                            }
                        }
                    }
                    if main_pp != -0xfffffffi32
                        && !is_char_node(main_pp)
                        && (*mem.offset(main_pp as isize)).b16.s1 as i32 == 8i32
                        && ((*mem.offset(main_pp as isize)).b16.s0 as i32 == 40i32
                            || (*mem.offset(main_pp as isize)).b16.s0 as i32 == 41i32)
                        && (*mem.offset((main_pp + 4i32) as isize)).b16.s2 as i32 == main_f
                        && main_ppp != main_pp
                        && !is_char_node(main_ppp)
                        && (*mem.offset(main_ppp as isize)).b16.s1 as i32 != 7i32
                    {
                        (*mem.offset(main_pp as isize)).b32.s1 = new_native_word_node(
                            main_f,
                            main_k + (*mem.offset((main_pp + 4i32) as isize)).b16.s1 as i32,
                        );
                        cur_list.tail = (*mem.offset(main_pp as isize)).b32.s1;
                        let mut for_end_4: i32 = 0;
                        main_p = 0i32;
                        for_end_4 = (*mem.offset((main_pp + 4i32) as isize)).b16.s1 as i32 - 1i32;
                        if main_p <= for_end_4 {
                            loop {
                                *(&mut *mem.offset((cur_list.tail + 6i32) as isize)
                                    as *mut memory_word
                                    as *mut u16)
                                    .offset(main_p as isize) = *(&mut *mem
                                    .offset((main_pp + 6i32) as isize)
                                    as *mut memory_word
                                    as *mut u16)
                                    .offset(main_p as isize);
                                let fresh93 = main_p;
                                main_p = main_p + 1;
                                if !(fresh93 < for_end_4) {
                                    break;
                                }
                            }
                        }
                        let mut for_end_5: i32 = 0;
                        main_p = 0i32;
                        for_end_5 = main_k - 1i32;
                        if main_p <= for_end_5 {
                            loop {
                                *(&mut *mem.offset((cur_list.tail + 6i32) as isize)
                                    as *mut memory_word
                                    as *mut u16)
                                    .offset(
                                        (main_p
                                            + (*mem.offset((main_pp + 4i32) as isize)).b16.s1
                                                as i32)
                                            as isize,
                                    ) = *native_text.offset(main_p as isize);
                                let fresh94 = main_p;
                                main_p = main_p + 1;
                                if !(fresh94 < for_end_5) {
                                    break;
                                }
                            }
                        }
                        measure_native_node(
                            &mut *mem.offset(cur_list.tail as isize) as *mut memory_word
                                as *mut libc::c_void,
                            ((*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 74i32) as isize,
                            ))
                            .b32
                            .s1 > 0i32) as i32,
                        );
                        main_p = cur_list.head;
                        if main_p != main_pp {
                            while (*mem.offset(main_p as isize)).b32.s1 != main_pp {
                                main_p = (*mem.offset(main_p as isize)).b32.s1
                            }
                        }
                        (*mem.offset(main_p as isize)).b32.s1 =
                            (*mem.offset(main_pp as isize)).b32.s1;
                        (*mem.offset(main_pp as isize)).b32.s1 = -0xfffffffi32;
                        flush_node_list(main_pp);
                    } else {
                        (*mem.offset(main_pp as isize)).b32.s1 =
                            new_native_word_node(main_f, main_k);
                        cur_list.tail = (*mem.offset(main_pp as isize)).b32.s1;
                        let mut for_end_6: i32 = 0;
                        main_p = 0i32;
                        for_end_6 = main_k - 1i32;
                        if main_p <= for_end_6 {
                            loop {
                                *(&mut *mem.offset((cur_list.tail + 6i32) as isize)
                                    as *mut memory_word
                                    as *mut u16)
                                    .offset(main_p as isize) = *native_text.offset(main_p as isize);
                                let fresh95 = main_p;
                                main_p = main_p + 1;
                                if !(fresh95 < for_end_6) {
                                    break;
                                }
                            }
                        }
                        measure_native_node(
                            &mut *mem.offset(cur_list.tail as isize) as *mut memory_word
                                as *mut libc::c_void,
                            ((*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32
                                    + 1i32
                                    + 3i32 * 256i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 74i32) as isize,
                            ))
                            .b32
                            .s1 > 0i32) as i32,
                        );
                    }
                }
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 80i32) as isize,
                ))
                .b32
                .s1 > 0i32
                {
                    main_p = cur_list.head;
                    main_pp = -0xfffffffi32;
                    while main_p != cur_list.tail {
                        if main_p != -0xfffffffi32
                            && !is_char_node(main_p)
                            && (*mem.offset(main_p as isize)).b16.s1 as i32 == 8i32
                            && ((*mem.offset(main_p as isize)).b16.s0 as i32 == 40i32
                                || (*mem.offset(main_p as isize)).b16.s0 as i32 == 41i32)
                        {
                            main_pp = main_p
                        }
                        main_p = (*mem.offset(main_p as isize)).b32.s1
                    }
                    if main_pp != -0xfffffffi32 {
                        if (*mem.offset((main_pp + 4i32) as isize)).b16.s2 as i32 == main_f {
                            main_p = (*mem.offset(main_pp as isize)).b32.s1;
                            while !is_char_node(main_p)
                                && ((*mem.offset(main_p as isize)).b16.s1 as i32 == 12i32
                                    || (*mem.offset(main_p as isize)).b16.s1 as i32 == 3i32
                                    || (*mem.offset(main_p as isize)).b16.s1 as i32 == 4i32
                                    || (*mem.offset(main_p as isize)).b16.s1 as i32 == 5i32
                                    || (*mem.offset(main_p as isize)).b16.s1 as i32 == 8i32
                                        && (*mem.offset(main_p as isize)).b16.s0 as i32 <= 4i32)
                            {
                                main_p = (*mem.offset(main_p as isize)).b32.s1
                            }
                            if !is_char_node(main_p)
                                && (*mem.offset(main_p as isize)).b16.s1 as i32 == 10i32
                            {
                                main_ppp = (*mem.offset(main_p as isize)).b32.s1;
                                while !is_char_node(main_ppp)
                                    && ((*mem.offset(main_ppp as isize)).b16.s1 as i32 == 12i32
                                        || (*mem.offset(main_ppp as isize)).b16.s1 as i32 == 3i32
                                        || (*mem.offset(main_ppp as isize)).b16.s1 as i32 == 4i32
                                        || (*mem.offset(main_ppp as isize)).b16.s1 as i32 == 5i32
                                        || (*mem.offset(main_ppp as isize)).b16.s1 as i32 == 8i32
                                            && (*mem.offset(main_ppp as isize)).b16.s0 as i32
                                                <= 4i32)
                                {
                                    main_ppp = (*mem.offset(main_ppp as isize)).b32.s1
                                }
                                if main_ppp == cur_list.tail {
                                    temp_ptr = new_native_word_node(
                                        main_f,
                                        (*mem.offset((main_pp + 4i32) as isize)).b16.s1 as i32
                                            + 1i32
                                            + (*mem.offset((cur_list.tail + 4i32) as isize)).b16.s1
                                                as i32,
                                    );
                                    main_k = 0i32;
                                    let mut for_end_7: i32 = 0;
                                    t = 0i32;
                                    for_end_7 = (*mem.offset((main_pp + 4i32) as isize)).b16.s1
                                        as i32
                                        - 1i32;
                                    if t <= for_end_7 {
                                        loop {
                                            *(&mut *mem.offset((temp_ptr + 6i32) as isize)
                                                as *mut memory_word
                                                as *mut u16)
                                                .offset(main_k as isize) = *(&mut *mem
                                                .offset((main_pp + 6i32) as isize)
                                                as *mut memory_word
                                                as *mut u16)
                                                .offset(t as isize);
                                            main_k += 1;
                                            let fresh96 = t;
                                            t = t + 1;
                                            if !(fresh96 < for_end_7) {
                                                break;
                                            }
                                        }
                                    }
                                    *(&mut *mem.offset((temp_ptr + 6i32) as isize)
                                        as *mut memory_word
                                        as *mut u16)
                                        .offset(main_k as isize) = ' ' as i32 as u16;
                                    main_k += 1;
                                    let mut for_end_8: i32 = 0;
                                    t = 0i32;
                                    for_end_8 = (*mem.offset((cur_list.tail + 4i32) as isize))
                                        .b16
                                        .s1 as i32
                                        - 1i32;
                                    if t <= for_end_8 {
                                        loop {
                                            *(&mut *mem.offset((temp_ptr + 6i32) as isize)
                                                as *mut memory_word
                                                as *mut u16)
                                                .offset(main_k as isize) = *(&mut *mem
                                                .offset((cur_list.tail + 6i32) as isize)
                                                as *mut memory_word
                                                as *mut u16)
                                                .offset(t as isize);
                                            main_k += 1;
                                            let fresh97 = t;
                                            t = t + 1;
                                            if !(fresh97 < for_end_8) {
                                                break;
                                            }
                                        }
                                    }
                                    measure_native_node(
                                        &mut *mem.offset(temp_ptr as isize) as *mut memory_word
                                            as *mut libc::c_void,
                                        ((*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 13i32
                                                + 256i32
                                                + 4i32
                                                + 256i32
                                                + 1i32
                                                + 3i32 * 256i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 74i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1 > 0i32) as i32,
                                    );
                                    t = (*mem.offset((temp_ptr + 1i32) as isize)).b32.s1
                                        - (*mem.offset((main_pp + 1i32) as isize)).b32.s1
                                        - (*mem.offset((cur_list.tail + 1i32) as isize)).b32.s1;
                                    free_node(
                                        temp_ptr,
                                        (*mem.offset((temp_ptr + 4i32) as isize)).b16.s3 as i32,
                                    );
                                    if t != (*mem.offset(
                                        (*font_glue.offset(main_f as isize) + 1i32) as isize,
                                    ))
                                    .b32
                                    .s1
                                    {
                                        temp_ptr = new_kern(
                                            t - (*mem.offset(
                                                (*font_glue.offset(main_f as isize) + 1i32)
                                                    as isize,
                                            ))
                                            .b32
                                            .s1,
                                        );
                                        (*mem.offset(temp_ptr as isize)).b16.s0 = 3_u16;
                                        (*mem.offset(temp_ptr as isize)).b32.s1 =
                                            (*mem.offset(main_p as isize)).b32.s1;
                                        (*mem.offset(main_p as isize)).b32.s1 = temp_ptr
                                    }
                                }
                            }
                        }
                    }
                }
                if cur_ptr != -0xfffffffi32 {
                    continue 'c_125208;
                }
            } else {
                main_s = ((*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + cur_chr) as isize,
                ))
                .b32
                .s1 as i64
                    % 65536) as i32;
                if main_s == 1000i32 {
                    cur_list.aux.b32.s0 = 1000i32
                } else if main_s < 1000i32 {
                    if main_s > 0i32 {
                        cur_list.aux.b32.s0 = main_s
                    }
                } else if cur_list.aux.b32.s0 < 1000i32 {
                    cur_list.aux.b32.s0 = 1000i32
                } else {
                    cur_list.aux.b32.s0 = main_s
                }
                cur_ptr = -0xfffffffi32;
                space_class = ((*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + cur_chr) as isize,
                ))
                .b32
                .s1 as i64
                    / 65536) as i32;
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 75i32) as isize,
                ))
                .b32
                .s1 > 0i32
                    && space_class != 4096i32
                {
                    if prev_class == 4096i32 - 1i32 {
                        if cur_input.state as i32 != 0i32 || cur_input.index as i32 != 4i32 {
                            find_sa_element(
                                6i32 as small_number,
                                (4096i32 - 1i32) * 4096i32 + space_class,
                                false,
                            );
                            if cur_ptr != -0xfffffffi32 {
                                if cur_cmd as i32 != 11i32 {
                                    cur_cmd = 12i32 as eight_bits
                                }
                                cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr;
                                back_input();
                                cur_input.index = 4_u16;
                                begin_token_list(
                                    (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1,
                                    17_u16,
                                );
                                continue 'c_125208;
                            }
                        }
                    } else {
                        find_sa_element(
                            6i32 as small_number,
                            prev_class * 4096i32 + space_class,
                            false,
                        );
                        if cur_ptr != -0xfffffffi32 {
                            if cur_cmd as i32 != 11i32 {
                                cur_cmd = 12i32 as eight_bits
                            }
                            cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr;
                            back_input();
                            cur_input.index = 4_u16;
                            begin_token_list(
                                (*mem.offset((cur_ptr + 1i32) as isize)).b32.s1,
                                17_u16,
                            );
                            prev_class = 4096i32 - 1i32;
                            continue 'c_125208;
                        }
                    }
                    prev_class = space_class
                }
                main_f = (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32) as isize,
                ))
                .b32
                .s1;
                bchar = *font_bchar.offset(main_f as isize);
                false_bchar = *font_false_bchar.offset(main_f as isize);
                if cur_list.mode as i32 > 0i32 {
                    if (*eqtb.offset(
                        (1i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 1i32
                            + 15000i32
                            + 12i32
                            + 9000i32
                            + 1i32
                            + 1i32
                            + 19i32
                            + 256i32
                            + 256i32
                            + 13i32
                            + 256i32
                            + 4i32
                            + 256i32
                            + 1i32
                            + 3i32 * 256i32
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + (0x10ffffi32 + 1i32)
                            + 50i32) as isize,
                    ))
                    .b32
                    .s1 != cur_list.aux.b32.s1
                    {
                        fix_language();
                    }
                }
                lig_stack = avail;
                if lig_stack == -0xfffffffi32 {
                    lig_stack = get_avail()
                } else {
                    avail = (*mem.offset(lig_stack as isize)).b32.s1;
                    (*mem.offset(lig_stack as isize)).b32.s1 = -0xfffffffi32
                }
                (*mem.offset(lig_stack as isize)).b16.s1 = main_f as u16;
                cur_l = cur_chr;
                (*mem.offset(lig_stack as isize)).b16.s0 = cur_l as u16;
                cur_q = cur_list.tail;
                if cancel_boundary {
                    cancel_boundary = false;
                    main_k = 0i32
                } else {
                    main_k = *bchar_label.offset(main_f as isize)
                }
                if main_k == 0i32 {
                    current_block = 249799543778823886;
                } else {
                    cur_r = cur_l;
                    cur_l = 65536i32;
                    current_block = 13962460947151495567;
                }
                'c_125239: loop {
                    match current_block {
                        13962460947151495567 => {
                            /*main_lig_loop 1 */
                            main_j = (*font_info.offset(main_k as isize)).b16;
                            current_block = 11331079115679122507;
                        }
                        _ =>
                        /*main_loop_move 2 */
                        {
                            if effective_char(false, main_f, cur_chr as u16)
                                > *font_ec.offset(main_f as isize) as i32
                                || effective_char(false, main_f, cur_chr as u16)
                                    < *font_bc.offset(main_f as isize) as i32
                            {
                                char_warning(main_f, cur_chr);
                                (*mem.offset(lig_stack as isize)).b32.s1 = avail;
                                avail = lig_stack;
                                continue 'c_125208;
                            } else {
                                main_i = effective_char_info(main_f, cur_l as u16);
                                if !(main_i.s3 as i32 > 0i32) {
                                    char_warning(main_f, cur_chr);
                                    (*mem.offset(lig_stack as isize)).b32.s1 = avail;
                                    avail = lig_stack;
                                    continue 'c_125208;
                                } else {
                                    (*mem.offset(cur_list.tail as isize)).b32.s1 = lig_stack;
                                    cur_list.tail = lig_stack
                                }
                            }
                            current_block = 18270385712206273994;
                        }
                    }
                    'c_125244: loop {
                        match current_block {
                            11331079115679122507 =>
                            /*main_lig_loop 2 */
                            {
                                if main_j.s2 as i32 == cur_r {
                                    if main_j.s3 as i32 <= 128i32 {
                                        /*1075: */
                                        if main_j.s1 as i32 >= 128i32 {
                                            if cur_l < 65536i32 {
                                                if (*mem.offset(cur_q as isize)).b32.s1
                                                    > -0xfffffffi32
                                                {
                                                    if (*mem.offset(cur_list.tail as isize)).b16.s0
                                                        as i32
                                                        == *hyphen_char.offset(main_f as isize)
                                                    {
                                                        ins_disc = true
                                                    }
                                                }
                                                if ligature_present {
                                                    main_p = new_ligature(
                                                        main_f,
                                                        cur_l as u16,
                                                        (*mem.offset(cur_q as isize)).b32.s1,
                                                    );
                                                    if lft_hit {
                                                        (*mem.offset(main_p as isize)).b16.s0 =
                                                            2_u16;
                                                        lft_hit = false
                                                    }
                                                    if rt_hit {
                                                        if lig_stack == -0xfffffffi32 {
                                                            let ref mut fresh99 = (*mem
                                                                .offset(main_p as isize))
                                                            .b16
                                                            .s0;
                                                            *fresh99 = (*fresh99).wrapping_add(1);
                                                            rt_hit = false
                                                        }
                                                    }
                                                    (*mem.offset(cur_q as isize)).b32.s1 = main_p;
                                                    cur_list.tail = main_p;
                                                    ligature_present = false
                                                }
                                                if ins_disc {
                                                    ins_disc = false;
                                                    if cur_list.mode as i32 > 0i32 {
                                                        (*mem.offset(cur_list.tail as isize))
                                                            .b32
                                                            .s1 = new_disc();
                                                        cur_list.tail = (*mem
                                                            .offset(cur_list.tail as isize))
                                                        .b32
                                                        .s1
                                                    }
                                                }
                                            }
                                            (*mem.offset(cur_list.tail as isize)).b32.s1 = new_kern(
                                                (*font_info.offset(
                                                    (*kern_base.offset(main_f as isize)
                                                        + 256i32 * main_j.s1 as i32
                                                        + main_j.s0 as i32)
                                                        as isize,
                                                ))
                                                .b32
                                                .s1,
                                            );
                                            cur_list.tail =
                                                (*mem.offset(cur_list.tail as isize)).b32.s1;
                                            current_block = 2772858075894446251;
                                        } else {
                                            if cur_l == 65536i32 {
                                                lft_hit = true
                                            } else if lig_stack == -0xfffffffi32 {
                                                rt_hit = true
                                            }
                                            match main_j.s1 as i32 {
                                                1 | 5 => {
                                                    cur_l = main_j.s0 as i32;
                                                    main_i = (*font_info.offset(
                                                        (*char_base.offset(main_f as isize)
                                                            + effective_char(
                                                                true,
                                                                main_f,
                                                                cur_l as u16,
                                                            ))
                                                            as isize,
                                                    ))
                                                    .b16;
                                                    ligature_present = true;
                                                    current_block = 5062343687657450649;
                                                }
                                                2 | 6 => {
                                                    cur_r = main_j.s0 as i32;
                                                    if lig_stack == -0xfffffffi32 {
                                                        lig_stack = new_lig_item(cur_r as u16);
                                                        bchar = 65536i32
                                                    } else if is_char_node(lig_stack) {
                                                        main_p = lig_stack;
                                                        lig_stack = new_lig_item(cur_r as u16);
                                                        (*mem.offset((lig_stack + 1i32) as isize))
                                                            .b32
                                                            .s1 = main_p
                                                    } else {
                                                        (*mem.offset(lig_stack as isize)).b16.s0 =
                                                            cur_r as u16
                                                    }
                                                    current_block = 5062343687657450649;
                                                }
                                                3 => {
                                                    cur_r = main_j.s0 as i32;
                                                    main_p = lig_stack;
                                                    lig_stack = new_lig_item(cur_r as u16);
                                                    (*mem.offset(lig_stack as isize)).b32.s1 =
                                                        main_p;
                                                    current_block = 5062343687657450649;
                                                }
                                                7 | 11 => {
                                                    if cur_l < 65536i32 {
                                                        if (*mem.offset(cur_q as isize)).b32.s1
                                                            > -0xfffffffi32
                                                        {
                                                            if (*mem.offset(cur_list.tail as isize))
                                                                .b16
                                                                .s0
                                                                as i32
                                                                == *hyphen_char
                                                                    .offset(main_f as isize)
                                                            {
                                                                ins_disc = true
                                                            }
                                                        }
                                                        if ligature_present {
                                                            main_p = new_ligature(
                                                                main_f,
                                                                cur_l as u16,
                                                                (*mem.offset(cur_q as isize))
                                                                    .b32
                                                                    .s1,
                                                            );
                                                            if lft_hit {
                                                                (*mem.offset(main_p as isize))
                                                                    .b16
                                                                    .s0 = 2_u16;
                                                                lft_hit = false
                                                            }
                                                            (*mem.offset(cur_q as isize)).b32.s1 =
                                                                main_p;
                                                            cur_list.tail = main_p;
                                                            ligature_present = false
                                                        }
                                                        if ins_disc {
                                                            ins_disc = false;
                                                            if cur_list.mode as i32 > 0i32 {
                                                                (*mem.offset(
                                                                    cur_list.tail as isize,
                                                                ))
                                                                .b32
                                                                .s1 = new_disc();
                                                                cur_list.tail = (*mem
                                                                    .offset(cur_list.tail as isize))
                                                                .b32
                                                                .s1
                                                            }
                                                        }
                                                    }
                                                    cur_q = cur_list.tail;
                                                    cur_l = main_j.s0 as i32;
                                                    main_i = (*font_info.offset(
                                                        (*char_base.offset(main_f as isize)
                                                            + effective_char(
                                                                true,
                                                                main_f,
                                                                cur_l as u16,
                                                            ))
                                                            as isize,
                                                    ))
                                                    .b16;
                                                    ligature_present = true;
                                                    current_block = 5062343687657450649;
                                                }
                                                _ => {
                                                    cur_l = main_j.s0 as i32;
                                                    ligature_present = true;
                                                    if lig_stack == -0xfffffffi32 {
                                                        current_block = 7236688557761431611;
                                                    } else {
                                                        current_block = 4014385708774270501;
                                                    }
                                                }
                                            }
                                            match current_block {
                                                7236688557761431611 => {}
                                                4014385708774270501 => {}
                                                _ => {
                                                    if main_j.s1 as i32 > 4i32 {
                                                        if main_j.s1 as i32 != 7i32 {
                                                            current_block = 7236688557761431611;
                                                        } else {
                                                            current_block = 17785146416239343017;
                                                        }
                                                    } else {
                                                        current_block = 17785146416239343017;
                                                    }
                                                    match current_block {
                                                        7236688557761431611 => {}
                                                        _ => {
                                                            if cur_l < 65536i32 {
                                                                current_block = 4700797278417140031;
                                                            } else {
                                                                main_k = *bchar_label
                                                                    .offset(main_f as isize);
                                                                current_block =
                                                                    13962460947151495567;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        current_block = 17910696963991344696;
                                    }
                                } else {
                                    current_block = 17910696963991344696;
                                }
                                match current_block {
                                    2772858075894446251 => {}
                                    7236688557761431611 => {}
                                    4014385708774270501 => {}
                                    4700797278417140031 => {}
                                    _ => {
                                        if main_j.s3 as i32 == 0i32 {
                                            main_k += 1;
                                            current_block = 13962460947151495567;
                                            break;
                                        } else if !(main_j.s3 as i32 >= 128i32) {
                                            main_k = main_k + main_j.s3 as i32 + 1i32;
                                            current_block = 13962460947151495567;
                                            break;
                                        }
                                        current_block = 7236688557761431611;
                                    }
                                }
                            }
                            _ => {
                                /*main_loop_lookahead *//*1073: */
                                get_next();
                                if cur_cmd as i32 == 11i32 {
                                    current_block = 10120566026430170701;
                                } else if cur_cmd as i32 == 12i32 {
                                    current_block = 10120566026430170701;
                                } else if cur_cmd as i32 == 68i32 {
                                    current_block = 10120566026430170701;
                                } else {
                                    x_token();
                                    if cur_cmd as i32 == 11i32 {
                                        current_block = 10120566026430170701;
                                    } else if cur_cmd as i32 == 12i32 {
                                        current_block = 10120566026430170701;
                                    } else if cur_cmd as i32 == 68i32 {
                                        current_block = 10120566026430170701;
                                    } else if cur_cmd as i32 == 16i32 {
                                        scan_char_num();
                                        cur_chr = cur_val;
                                        current_block = 10120566026430170701;
                                    } else {
                                        if cur_cmd as i32 == 65i32 {
                                            bchar = 65536i32
                                        }
                                        cur_r = bchar;
                                        lig_stack = -0xfffffffi32;
                                        current_block = 4700797278417140031;
                                    }
                                }
                                match current_block {
                                    4700797278417140031 => {}
                                    _ => {
                                        /*main_loop_lookahead 1 */
                                        main_s = ((*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 13i32
                                                + 256i32
                                                + 4i32
                                                + 256i32
                                                + 1i32
                                                + 3i32 * 256i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + cur_chr)
                                                as isize,
                                        ))
                                        .b32
                                        .s1
                                            as i64
                                            % 65536)
                                            as i32; /*:1073 */
                                        if main_s == 1000i32 {
                                            cur_list.aux.b32.s0 = 1000i32
                                        } else if main_s < 1000i32 {
                                            if main_s > 0i32 {
                                                cur_list.aux.b32.s0 = main_s
                                            }
                                        } else if cur_list.aux.b32.s0 < 1000i32 {
                                            cur_list.aux.b32.s0 = 1000i32
                                        } else {
                                            cur_list.aux.b32.s0 = main_s
                                        }
                                        cur_ptr = -0xfffffffi32;
                                        space_class = ((*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 13i32
                                                + 256i32
                                                + 4i32
                                                + 256i32
                                                + 1i32
                                                + 3i32 * 256i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + cur_chr)
                                                as isize,
                                        ))
                                        .b32
                                        .s1
                                            as i64
                                            / 65536)
                                            as i32;
                                        if (*eqtb.offset(
                                            (1i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 1i32
                                                + 15000i32
                                                + 12i32
                                                + 9000i32
                                                + 1i32
                                                + 1i32
                                                + 19i32
                                                + 256i32
                                                + 256i32
                                                + 13i32
                                                + 256i32
                                                + 4i32
                                                + 256i32
                                                + 1i32
                                                + 3i32 * 256i32
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + (0x10ffffi32 + 1i32)
                                                + 75i32)
                                                as isize,
                                        ))
                                        .b32
                                        .s1 > 0i32
                                            && space_class != 4096i32
                                        {
                                            if prev_class == 4096i32 - 1i32 {
                                                if cur_input.state as i32 != 0i32
                                                    || cur_input.index as i32 != 4i32
                                                {
                                                    find_sa_element(
                                                        6i32 as small_number,
                                                        (4096i32 - 1i32) * 4096i32 + space_class,
                                                        false,
                                                    );
                                                    if cur_ptr != -0xfffffffi32 {
                                                        if cur_cmd as i32 != 11i32 {
                                                            cur_cmd = 12i32 as eight_bits
                                                        }
                                                        cur_tok =
                                                            cur_cmd as i32 * 0x200000i32 + cur_chr;
                                                        back_input();
                                                        cur_input.index = 4_u16;
                                                        begin_token_list(
                                                            (*mem
                                                                .offset((cur_ptr + 1i32) as isize))
                                                            .b32
                                                            .s1,
                                                            17_u16,
                                                        );
                                                        continue 'c_125208;
                                                    }
                                                }
                                            } else {
                                                find_sa_element(
                                                    6i32 as small_number,
                                                    prev_class * 4096i32 + space_class,
                                                    false,
                                                );
                                                if cur_ptr != -0xfffffffi32 {
                                                    if cur_cmd as i32 != 11i32 {
                                                        cur_cmd = 12i32 as eight_bits
                                                    }
                                                    cur_tok =
                                                        cur_cmd as i32 * 0x200000i32 + cur_chr;
                                                    back_input();
                                                    cur_input.index = 4_u16;
                                                    begin_token_list(
                                                        (*mem.offset((cur_ptr + 1i32) as isize))
                                                            .b32
                                                            .s1,
                                                        17_u16,
                                                    );
                                                    prev_class = 4096i32 - 1i32;
                                                    continue 'c_125208;
                                                }
                                            }
                                            prev_class = space_class
                                        }
                                        lig_stack = avail;
                                        if lig_stack == -0xfffffffi32 {
                                            lig_stack = get_avail()
                                        } else {
                                            avail = (*mem.offset(lig_stack as isize)).b32.s1;
                                            (*mem.offset(lig_stack as isize)).b32.s1 = -0xfffffffi32
                                        }
                                        (*mem.offset(lig_stack as isize)).b16.s1 = main_f as u16;
                                        cur_r = cur_chr;
                                        (*mem.offset(lig_stack as isize)).b16.s0 = cur_r as u16;
                                        if cur_r == false_bchar {
                                            cur_r = 65536i32
                                        }
                                        current_block = 4700797278417140031;
                                    }
                                }
                            }
                        }
                        loop {
                            match current_block {
                                7236688557761431611 => {
                                    /*main_loop_wrapup *//*1070: */
                                    if cur_l < 65536i32 {
                                        if (*mem.offset(cur_q as isize)).b32.s1 > -0xfffffffi32 {
                                            if (*mem.offset(cur_list.tail as isize)).b16.s0 as i32
                                                == *hyphen_char.offset(main_f as isize)
                                            {
                                                ins_disc = true
                                            }
                                        }
                                        if ligature_present {
                                            main_p = new_ligature(
                                                main_f,
                                                cur_l as u16,
                                                (*mem.offset(cur_q as isize)).b32.s1,
                                            );
                                            if lft_hit {
                                                (*mem.offset(main_p as isize)).b16.s0 = 2_u16;
                                                lft_hit = false
                                            }
                                            if rt_hit {
                                                if lig_stack == -0xfffffffi32 {
                                                    let ref mut fresh98 =
                                                        (*mem.offset(main_p as isize)).b16.s0;
                                                    *fresh98 = (*fresh98).wrapping_add(1);
                                                    rt_hit = false
                                                }
                                            }
                                            (*mem.offset(cur_q as isize)).b32.s1 = main_p;
                                            cur_list.tail = main_p;
                                            ligature_present = false
                                        }
                                        if ins_disc {
                                            ins_disc = false;
                                            if cur_list.mode as i32 > 0i32 {
                                                (*mem.offset(cur_list.tail as isize)).b32.s1 =
                                                    new_disc();
                                                cur_list.tail =
                                                    (*mem.offset(cur_list.tail as isize)).b32.s1
                                            }
                                        }
                                    }
                                    current_block = 2772858075894446251;
                                }
                                4700797278417140031 =>
                                /*main_lig_loop *//*1074: */
                                {
                                    if main_i.s1 as i32 % 4i32 != 1i32 {
                                        current_block = 7236688557761431611;
                                        continue;
                                    }
                                    if cur_r == 65536i32 {
                                        current_block = 7236688557761431611;
                                    } else {
                                        break;
                                    }
                                }
                                2772858075894446251 =>
                                /*main_loop_move *//*1071: */
                                {
                                    if lig_stack == -0xfffffffi32 {
                                        break 'c_125239;
                                    }
                                    cur_q = cur_list.tail;
                                    cur_l = (*mem.offset(lig_stack as isize)).b16.s0 as i32;
                                    current_block = 4014385708774270501;
                                }
                                _ =>
                                /*main_loop_move 1 */
                                {
                                    if is_char_node(lig_stack) {
                                        current_block = 249799543778823886;
                                        break 'c_125244;
                                    }
                                    /*main_loop_move_lig *//*1072: */
                                    main_p = (*mem.offset((lig_stack + 1i32) as isize)).b32.s1;
                                    if main_p > -0xfffffffi32 {
                                        (*mem.offset(cur_list.tail as isize)).b32.s1 = main_p;
                                        cur_list.tail = (*mem.offset(cur_list.tail as isize)).b32.s1
                                    }
                                    temp_ptr = lig_stack;
                                    lig_stack = (*mem.offset(temp_ptr as isize)).b32.s1;
                                    free_node(temp_ptr, 2i32);
                                    main_i = (*font_info.offset(
                                        (*char_base.offset(main_f as isize)
                                            + effective_char(1i32 != 0, main_f, cur_l as u16))
                                            as isize,
                                    ))
                                    .b16;
                                    ligature_present = true;
                                    if lig_stack == -0xfffffffi32 {
                                        if main_p > -0xfffffffi32 {
                                            current_block = 18270385712206273994;
                                            continue 'c_125244;
                                        }
                                        cur_r = bchar;
                                        current_block = 4700797278417140031;
                                    } else {
                                        cur_r = (*mem.offset(lig_stack as isize)).b16.s0 as i32;
                                        current_block = 4700797278417140031;
                                    }
                                }
                            }
                        }
                        main_k = *lig_kern_base.offset(main_f as isize) + main_i.s0 as i32;
                        main_j = (*font_info.offset(main_k as isize)).b16;
                        if main_j.s3 as i32 <= 128i32 {
                            current_block = 11331079115679122507;
                            continue;
                        }
                        main_k = ((*lig_kern_base.offset(main_f as isize)
                            + 256i32 * main_j.s1 as i32
                            + main_j.s0 as i32) as i64
                            + 32768
                            - (256i32 * 128i32) as i64)
                            as font_index;
                        current_block = 13962460947151495567;
                        break;
                    }
                }
            }
        }
        match current_block {
            11459959175219260272 => {
                app_space();
            }
            _ =>
            /*append_normal_space */
            {
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 19i32
                        + 256i32
                        + 256i32
                        + 13i32
                        + 256i32
                        + 4i32
                        + 256i32
                        + 1i32
                        + 3i32 * 256i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 75i32) as isize,
                ))
                .b32
                .s1 > 0i32
                    && space_class != 4096i32
                    && prev_class != 4096i32 - 1i32
                {
                    prev_class = 4096i32 - 1i32;
                    find_sa_element(
                        6i32 as small_number,
                        space_class * 4096i32 + (4096i32 - 1i32),
                        false,
                    );
                    if cur_ptr != -0xfffffffi32 {
                        if cur_cs == 0i32 {
                            if cur_cmd as i32 == 16i32 {
                                cur_cmd = 12i32 as eight_bits
                            }
                            cur_tok = cur_cmd as i32 * 0x200000i32 + cur_chr
                        } else {
                            cur_tok = 0x1ffffffi32 + cur_cs
                        }
                        back_input();
                        begin_token_list((*mem.offset((cur_ptr + 1i32) as isize)).b32.s1, 17_u16);
                        continue;
                    }
                }
                if (*eqtb.offset(
                    (1i32
                        + (0x10ffffi32 + 1i32)
                        + (0x10ffffi32 + 1i32)
                        + 1i32
                        + 15000i32
                        + 12i32
                        + 9000i32
                        + 1i32
                        + 1i32
                        + 12i32) as isize,
                ))
                .b32
                .s1 == 0i32
                {
                    main_p = *font_glue.offset(
                        (*eqtb.offset(
                            (1i32
                                + (0x10ffffi32 + 1i32)
                                + (0x10ffffi32 + 1i32)
                                + 1i32
                                + 15000i32
                                + 12i32
                                + 9000i32
                                + 1i32
                                + 1i32
                                + 19i32
                                + 256i32
                                + 256i32
                                + 13i32
                                + 256i32
                                + 4i32
                                + 256i32) as isize,
                        ))
                        .b32
                        .s1 as isize,
                    );
                    if main_p == -0xfffffffi32 {
                        main_p = new_spec(0i32);
                        main_k = *param_base.offset(
                            (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32) as isize,
                            ))
                            .b32
                            .s1 as isize,
                        ) + 2i32;
                        (*mem.offset((main_p + 1i32) as isize)).b32.s1 =
                            (*font_info.offset(main_k as isize)).b32.s1;
                        (*mem.offset((main_p + 2i32) as isize)).b32.s1 =
                            (*font_info.offset((main_k + 1i32) as isize)).b32.s1;
                        (*mem.offset((main_p + 3i32) as isize)).b32.s1 =
                            (*font_info.offset((main_k + 2i32) as isize)).b32.s1;
                        *font_glue.offset(
                            (*eqtb.offset(
                                (1i32
                                    + (0x10ffffi32 + 1i32)
                                    + (0x10ffffi32 + 1i32)
                                    + 1i32
                                    + 15000i32
                                    + 12i32
                                    + 9000i32
                                    + 1i32
                                    + 1i32
                                    + 19i32
                                    + 256i32
                                    + 256i32
                                    + 13i32
                                    + 256i32
                                    + 4i32
                                    + 256i32) as isize,
                            ))
                            .b32
                            .s1 as isize,
                        ) = main_p
                    }
                    temp_ptr = new_glue(main_p)
                } else {
                    temp_ptr = new_param_glue(12i32 as small_number)
                }
                (*mem.offset(cur_list.tail as isize)).b32.s1 = temp_ptr;
                cur_list.tail = temp_ptr
            }
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn give_err_help() {
    token_show(
        (*eqtb.offset(
            (1i32
                + (0x10ffffi32 + 1i32)
                + (0x10ffffi32 + 1i32)
                + 1i32
                + 15000i32
                + 12i32
                + 9000i32
                + 1i32
                + 1i32
                + 19i32
                + 256i32
                + 256i32
                + 9i32) as isize,
        ))
        .b32
        .s1,
    );
}
#[no_mangle]
pub unsafe extern "C" fn close_files_and_terminate() {
    let mut k: i32 = 0;
    terminate_font_manager();
    k = 0i32;
    while k <= 15i32 {
        if write_open[k as usize] {
            ttstub_output_close(write_file[k as usize].take().unwrap());
        }
        k += 1
    }
    finalize_dvi_file();
    synctex_terminate(log_opened);
    if log_opened {
        ttstub_output_putc(log_file.as_mut().unwrap(), '\n' as i32);
        ttstub_output_close(log_file.take().unwrap());
        log_file = None;
        selector = u8::from(selector).wrapping_sub(2).into();
        if selector == Selector::TERM_ONLY {
            print_nl_cstr(b"Transcript written on \x00" as *const u8 as *const i8);
            print(texmf_log_name);
            print_char('.' as i32);
        }
    }
    print_ln();
}
#[no_mangle]
pub unsafe extern "C" fn flush_str(mut s: str_number) {
    if s == str_ptr - 1i32 {
        str_ptr -= 1;
        pool_ptr = *str_start.offset((str_ptr - 65536i32) as isize)
    };
}
#[no_mangle]
pub unsafe extern "C" fn tokens_to_string(mut p: i32) -> str_number {
    if selector == Selector::NEW_STRING {
        pdf_error(
            b"tokens\x00" as *const u8 as *const i8,
            b"tokens_to_string() called while selector = new_string\x00" as *const u8 as *const i8,
        );
    }
    old_setting = selector;
    selector = Selector::NEW_STRING;
    show_token_list(
        (*mem.offset(p as isize)).b32.s1,
        -0xfffffffi32,
        pool_size - pool_ptr,
    );
    selector = old_setting;
    make_string()
}
#[no_mangle]
pub unsafe extern "C" fn scan_pdf_ext_toks() {
    scan_toks(false, true);
}
#[no_mangle]
pub unsafe extern "C" fn compare_strings() {
    let mut current_block: u64;
    let mut s1: str_number = 0;
    let mut s2: str_number = 0;
    let mut i1: pool_pointer = 0;
    let mut i2: pool_pointer = 0;
    let mut j1: pool_pointer = 0;
    let mut j2: pool_pointer = 0;
    scan_toks(false, true);
    s1 = tokens_to_string(def_ref);
    delete_token_ref(def_ref);
    scan_toks(false, true);
    s2 = tokens_to_string(def_ref);
    delete_token_ref(def_ref);
    i1 = *str_start.offset((s1 as i64 - 65536) as isize);
    j1 = *str_start.offset(((s1 + 1i32) as i64 - 65536) as isize);
    i2 = *str_start.offset((s2 as i64 - 65536) as isize);
    j2 = *str_start.offset(((s2 + 1i32) as i64 - 65536) as isize);
    loop {
        if !(i1 < j1 && i2 < j2) {
            current_block = 12124785117276362961;
            break;
        }
        if (*str_pool.offset(i1 as isize) as i32) < *str_pool.offset(i2 as isize) as i32 {
            cur_val = -1i32;
            current_block = 11833780966967478830;
            break;
        } else if *str_pool.offset(i1 as isize) as i32 > *str_pool.offset(i2 as isize) as i32 {
            cur_val = 1i32;
            current_block = 11833780966967478830;
            break;
        } else {
            i1 += 1;
            i2 += 1
        }
    }
    match current_block {
        12124785117276362961 => {
            if i1 == j1 && i2 == j2 {
                cur_val = 0i32
            } else if i1 < j1 {
                cur_val = 1i32
            } else {
                cur_val = -1i32
            }
        }
        _ => {}
    }
    flush_str(s2);
    flush_str(s1);
    cur_val_level = 0_u8;
}
#[no_mangle]
pub unsafe extern "C" fn prune_page_top(mut p: i32, mut s: bool) -> i32 {
    let mut prev_p: i32 = 0;
    let mut q: i32 = 0;
    let mut r: i32 = -0xfffffffi32;
    prev_p = 4999999i32 - 3i32;
    (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1 = p;
    while p != -0xfffffffi32 {
        match (*mem.offset(p as isize)).b16.s1 as i32 {
            0 | 1 | 2 => {
                q = new_skip_param(10i32 as small_number);
                (*mem.offset(prev_p as isize)).b32.s1 = q;
                (*mem.offset(q as isize)).b32.s1 = p;
                if (*mem.offset((temp_ptr + 1i32) as isize)).b32.s1
                    > (*mem.offset((p + 3i32) as isize)).b32.s1
                {
                    (*mem.offset((temp_ptr + 1i32) as isize)).b32.s1 =
                        (*mem.offset((temp_ptr + 1i32) as isize)).b32.s1
                            - (*mem.offset((p + 3i32) as isize)).b32.s1
                } else {
                    (*mem.offset((temp_ptr + 1i32) as isize)).b32.s1 = 0i32
                }
                p = -0xfffffffi32
            }
            8 | 4 | 3 => {
                prev_p = p;
                p = (*mem.offset(prev_p as isize)).b32.s1
            }
            10 | 11 | 12 => {
                q = p;
                p = (*mem.offset(q as isize)).b32.s1;
                (*mem.offset(q as isize)).b32.s1 = -0xfffffffi32;
                (*mem.offset(prev_p as isize)).b32.s1 = p;
                if s {
                    if disc_ptr[3] == -0xfffffffi32 {
                        disc_ptr[3] = q
                    } else {
                        (*mem.offset(r as isize)).b32.s1 = q
                    }
                    r = q
                } else {
                    flush_node_list(q);
                }
            }
            _ => {
                confusion(b"pruning\x00" as *const u8 as *const i8);
            }
        }
    }
    (*mem.offset((4999999i32 - 3i32) as isize)).b32.s1
}
#[no_mangle]
pub unsafe extern "C" fn do_marks(mut a: small_number, mut l: small_number, mut q: i32) -> bool {
    let mut i: small_number = 0;
    if (l as i32) < 4i32 {
        i = 0i32 as small_number;
        while i as i32 <= 15i32 {
            if i as i32 & 1i32 != 0 {
                cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1
            } else {
                cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0
            }
            if cur_ptr != -0xfffffffi32 {
                if do_marks(a, (l as i32 + 1i32) as small_number, cur_ptr) {
                    if i as i32 & 1i32 != 0 {
                        (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 = -0xfffffffi32
                    } else {
                        (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 = -0xfffffffi32
                    }
                    let ref mut fresh101 = (*mem.offset(q as isize)).b16.s0;
                    *fresh101 = (*fresh101).wrapping_sub(1)
                }
            }
            i += 1
        }
        if (*mem.offset(q as isize)).b16.s0 as i32 == 0i32 {
            free_node(q, 33i32);
            q = -0xfffffffi32
        }
    } else {
        match a as i32 {
            0 => {
                /*1614: */
                if (*mem.offset((q + 2i32) as isize)).b32.s1 != -0xfffffffi32 {
                    delete_token_ref((*mem.offset((q + 2i32) as isize)).b32.s1);
                    (*mem.offset((q + 2i32) as isize)).b32.s1 = -0xfffffffi32;
                    delete_token_ref((*mem.offset((q + 3i32) as isize)).b32.s0);
                    (*mem.offset((q + 3i32) as isize)).b32.s0 = -0xfffffffi32
                }
            }
            1 => {
                if (*mem.offset((q + 2i32) as isize)).b32.s0 != -0xfffffffi32 {
                    if (*mem.offset((q + 1i32) as isize)).b32.s0 != -0xfffffffi32 {
                        delete_token_ref((*mem.offset((q + 1i32) as isize)).b32.s0);
                    }
                    delete_token_ref((*mem.offset((q + 1i32) as isize)).b32.s1);
                    (*mem.offset((q + 1i32) as isize)).b32.s1 = -0xfffffffi32;
                    if (*mem.offset((*mem.offset((q + 2i32) as isize)).b32.s0 as isize))
                        .b32
                        .s1
                        == -0xfffffffi32
                    {
                        delete_token_ref((*mem.offset((q + 2i32) as isize)).b32.s0);
                        (*mem.offset((q + 2i32) as isize)).b32.s0 = -0xfffffffi32
                    } else {
                        let ref mut fresh102 = (*mem
                            .offset((*mem.offset((q + 2i32) as isize)).b32.s0 as isize))
                        .b32
                        .s0;
                        *fresh102 += 1
                    }
                    (*mem.offset((q + 1i32) as isize)).b32.s0 =
                        (*mem.offset((q + 2i32) as isize)).b32.s0
                }
            }
            2 => {
                if (*mem.offset((q + 1i32) as isize)).b32.s0 != -0xfffffffi32
                    && (*mem.offset((q + 1i32) as isize)).b32.s1 == -0xfffffffi32
                {
                    (*mem.offset((q + 1i32) as isize)).b32.s1 =
                        (*mem.offset((q + 1i32) as isize)).b32.s0;
                    let ref mut fresh103 = (*mem
                        .offset((*mem.offset((q + 1i32) as isize)).b32.s0 as isize))
                    .b32
                    .s0;
                    *fresh103 += 1
                }
            }
            3 => {
                i = 0i32 as small_number;
                while i as i32 <= 4i32 {
                    if i as i32 & 1i32 != 0 {
                        cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1
                    } else {
                        cur_ptr = (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0
                    }
                    if cur_ptr != -0xfffffffi32 {
                        delete_token_ref(cur_ptr);
                        if i as i32 & 1i32 != 0 {
                            (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s1 =
                                -0xfffffffi32
                        } else {
                            (*mem.offset((q + i as i32 / 2i32 + 1i32) as isize)).b32.s0 =
                                -0xfffffffi32
                        }
                    }
                    i += 1
                }
            }
            _ => {}
        }
        if (*mem.offset((q + 2i32) as isize)).b32.s0 == -0xfffffffi32 {
            if (*mem.offset((q + 3i32) as isize)).b32.s0 == -0xfffffffi32 {
                free_node(q, 4i32);
                q = -0xfffffffi32
            }
        }
    }
    q == -0xfffffffi32
}
#[no_mangle]
pub unsafe extern "C" fn do_assignments() {
    loop {
        loop {
            get_x_token();
            if !(cur_cmd as i32 == 10i32 || cur_cmd as i32 == 0i32) {
                break;
            }
        }
        if cur_cmd as i32 <= 71i32 {
            return;
        }
        set_box_allowed = false;
        prefixed_command();
        set_box_allowed = true
    }
}
/* the former xetexcoerce.h: */
#[no_mangle]
pub unsafe extern "C" fn new_whatsit(mut s: small_number, mut w: small_number) {
    let mut p: i32 = 0;
    p = get_node(w as i32);
    (*mem.offset(p as isize)).b16.s1 = 8_u16;
    (*mem.offset(p as isize)).b16.s0 = s as u16;
    (*mem.offset(cur_list.tail as isize)).b32.s1 = p;
    cur_list.tail = p;
}
